#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Prove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE';
  package App::Prove;use strict;use warnings;use TAP::Harness::Env;use Text::ParseWords qw(shellwords);use File::Spec;use Getopt::Long;use App::Prove::State;use Carp;use base 'TAP::Object';our$VERSION='3.36';use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>$^O eq 'VMS';use constant IS_UNIXY=>!(IS_VMS || IS_WIN32);use constant STATE_FILE=>IS_UNIXY ? '.prove' : '_prove';use constant RC_FILE=>IS_UNIXY ? '.proverc' : '_proverc';use constant PLUGINS=>'App::Prove::Plugin';my@ATTR;BEGIN {@ATTR=qw(archive argv blib show_count color directives exec failures comments formatter harness includes modules plugins jobs lib merge parse quiet really_quiet recurse backwards shuffle taint_fail taint_warn timer verbose warnings_fail warnings_warn show_help show_man show_version state_class test_args state dry extensions ignore_exit rules state_manager normalize sources tapversion trap);__PACKAGE__->mk_methods(@ATTR)}sub _initialize {my$self=shift;my$args=shift || {};my@is_array=qw(argv rc_opts includes modules state plugins rules sources);for my$key (@is_array){$self->{$key}=[]}for my$attr (@ATTR){if (exists$args->{$attr}){$self->{$attr}=$args->{$attr}}}$self->state_class('App::Prove::State');return$self}sub add_rc_file {my ($self,$rc_file)=@_;local*RC;open RC,"<$rc_file" or croak "Can't read $rc_file ($!)";while (defined(my$line=<RC>)){push @{$self->{rc_opts}},grep {defined and not /^#/}$line =~ m{ ' ([^']*) ' | " ([^"]*) " | (\#.*) | (\S+) }xg}close RC}sub process_args {my$self=shift;my@rc=RC_FILE;unshift@rc,glob '~/' .RC_FILE if IS_UNIXY;my@args;while (defined(my$arg=shift)){if ($arg eq '--norc'){@rc=()}elsif ($arg eq '--rc'){defined(my$rc=shift)or croak "Missing argument to --rc";push@rc,$rc}elsif ($arg =~ m{^--rc=(.+)$}){push@rc,$1}else {push@args,$arg}}if (defined(my$stop_at=_first_pos('::',@args))){my@test_args=splice@args,$stop_at;shift@test_args;$self->{test_args}=\@test_args}$self->add_rc_file($_)for grep -f,@rc;unshift@args,@{$self->{rc_opts}};if (my@bad=map {"-$_"}grep {/^-(man|help)$/}@args){die "Long options should be written with two dashes: ",join(', ',@bad),"\n"}{local@ARGV=@args;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through));GetOptions('v|verbose'=>\$self->{verbose},'f|failures'=>\$self->{failures},'o|comments'=>\$self->{comments},'l|lib'=>\$self->{lib},'b|blib'=>\$self->{blib},'s|shuffle'=>\$self->{shuffle},'color!'=>\$self->{color},'colour!'=>\$self->{color},'count!'=>\$self->{show_count},'c'=>\$self->{color},'D|dry'=>\$self->{dry},'ext=s@'=>sub {my ($opt,$val)=@_;push @{$self->{extensions}||= []},$val},'harness=s'=>\$self->{harness},'ignore-exit'=>\$self->{ignore_exit},'source=s@'=>$self->{sources},'formatter=s'=>\$self->{formatter},'r|recurse'=>\$self->{recurse},'reverse'=>\$self->{backwards},'p|parse'=>\$self->{parse},'q|quiet'=>\$self->{quiet},'Q|QUIET'=>\$self->{really_quiet},'e|exec=s'=>\$self->{exec},'m|merge'=>\$self->{merge},'I=s@'=>$self->{includes},'M=s@'=>$self->{modules},'P=s@'=>$self->{plugins},'state=s@'=>$self->{state},'directives'=>\$self->{directives},'h|help|?'=>\$self->{show_help},'H|man'=>\$self->{show_man},'V|version'=>\$self->{show_version},'a|archive=s'=>\$self->{archive},'j|jobs=i'=>\$self->{jobs},'timer'=>\$self->{timer},'T'=>\$self->{taint_fail},'t'=>\$self->{taint_warn},'W'=>\$self->{warnings_fail},'w'=>\$self->{warnings_warn},'normalize'=>\$self->{normalize},'rules=s@'=>$self->{rules},'tapversion=s'=>\$self->{tapversion},'trap'=>\$self->{trap},)or croak('Unable to continue');$self->{argv}=[@ARGV]}return}sub _first_pos {my$want=shift;for (0 .. $#_){return $_ if $_[$_]eq $want}return}sub _help {my ($self,$verbosity)=@_;eval('use Pod::Usage 1.12 ()');if (my$err=$@){die 'Please install Pod::Usage for the --help option ' .'(or try `perldoc prove`.)' ."\n ($@)"}Pod::Usage::pod2usage({-verbose=>$verbosity });return}sub _color_default {my$self=shift;return -t STDOUT &&!$ENV{HARNESS_NOTTY}&&!IS_WIN32}sub _get_args {my$self=shift;my%args;$args{trap}=1 if$self->trap;if (defined$self->color ? $self->color : $self->_color_default){$args{color}=1}if (!defined$self->show_count){$args{show_count}=1}else {$args{show_count}=$self->show_count}if ($self->archive){$self->require_harness(archive=>'TAP::Harness::Archive');$args{archive}=$self->archive}if (my$jobs=$self->jobs){$args{jobs}=$jobs}if (my$harness_opt=$self->harness){$self->require_harness(harness=>$harness_opt)}if (my$formatter=$self->formatter){$args{formatter_class}=$formatter}for my$handler (@{$self->sources}){my ($name,$config)=$self->_parse_source($handler);$args{sources}->{$name}=$config}if ($self->ignore_exit){$args{ignore_exit}=1}if ($self->taint_fail && $self->taint_warn){die '-t and -T are mutually exclusive'}if ($self->warnings_fail && $self->warnings_warn){die '-w and -W are mutually exclusive'}for my$a (qw(lib switches)){my$method="_get_$a";my$val=$self->$method();$args{$a}=$val if defined$val}my%verb_map=(verbose=>1,quiet=>-1,really_quiet=>-2,);my@verb_adj=grep {$_}map {$self->$_()? $verb_map{$_}: 0}keys%verb_map;die "Only one of verbose, quiet or really_quiet should be specified\n" if@verb_adj > 1;$args{verbosity}=shift@verb_adj || 0;for my$a (qw(merge failures comments timer directives normalize)){$args{$a}=1 if$self->$a()}$args{errors}=1 if$self->parse;$args{exec}=[split(/\s+/,$self->exec)]if (defined($self->exec));$args{version}=$self->tapversion if defined($self->tapversion);if (defined(my$test_args=$self->test_args)){$args{test_args}=$test_args}if (@{$self->rules}){my@rules;for (@{$self->rules}){if (/^par=(.*)/){push@rules,$1}elsif (/^seq=(.*)/){push@rules,{seq=>$1 }}}$args{rules}={par=>[@rules]}}$args{harness_class}=$self->{harness_class}if$self->{harness_class};return \%args}sub _find_module {my ($self,$class,@search)=@_;croak "Bad module name $class" unless$class =~ /^ \w+ (?: :: \w+ ) *$/x;for my$pfx (@search){my$name=join('::',$pfx,$class);eval "require $name";return$name unless $@}eval "require $class";return$class unless $@;return}sub _load_extension {my ($self,$name,@search)=@_;my@args=();if ($name =~ /^(.*?)=(.*)/){$name=$1;@args=split(/,/,$2)}if (my$class=$self->_find_module($name,@search)){$class->import(@args);if ($class->can('load')){$class->load({app_prove=>$self,args=>[@args]})}}else {croak "Can't load module $name"}}sub _load_extensions {my ($self,$ext,@search)=@_;$self->_load_extension($_,@search)for @$ext}sub _parse_source {my ($self,$handler)=@_;(my$opt_name=lc$handler)=~ s/::/-/g;local@ARGV=@{$self->{argv}};my%config;Getopt::Long::GetOptions("$opt_name-option=s%"=>sub {my ($name,$k,$v)=@_;if ($v =~ /(?<!\\)=/){croak "Option $name must be consistently used as a hash" if exists$config{$k}&& ref$config{$k}ne 'HASH';$config{$k}||= {};my ($hk,$hv)=split /(?<!\\)=/,$v,2;$config{$k}{$hk}=$hv}else {$v =~ s/\\=/=/g;if (exists$config{$k}){$config{$k}=[$config{$k}]unless ref$config{$k}eq 'ARRAY';push @{$config{$k}}=>$v}else {$config{$k}=$v}}});$self->{argv}=\@ARGV;return ($handler,\%config)}sub run {my$self=shift;unless ($self->state_manager){$self->state_manager($self->state_class->new({store=>STATE_FILE }))}if ($self->show_help){$self->_help(1)}elsif ($self->show_man){$self->_help(2)}elsif ($self->show_version){$self->print_version}elsif ($self->dry){print "$_\n" for$self->_get_tests}else {$self->_load_extensions($self->modules);$self->_load_extensions($self->plugins,PLUGINS);local$ENV{TEST_VERBOSE}=1 if$self->verbose;return$self->_runtests($self->_get_args,$self->_get_tests)}return 1}sub _get_tests {my$self=shift;my$state=$self->state_manager;my$ext=$self->extensions;$state->extensions($ext)if defined$ext;if (defined(my$state_switch=$self->state)){$state->apply_switch(@$state_switch)}my@tests=$state->get_tests($self->recurse,@{$self->argv});$self->_shuffle(@tests)if$self->shuffle;@tests=reverse@tests if$self->backwards;return@tests}sub _runtests {my ($self,$args,@tests)=@_;my$harness=TAP::Harness::Env->create($args);my$state=$self->state_manager;$harness->callback(after_test=>sub {$state->observe_test(@_)});$harness->callback(after_runtests=>sub {$state->commit(@_)});my$aggregator=$harness->runtests(@tests);return!$aggregator->has_errors}sub _get_switches {my$self=shift;my@switches;if ($self->taint_fail){push@switches,'-T'}elsif ($self->taint_warn){push@switches,'-t'}if ($self->warnings_fail){push@switches,'-W'}elsif ($self->warnings_warn){push@switches,'-w'}return@switches ? \@switches : ()}sub _get_lib {my$self=shift;my@libs;if ($self->lib){push@libs,'lib'}if ($self->blib){push@libs,'blib/lib','blib/arch'}if (@{$self->includes}){push@libs,@{$self->includes}}@libs=map {File::Spec->rel2abs($_)}@libs;return@libs ? \@libs : ()}sub _shuffle {my$self=shift;my$i=@_;while ($i){my$j=rand$i--;@_[$i,$j ]=@_[$j,$i ]}return}sub require_harness {my ($self,$for,$class)=@_;my ($class_name)=$class =~ /^(\w+(?:::\w+)*)/;$class =~ s!^(\w+(?:::\w+)*)=(.*)$!$1 split(/,/,q{$2})!;eval("use $class;");die "$class_name is required to use the --$for feature: $@" if $@;$self->{harness_class}=$class_name;return}sub print_version {my$self=shift;require TAP::Harness;printf("TAP::Harness v%s and Perl v%vd\n",$TAP::Harness::VERSION,$^V);return}1;
APP_PROVE

$fatpacked{"App/Prove/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE';
  package App::Prove::State;use strict;use warnings;use File::Find;use File::Spec;use Carp;use App::Prove::State::Result;use TAP::Parser::YAMLish::Reader ();use TAP::Parser::YAMLish::Writer ();use base 'TAP::Base';BEGIN {__PACKAGE__->mk_methods('result_class')}use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant NEED_GLOB=>IS_WIN32;our$VERSION='3.36';sub new {my$class=shift;my%args=%{shift || {}};my$self=bless {select=>[],seq=>1,store=>delete$args{store},extensions=>(delete$args{extensions}|| ['.t']),result_class=>(delete$args{result_class}|| 'App::Prove::State::Result'),},$class;$self->{_}=$self->result_class->new({tests=>{},generation=>1,});my$store=$self->{store};$self->load($store)if defined$store && -f $store;return$self}sub extensions {my$self=shift;$self->{extensions}=shift if @_;return$self->{extensions}}sub results {my$self=shift;$self->{_}|| $self->result_class->new}sub commit {my$self=shift;if ($self->{should_save}){$self->save}}sub apply_switch {my$self=shift;my@opts=@_;my$last_gen=$self->results->generation - 1;my$last_run_time=$self->results->last_run_time;my$now=$self->get_time;my@switches=map {split /,/}@opts;my%handler=(last=>sub {$self->_select(limit=>shift,where=>sub {$_->generation >= $last_gen},order=>sub {$_->sequence})},failed=>sub {$self->_select(limit=>shift,where=>sub {$_->result!=0},order=>sub {-$_->result})},passed=>sub {$self->_select(limit=>shift,where=>sub {$_->result==0})},all=>sub {$self->_select(limit=>shift)},todo=>sub {$self->_select(limit=>shift,where=>sub {$_->num_todo!=0},order=>sub {-$_->num_todo})},hot=>sub {$self->_select(limit=>shift,where=>sub {defined $_->last_fail_time},order=>sub {$now - $_->last_fail_time})},slow=>sub {$self->_select(limit=>shift,order=>sub {-$_->elapsed})},fast=>sub {$self->_select(limit=>shift,order=>sub {$_->elapsed})},new=>sub {$self->_select(limit=>shift,order=>sub {-$_->mtime})},old=>sub {$self->_select(limit=>shift,order=>sub {$_->mtime})},fresh=>sub {$self->_select(limit=>shift,where=>sub {$_->mtime >= $last_run_time})},save=>sub {$self->{should_save}++},adrian=>sub {unshift@switches,qw(hot all save)},);while (defined(my$ele=shift@switches)){my ($opt,$arg)=($ele =~ /^([^:]+):(.*)/)? ($1,$2): ($ele,undef);my$code=$handler{$opt}|| croak "Illegal state option: $opt";$code->($arg)}return}sub _select {my ($self,%spec)=@_;push @{$self->{select}},\%spec}sub get_tests {my$self=shift;my$recurse=shift;my@argv=@_;my%seen;my@selected=$self->_query;unless (@argv || @{$self->{select}}){@argv=$recurse ? '.' : 't';croak qq{No tests named and '@argv' directory not found} unless -d $argv[0]}push@selected,$self->_get_raw_tests($recurse,@argv)if@argv;return grep {!$seen{$_}++}@selected}sub _query {my$self=shift;if (my@sel=@{$self->{select}}){warn "No saved state, selection will be empty\n" unless$self->results->num_tests;return map {$self->_query_clause($_)}@sel}return}sub _query_clause {my ($self,$clause)=@_;my@got;my$results=$self->results;my$where=$clause->{where}|| sub {1};for my$name ($results->test_names){next unless -f $name;local $_=$results->test($name);push@got,$name if$where->()}if (my$order=$clause->{order}){@got=map {$_->[0]}sort {(defined$b->[1]<=> defined$a->[1])|| (($a->[1]|| 0)<=> ($b->[1]|| 0))}map {[$_,do {local $_=$results->test($_);$order->()}]}@got}if (my$limit=$clause->{limit}){@got=splice@got,0,$limit if@got > $limit}return@got}sub _get_raw_tests {my$self=shift;my$recurse=shift;my@argv=@_;my@tests;if (NEED_GLOB){eval "use File::Glob::Windows";@argv=map {glob "$_"}@argv}my$extensions=$self->{extensions};for my$arg (@argv){if ('-' eq $arg){push@argv=><STDIN>;chomp(@argv);next}push@tests,sort -d $arg ? $recurse ? $self->_expand_dir_recursive($arg,$extensions): map {glob(File::Spec->catfile($arg,"*$_"))}@{$extensions}: $arg}return@tests}sub _expand_dir_recursive {my ($self,$dir,$extensions)=@_;my@tests;my$ext_string=join('|',map {quotemeta}@{$extensions});find({follow=>1,follow_skip=>2,wanted=>sub {-f && /(?:$ext_string)$/ && push@tests=>$File::Find::name}},$dir);return@tests}sub observe_test {my ($self,$test_info,$parser)=@_;my$name=$test_info->[0];my$fail=scalar($parser->failed)+ ($parser->has_problems ? 1 : 0);my$todo=scalar($parser->todo);my$start_time=$parser->start_time;my$end_time=$parser->end_time,my$test=$self->results->test($name);$test->sequence($self->{seq}++);$test->generation($self->results->generation);$test->run_time($end_time);$test->result($fail);$test->num_todo($todo);$test->elapsed($end_time - $start_time);$test->parser($parser);if ($fail){$test->total_failures($test->total_failures + 1);$test->last_fail_time($end_time)}else {$test->total_passes($test->total_passes + 1);$test->last_pass_time($end_time)}}sub save {my ($self)=@_;my$store=$self->{store}or return;$self->results->last_run_time($self->get_time);my$writer=TAP::Parser::YAMLish::Writer->new;local*FH;open FH,">$store" or croak "Can't write $store ($!)";$writer->write($self->results->raw,\*FH);close FH}sub load {my ($self,$name)=@_;my$reader=TAP::Parser::YAMLish::Reader->new;local*FH;open FH,"<$name" or croak "Can't read $name ($!)";$self->{_}=$self->result_class->new($reader->read(sub {my$line=<FH>;defined$line && chomp$line;return$line}));close FH;$self->_regen_seq;$self->_prune_and_stamp;$self->results->generation($self->results->generation + 1)}sub _prune_and_stamp {my$self=shift;my$results=$self->results;my@tests=$self->results->tests;for my$test (@tests){my$name=$test->name;if (my@stat=stat$name){$test->mtime($stat[9])}else {$results->remove($name)}}}sub _regen_seq {my$self=shift;for my$test ($self->results->tests){$self->{seq}=$test->sequence + 1 if defined$test->sequence && $test->sequence >= $self->{seq}}}1;
APP_PROVE_STATE

$fatpacked{"App/Prove/State/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT';
  package App::Prove::State::Result;use strict;use warnings;use Carp 'croak';use App::Prove::State::Result::Test;use constant STATE_VERSION=>1;our$VERSION='3.36';sub new {my ($class,$arg_for)=@_;$arg_for ||= {};my%instance_data=%$arg_for;$instance_data{version}=$class->state_version;my$tests=delete$instance_data{tests}|| {};my$self=bless \%instance_data=>$class;$self->_initialize($tests);return$self}sub _initialize {my ($self,$tests)=@_;my%tests;while (my ($name,$test)=each %$tests){$tests{$name}=$self->test_class->new({%$test,name=>$name})}$self->tests(\%tests);return$self}sub state_version {STATE_VERSION}sub test_class {return 'App::Prove::State::Result::Test'}my%methods=(generation=>{method=>'generation',default=>0 },last_run_time=>{method=>'last_run_time',default=>undef },);while (my ($key,$description)=each%methods){my$default=$description->{default};no strict 'refs';*{$description->{method}}=sub {my$self=shift;if (@_){$self->{$key}=shift;return$self}return$self->{$key}|| $default}}sub tests {my$self=shift;if (@_){$self->{tests}=shift;return$self}my%tests=%{$self->{tests}};my@tests=sort {$a->sequence <=> $b->sequence}values%tests;return wantarray ? @tests : \@tests}sub test {my ($self,$name)=@_;croak("test() requires a test name")unless defined$name;my$tests=$self->{tests}||= {};if (my$test=$tests->{$name}){return$test}else {my$test=$self->test_class->new({name=>$name });$self->{tests}->{$name}=$test;return$test}}sub test_names {my$self=shift;return map {$_->name}$self->tests}sub remove {my ($self,$name)=@_;delete$self->{tests}->{$name};return$self}sub num_tests {keys %{shift->{tests}}}sub raw {my$self=shift;my%raw=%$self;my%tests;for my$test ($self->tests){$tests{$test->name }=$test->raw}$raw{tests}=\%tests;return \%raw}1;
APP_PROVE_STATE_RESULT

$fatpacked{"App/Prove/State/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT_TEST';
  package App::Prove::State::Result::Test;use strict;use warnings;our$VERSION='3.36';my%methods=(name=>{method=>'name' },elapsed=>{method=>'elapsed',default=>0 },gen=>{method=>'generation',default=>1 },last_pass_time=>{method=>'last_pass_time',default=>undef },last_fail_time=>{method=>'last_fail_time',default=>undef },last_result=>{method=>'result',default=>0 },last_run_time=>{method=>'run_time',default=>undef },last_todo=>{method=>'num_todo',default=>0 },mtime=>{method=>'mtime',default=>undef },seq=>{method=>'sequence',default=>1 },total_passes=>{method=>'total_passes',default=>0 },total_failures=>{method=>'total_failures',default=>0 },parser=>{method=>'parser' },);while (my ($key,$description)=each%methods){my$default=$description->{default};no strict 'refs';*{$description->{method}}=sub {my$self=shift;if (@_){$self->{$key}=shift;return$self}return$self->{$key}|| $default}}sub new {my ($class,$arg_for)=@_;$arg_for ||= {};bless$arg_for=>$class}sub raw {my$self=shift;my%raw=%$self;delete$raw{name};delete$raw{parser};return \%raw}1;
APP_PROVE_STATE_RESULT_TEST

$fatpacked{"App/stew.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW';
  package App::stew;use 5.008001;use strict;use warnings;our$VERSION="0.01";1;
APP_STEW

$fatpacked{"App/stew/builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_BUILDER';
  package App::stew::builder;use strict;use warnings;use Cwd qw(abs_path getcwd);use Carp qw(croak);use File::Path qw(rmtree);use File::Basename qw(basename dirname);use App::stew::util qw(cmd info debug error _chdir _mkpath _copy _rmtree _tree);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{root_dir}=$params{root_dir};$self->{build_dir}=$params{build_dir};$self->{repo}=$params{repo};$self->{snapshot}=$params{snapshot};return$self}sub build {my$self=shift;my ($stew_tree)=@_;my$stew=$stew_tree->{stew};croak '$ENV{PREFIX} not defined' unless$ENV{PREFIX};_mkpath($ENV{PREFIX});info sprintf "Building '%s'...",$stew->package;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);my$cwd=getcwd();my$tree=[];eval {_rmtree$work_dir;_mkpath($work_dir);_chdir($work_dir);info sprintf "Checking dependencies...";$self->_check_dependencies($stew,$stew_tree);my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);my$dist_archive=basename$dist_path;my ($dist_name)=$dist_archive =~ m/^(.*)\.tar\.gz$/;_chdir($work_dir);$tree=$self->_build_from_source($stew,$dist_name);if (!$stew->is('cross-platform')){_chdir($work_dir);cmd("tar czhf $dist_archive -C $dist_name/$ENV{PREFIX}/ .");info sprintf "Saving '%s' as '$dist_path'...",$stew->package;_mkpath(dirname$dist_path);_copy$dist_archive,$dist_path}_chdir($cwd)}or do {my$e=$@;_chdir($cwd);die$e};return$tree}sub _build_from_source {my$self=shift;my ($stew,$dist_name)=@_;_mkpath($ENV{PREFIX});_mkpath$dist_name;$ENV{DESTDIR}=abs_path($dist_name);my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_mkpath$work_dir;_chdir($work_dir);if ($stew->url){my$src_file=$self->{repo}->mirror_file($stew->url,File::Spec->catfile($self->{repo}->{mirror_path},'src'));_copy($src_file,$work_dir)}else {my$src_file=$self->{repo}->mirror_src($stew->file);_copy($src_file,$work_dir)}if (my@files=$stew->files){for my$file (@files){my$src_file=$self->{repo}->mirror_src($file);_copy($src_file,$work_dir)}}info sprintf "Preparing '%s'...",$stew->package;$self->_run_stew_phase($stew,'prepare');info sprintf "Building '%s'...",$stew->package;$self->_run_stew_phase($stew,'build');info sprintf "Installing '%s'...",$stew->package;$self->_run_stew_phase($stew,'install');info sprintf "Cleaning '%s'...",$stew->package;$self->_run_stew_phase($stew,'cleanup');_chdir "$ENV{DESTDIR}/$ENV{PREFIX}";return _tree('.','.')}sub _run_stew_phase {my$self=shift;my ($stew,$phase)=@_;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_chdir($work_dir);my@commands=$stew->run($phase);cmd(@commands)}sub _check_dependencies {my$self=shift;my ($stew,$tree)=@_;my$build_dir=$self->{build_dir};my$work_dir=File::Spec->catfile($build_dir,$stew->package);my@depends=@{$tree->{dependencies}|| []};for my$tree (@depends){my$stew=$tree->{stew};die$stew->package ." is not up to date\n" unless$self->{snapshot}->is_up_to_date($stew->name,$stew->version)}}1;
APP_STEW_BUILDER

$fatpacked{"App/stew/cmd/autoremove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_AUTOREMOVE';
  package App::stew::cmd::autoremove;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::uninstaller;use App::stew::util qw(info);sub run {my$self=shift;my (@argv)=@_;my$opt_prefix='local';my$opt_base;my$opt_dry_run;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"dry-run"=>\$opt_dry_run,)or die "error";error("--base is required")unless$opt_base;my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;my$uninstaller=App::stew::uninstaller->new(base=>$opt_base,prefix=>$opt_prefix);my@not_required=$snapshot->list_not_required;if ($opt_dry_run){info sprintf "Will remove '%s'",join(', ',@not_required)}else {$uninstaller->uninstall(@not_required)}info "Done"}1;
APP_STEW_CMD_AUTOREMOVE

$fatpacked{"App/stew/cmd/base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_BASE';
  package App::stew::cmd::base;use strict;use warnings;sub new {my$class=shift;my$self={};bless$self,$class;return$self}1;
APP_STEW_CMD_BASE

$fatpacked{"App/stew/cmd/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_BUILD';
  package App::stew::cmd::build;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::repo;use App::stew::builder;use App::stew::index;use App::stew::tree;use App::stew::env;use App::stew::util qw(info debug error);sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_repo;my$opt_os;my$opt_arch;my$opt_build_dir='build';my$opt_verbose;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"repo=s"=>\$opt_repo,"os=s"=>\$opt_os,"arch=s"=>\$opt_arch,"build-dir=s"=>\$opt_build_dir,"verbose"=>\$opt_verbose,)or die "error";$opt_os //= App::stew::env->detect_os;$opt_arch //= App::stew::env->detect_arch;error("--base is required")unless$opt_base;error("--repo is required")unless$opt_repo;mkpath($opt_base);$opt_base=abs_path($opt_base);my$root_dir=abs_path(cwd());my$build_dir=abs_path($opt_build_dir);mkpath($build_dir);$ENV{STEW_LOG_LEVEL}=$opt_verbose ? 1 : 0;$ENV{STEW_LOG_FILE}="$build_dir/stew.log";unlink$ENV{STEW_LOG_FILE};my$repo=App::stew::repo->new(path=>$opt_repo,mirror_path=>"$build_dir/.cache",os=>$opt_os,arch=>$opt_arch);my$index=App::stew::index->new(repo=>$repo);my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;my@trees;for my$package (@argv){my$tree=App::stew::tree->new(repo=>$repo,index=>$index);my$dump=$tree->build($package);push@trees,$dump}$ENV{STEW_OS}=$opt_os;$ENV{STEW_ARCH}=$opt_arch;$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->new(prefix=>$ENV{PREFIX})->setup;my$builder=App::stew::builder->new(root_dir=>$root_dir,build_dir=>$build_dir,repo=>$repo,snapshot=>$snapshot,);for my$tree (@trees){$builder->build($tree)}info "Done"}1;
APP_STEW_CMD_BUILD

$fatpacked{"App/stew/cmd/exec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_EXEC';
  package App::stew::cmd::exec;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(abs_path);use File::Spec;use App::stew::env;use App::stew::util qw(info debug error);sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,)or die "error";error("--base is required")unless$opt_base;$opt_base=abs_path($opt_base);my$prefix=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->new(prefix=>$prefix)->setup;system(@argv)}1;
APP_STEW_CMD_EXEC

$fatpacked{"App/stew/cmd/help.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_HELP';
  package App::stew::cmd::help;use strict;use warnings;use base 'App::stew::cmd::base';use Pod::Find qw(pod_where);use Pod::Usage qw(pod2usage);use App::stew::cmdbuilder;sub run {my$self=shift;my ($command)=@_;my$command_instance=App::stew::cmdbuilder->new->build($command);pod2usage(-input=>pod_where({-inc=>1},ref($command_instance)),-verbose=>2)}1;
APP_STEW_CMD_HELP

$fatpacked{"App/stew/cmd/install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_INSTALL';
  package App::stew::cmd::install;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::repo;use App::stew::installer;use App::stew::snapshot;use App::stew::index;use App::stew::tree;use App::stew::env;use App::stew::util qw(info debug error slurp_file);sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_repo=$ENV{STEW_REPO};my$opt_force_platform;my$opt_os;my$opt_arch;my$opt_build='build';my$opt_dry_run;my$opt_verbose;my$opt_from_source;my$opt_from_source_recursive;my$opt_reinstall;my$opt_keep_files;my$opt_cache;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"repo=s"=>\$opt_repo,"force-platform"=>\$opt_force_platform,"os=s"=>\$opt_os,"arch=s"=>\$opt_arch,"build=s"=>\$opt_build,"dry-run"=>\$opt_dry_run,"verbose"=>\$opt_verbose,"from-source"=>\$opt_from_source,"from-source-recursive"=>\$opt_from_source_recursive,"reinstall"=>\$opt_reinstall,"keep-files"=>\$opt_keep_files,"cache"=>\$opt_cache,)or die "error";error("--base is required")unless$opt_base;error("--repo is required")unless$opt_repo;mkpath($opt_base);$opt_base=abs_path($opt_base);mkpath($opt_build);my$root_dir=abs_path(cwd());my$build_dir=abs_path($opt_build);$ENV{STEW_LOG_LEVEL}=$opt_verbose ? 1 : 0;$ENV{STEW_LOG_FILE}="$build_dir/stew.log";unlink$ENV{STEW_LOG_FILE};my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;my$local_settings=$snapshot->local_settings;my$os_forced=!!$opt_os;$opt_os //= $local_settings->{os}// App::stew::env->detect_os;$opt_arch //= $local_settings->{arch}// App::stew::env->detect_arch;my$repo=App::stew::repo->new(path=>$opt_repo,mirror_path=>"$build_dir/.cache",os=>$opt_os,arch=>$opt_arch,cache=>$opt_cache,);my$index=App::stew::index->new(repo=>$repo);my$platform="$opt_os-$opt_arch";warn "Installing for '$platform'\n";if (!$os_forced &&!$opt_force_platform &&!$opt_from_source &&!$local_settings->{os}&&!$local_settings->{arch}){if (!$index->platform_available($opt_os,$opt_arch)){my$platforms=$index->list_platforms;warn "Platform '$platform' is not available. " ."Maybe you want --from-source or --force-platform?\n";warn "Available platforms are: \n\n";warn join("\n",map {"    --os $_->{os} --arch $_->{arch}"}@$platforms)."\n\n";error 'Fail to detect platform'}}if (@argv==1 && $argv[0]eq '.'){die 'stewfile not found' unless -f 'stewfile';@argv=grep {$_ &&!/^#/}split /\n+/,slurp_file('stewfile')}my@trees;for my$package (@argv){my$resolved=$index->resolve($package);if (!$opt_reinstall && $snapshot->is_up_to_date($resolved)){info sprintf "'%s' is up to date",$resolved;next}my$tree=App::stew::tree->new(repo=>$repo,index=>$index);my$dump=$tree->build($package);push@trees,$dump}$ENV{STEW_OS}=$opt_os;$ENV{STEW_ARCH}=$opt_arch;$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->new(prefix=>$ENV{PREFIX})->setup;my$installer=App::stew::installer->new(base=>$opt_base,root_dir=>$root_dir,build_dir=>$build_dir,repo=>$repo,snapshot=>$snapshot,from_source=>$opt_from_source,from_source_recursive=>$opt_from_source_recursive,reinstall=>$opt_reinstall,keep_files=>$opt_keep_files,);for my$tree (@trees){$installer->install($tree)}$snapshot->local_settings->{os}=$opt_os;$snapshot->local_settings->{arch}=$opt_arch;$snapshot->store;info "Done"}1;
APP_STEW_CMD_INSTALL

$fatpacked{"App/stew/cmd/list_installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_LIST_INSTALLED';
  package App::stew::cmd::list_installed;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base)or die "error";error("--base is required")unless$opt_base;my$snapshot=App::stew::snapshot->new(base=>$opt_base)->load;for my$key (sort keys %$snapshot){next if$key eq '_';next if$snapshot->{$key}->{dependency};print "$key $snapshot->{$key}->{version}\n"}}1;
APP_STEW_CMD_LIST_INSTALLED

$fatpacked{"App/stew/cmd/uninstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_UNINSTALL';
  package App::stew::cmd::uninstall;use strict;use warnings;use base 'App::stew::cmd::base';use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::uninstaller;use App::stew::util qw(error info);sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_force;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"force"=>\$opt_force,)or die "error";error("--base is required")unless$opt_base;my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;my$uninstaller=App::stew::uninstaller->new(base=>$opt_base,prefix=>$opt_prefix);if (!$opt_force){for my$package (@argv){next unless$snapshot->is_dependency($package);error "Cannot remove '$package' since it is was installed " ."as dependency and can break other packages" if$snapshot->is_required($package)}}$uninstaller->uninstall(@argv);info 'Done'}1;
APP_STEW_CMD_UNINSTALL

$fatpacked{"App/stew/cmdbuilder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMDBUILDER';
  package App::stew::cmdbuilder;use strict;use warnings;use List::Util qw(max first);use Pod::Usage qw(pod2usage);use App::stew::cmd::install;use App::stew::cmd::build;use App::stew::cmd::list_installed;use App::stew::cmd::uninstall;use App::stew::cmd::autoremove;use App::stew::cmd::exec;use App::stew::cmd::help;my@COMMANDS=('install','uninstall','build','list-installed','autoremove','exec','help',);sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub build {my$self=shift;my ($command)=@_;my$offset=max map {length}@COMMANDS;if (!$command ||!first {$_ eq $command}@COMMANDS){pod2usage()}return$self->_command_to_class($command)->new}sub _command_to_class {my$self=shift;my ($command)=@_;$command =~ s/-/_/g;return 'App::stew::cmd::' .$command}1;
APP_STEW_CMDBUILDER

$fatpacked{"App/stew/env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_ENV';
  package App::stew::env;use strict;use warnings;use Config;use Linux::Distribution;use App::stew::util qw(debug error slurp_file);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{prefix}=$params{prefix}|| error 'prefix required';return$self}sub setup {my$self=shift;my$prefix=$self->{prefix};$ENV{PERL5LIB}="";$ENV{PERL_LOCAL_LIB_ROOT}="";$ENV{PERL_MB_OPT}="--installdirs site";$ENV{PERL_MM_OPT}="INSTALLDIRS=site";$ENV{PERL_CPANM_OPT}="";_unshift_env(PATH=>"$prefix/bin");_unshift_env(LIBPATH=>"$prefix/lib");_unshift_env(LIBRARY_PATH=>"$prefix/lib");_unshift_env(LD_LIBRARY_PATH=>"$prefix/lib");_unshift_env(CPATH=>"$prefix/include");_unshift_env(C_INCLUDE_PATH=>"$prefix/include");_unshift_env(CPLUS_INCLUDE_PATH=>"$prefix/include")}sub detect_os {my$self=shift;my$os=$self->_osname;if ($os eq 'linux'){my$dist_name=Linux::Distribution::distribution_name()// 'generic';my$dist_version=eval {Linux::Distribution::distribution_version()};if ($dist_version && $dist_version =~ m/^(\d+(?:\.\d+)?)/){$dist_version=$1}else {$dist_version=undef}$os .= "-$dist_name";$os .= "-$dist_version" if$dist_version}elsif ($os eq 'darwin'){my$cmd='sw_vers';my$output=$self->_run_cmd($cmd);my ($dist_version)=$output =~ m/ProductVersion:\s+(\d+\.\d+)/;$os .= "-osx";$os .= "-$dist_version" if$dist_version}elsif ($os eq 'cygwin'){my$cmd='uname -r';my$output=$self->_run_cmd($cmd);my ($dist_version)=$output =~ m/^(\d+\.\d+)/;$os="windows-$os";$os .= "-$dist_version" if$dist_version}return$os}sub detect_arch {my$self=shift;my$arch;chomp($arch //= `uname -m`);$arch=lc$arch;return$arch}sub _osname {$^O}sub _run_cmd {my$self=shift;my ($cmd)=@_;return `$cmd`}sub _unshift_env {my ($var,$value)=@_;if ($ENV{$var}){$ENV{$var}="$value:$ENV{$var}"}else {$ENV{$var}=$value}debug "Setting ENV{$var}=$ENV{$var}"}1;
APP_STEW_ENV

$fatpacked{"App/stew/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_FILE';
  package App::stew::file;use strict;use warnings;use App::stew::util qw(slurp_file error);my%CACHE;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub parse {my$class=shift;my ($stew_file)=@_;return$CACHE{"$stew_file"}if$CACHE{"$stew_file"};my$content=slurp_file($stew_file);my$stew_class=$class->_sandbox($stew_file,$content);my$stew=$stew_class->new;$CACHE{"$stew_file"}=$stew;return$stew}sub _sandbox {my$self=shift;my ($file,$content)=@_;my$class_name='stew::_build_' ._rand_str();my$package=<<"EOP";eval$package or error("Error compiling '$file': $@");return$class_name}sub _rand_str {my@alpha=('0' .. '9','a' .. 'z','A' .. 'Z');my$str='';$str .= $alpha[rand($#alpha)]for 1 .. 16;return$str}1;
      package $class_name;
      use strict;
      use warnings;
      my \$name;
      my \$version;
      my \$package;
      my \$file;
      my \@files;
      my \$url;
      my \@depends;
      my \@flags;
      my \@os;
  
      sub new {
          my \$class = shift;
  
          my \$self = {};
          bless \$self, \$class;
  
          return \$self;
      }
  
      sub name    { \$name }
      sub version { \$version }
      sub package { \$package }
      sub file    { \$file }
      sub files   { \@files }
      sub url     { \$url }
      sub depends { \@depends }
      sub flags   { \@flags }
      sub os      { \@os }
  
      my \$phases = {};
      sub download(&) { \$phases->{download} = shift }
      sub prepare(&)  { \$phases->{prepare}  = shift }
      sub build(&)    { \$phases->{build}    = shift }
      sub install(&)  { \$phases->{install}  = shift }
      sub cleanup(&)  { \$phases->{cleanup}  = shift }
  
      sub phase { \$phases->{\$_[1]} }
  
      sub is {
          my \$self = shift;
          my (\$flag) = \@_;
  
          return !!grep { \$_ eq \$flag } \$self->flags;
      }
  
      sub run {
          my \$self = shift;
          my (\$phase) = \@_;
  
          if (\$phases->{\$phase}) {
              return \$phases->{\$phase}->()
          }
  
          return;
      }
      $content
      1;
  EOP
APP_STEW_FILE

$fatpacked{"App/stew/index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_INDEX';
  package App::stew::index;use strict;use warnings;use Carp qw(croak);use List::Util qw(first);use App::stew::util qw(error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{repo}=$params{repo}or croak 'repo required';return$self}sub resolve {my$self=shift;my ($need)=@_;my$name=$need;my$op;my$version;if ($need =~ m/^(.*?)(==|>=?|<=?)(.*)$/){$name=$1;$op=$2;$version=$3}$self->{index}||= $self->_read_index;my@packages;for my$package (@{$self->{index}}){push@packages,$package if$package->{name}eq $name}if (!$op){my$package=$packages[-1];return unless$package;return$package->{full}}elsif ($op eq '=='){my$package=first {$_->{version}eq $version}@packages;return unless$package;return$package->{full}}elsif ($op eq '>='){my@newer=grep {$_->{version}ge $version}@packages;return unless@newer;return$newer[-1]->{full}}elsif ($op eq '>'){my@packages=grep {$_->{version}gt $version}@packages;return unless@packages;return$packages[-1]->{full}}return}sub list_platforms {my$self=shift;my@platforms;my$index_file=$self->{repo}->mirror_index;my@index;open my$fh,'<',$index_file or error "Can't read index file '$index_file': $!";for my$line (<$fh>){chomp$line;next unless$line =~ m/^dist\/(.*?)\/(.*?)$/;push@platforms,{os=>$1,arch=>$2}}close$fh;return \@platforms}sub platform_available {my$self=shift;my ($os,$arch)=@_;my$platforms=$self->list_platforms;for my$platform (@$platforms){if ($platform->{os}=~ m/^\Q$os\E/ && $arch eq $platform->{arch}){return 1}}return 0}sub _read_index {my$self=shift;my$index_file=$self->{repo}->mirror_index;my@index;open my$fh,'<',$index_file or error "Can't read index file '$index_file': $!";for my$line (<$fh>){chomp$line;next unless$line =~ m/^stew\/(.*?)_(.*?)\.stew$/;push@index,{name=>$1,version=>$2,full=>"$1_$2" }}close$fh;return \@index}1;
APP_STEW_INDEX

$fatpacked{"App/stew/installer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_INSTALLER';
  package App::stew::installer;use strict;use warnings;use Cwd qw(abs_path getcwd);use Carp qw(croak);use File::Path qw(rmtree);use File::Basename qw(basename dirname);use App::stew::builder;use App::stew::util qw(cmd info debug error _chdir _mkpath _rmtree _copy _unlink _tree _tree_diff);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base}=$params{base};$self->{root_dir}=$params{root_dir};$self->{build_dir}=$params{build_dir};$self->{repo}=$params{repo};$self->{snapshot}=$params{snapshot};$self->{from_source}=$params{from_source};$self->{from_source_recursive}=$params{from_source_recursive};$self->{reinstall}=$params{reinstall};$self->{keep_files}=$params{keep_files};$self->{cache}=$params{cache};return$self}sub install {my$self=shift;my ($stew_tree,%options)=@_;my$is_dependency=!!$options{satisfies};my$stew=$stew_tree->{stew};my$reinstall=!$is_dependency && $self->{reinstall};my$from_source=$self->{from_source_recursive}|| (!$is_dependency && $self->{from_source});if (!$reinstall && $self->{snapshot}->is_up_to_date($stew->name,$stew->version)){info sprintf "'%s' is up to date",$stew->package;return}elsif ($self->{snapshot}->is_installed($stew->name)){my$uninstaller=App::stew::uninstaller->new(base=>$self->{base});$uninstaller->uninstall($stew->name)}croak '$ENV{PREFIX} not defined' unless$ENV{PREFIX};_mkpath($ENV{PREFIX});info sprintf "Building & installing '%s'...",$stew->package;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_rmtree$work_dir;_mkpath($work_dir);my$cwd=getcwd();my$tree=[];my@depends;eval {if (my@os=$stew->os){my$match=0;for my$os (@os){if ($ENV{STEW_OS}=~ m/$os/){$match=1;last}}if (!$match){info sprintf "Not supported OS '%s'. Supported are '%s'. Skipping...",$ENV{STEW_OS},join(', ',@os);return$self}}info "Resolving dependencies...";@depends=$self->_install_dependencies($stew,$stew_tree);if ($stew->is('cross-platform')){info 'Cross platform package';my$builder=$self->_build_builder;$tree=$builder->build($stew_tree);my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);my$dist_archive=basename$dist_path;my ($dist_name)=$dist_archive =~ m/^(.*)\.tar\.gz$/;_chdir$work_dir;_chdir "$dist_name/$ENV{PREFIX}";cmd("cp -Ra * $ENV{PREFIX}/")}elsif ($stew->is('meta')){info 'Meta package'}else {my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);eval {$self->{repo}->mirror_dist($stew->name,$stew->version)};if ($from_source ||!-f $dist_path){my$builder=$self->_build_builder;$tree=$builder->build($stew_tree)}$tree=$self->_install_from_binary($stew,$dist_path)}_chdir($cwd)}or do {my$e=$@;_chdir($cwd);die$e};info sprintf "Done installing '%s'",$stew->package;$self->{snapshot}->mark_installed(name=>$stew->name,version=>$stew->version,files=>$tree,depends=>[map {{name=>$_->{stew}->name,version=>$_->{stew}->version}}@depends ],$is_dependency ? (dependency=>1): ());_rmtree$work_dir unless$self->{keep_files};return$self}sub _install_from_binary {my$self=shift;my ($stew,$dist_path)=@_;info sprintf "Installing '%s' from binaries '%s'...",$stew->package,$dist_path;my$basename=basename$dist_path;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_chdir$work_dir;my ($dist_name)=$basename =~ m/^(.*)\.tar\.gz$/;_rmtree$dist_name;_mkpath$dist_name;_copy($dist_path,"$dist_name/$basename");_chdir$dist_name;cmd("tar xzf $basename");_unlink$basename;cmd("cp -Ra * $ENV{PREFIX}/");return _tree(".",".")}sub _install_dependencies {my$self=shift;my ($stew,$tree)=@_;my@depends=@{$tree->{dependencies}|| []};if (@depends){info "Found dependencies: " .join(', ',map {$_->{stew}->package}@depends)}for my$tree (@depends){my$stew=$tree->{stew};_chdir($self->{root_dir});$self->install($tree,satisfies=>$stew);_chdir($self->{root_dir})}return@depends}sub _build_builder {my$self=shift;return App::stew::builder->new(root_dir=>$self->{root_dir},build_dir=>$self->{build_dir},repo=>$self->{repo},snapshot=>$self->{snapshot},)}1;
APP_STEW_INSTALLER

$fatpacked{"App/stew/rc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_RC';
  package App::stew::rc;use strict;use warnings;use File::Spec;sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub load {my$self=shift;my$file='.stewrc';for ('.',$ENV{HOME}){my$path=File::Spec->catfile($_,$file);return$self->parse($path)if -f $path}return {}}sub parse {my$self=shift;my ($file)=@_;my@lines=do {open my$fh,'<',$file or die "Can't open '$file': $!";<$fh>};my$section='_';my%options;for my$line (@lines){next unless defined$line && $line !~ m/^\s*#/;chomp$line;$line =~ s{^\s+}{};$line =~ s{\s+$}{};next unless length$line;if ($line =~ m/^\[(.*?)\]$/){$section=$1;next}my ($key,$value)=split /\s+/,$line,2;$options{$section}->{$key}=$value}return \%options}1;
APP_STEW_RC

$fatpacked{"App/stew/repo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_REPO';
  package App::stew::repo;use strict;use warnings;use HTTP::Tiny;use File::Basename qw(dirname basename);use File::Path ();use Carp qw(croak);use App::stew::util qw(error debug _copy _mkpath sort_by_version);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{path}=$params{path}or croak 'path required';$self->{path}.= '/' unless$self->{path}=~ m{/$};$self->{mirror_path}=$params{mirror_path}or croak 'mirror_path required';$self->{mirror_path}.= '/' unless$self->{mirror_path}=~ m{/$};$self->{os}=$params{os}or croak 'os required';$self->{arch}=$params{arch}or croak 'arch required';$self->{ua}=$params{ua};$self->{cache}=$params{cache};return$self}sub mirror_stew {my$self=shift;my ($name)=@_;my$full_name=$self->{path}.File::Spec->catfile('stew',$name .'.stew');return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'stew'))}sub mirror_src {my$self=shift;my ($filename)=@_;my$full_name=$self->{path}.File::Spec->catfile('src',$filename);return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'src'))}sub mirror_dist_dest {my$self=shift;my ($name,$version)=@_;my$os=$self->{os};my$arch=$self->{arch};return File::Spec->catfile($self->{mirror_path},'dist',$os,$arch,"${name}_${version}_$os-$arch.tar.gz")}sub mirror_dist {my$self=shift;my ($name,$version)=@_;croak 'name required' unless$name;croak 'version required ' unless$version;my$os=$self->{os};my$arch=$self->{arch};my$full_name=$self->{path}.File::Spec->catfile('dist',$os,$arch,"${name}_${version}_$os-$arch.tar.gz");return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'dist',$os,$arch))}sub mirror_index {my$self=shift;my$to=File::Spec->catfile($self->{mirror_path},'index');if ($self->{cache}){debug("NOT Mirroring index");return$to}my@index;if ($self->{path}=~ m/^http/){my$ua=$self->{ua}|| HTTP::Tiny->new;for my$type (qw(stew src)){my$response=$ua->get("$self->{path}$type");if ($response->{success}){my$content=$response->{content};while ($content =~ m#<a href="(.*?\.(?:stew|tar\.gz))">.*?</a>#g){push@index,"$type/$1"}}}my$response=$ua->get("$self->{path}dist");if ($response->{success}){my$content=$response->{content};my@os;while ($content =~ m#<a href="([^\.].*?)/?">.*?</a>#g){push@os,$1}for my$os (@os){my$response=$ua->get("$self->{path}dist/$os");next unless$response->{success};my$content=$response->{content};while ($content =~ m#<a href="([^\.].*?)/?">.*?</a>#g){push@index,"dist/$os/$1"}}}}else {for my$type (qw(stew src)){opendir my$dh,"$self->{path}/$type" or error "Can't open directory '$self->{path}/$type': $!";push@index,map {"$type/$_"}grep {!/^\./ && -f "$self->{path}/$type/$_"}readdir($dh);closedir$dh}if (opendir my$dh,"$self->{path}/dist"){my@os=grep {!/^\./ && -d "$self->{path}/dist/$_"}readdir($dh);closedir$dh;for my$os (@os){opendir my$dh,"$self->{path}/dist/$os" or next;my@arch=grep {!/^\./ && -d "$self->{path}/dist/$os/$_"}readdir($dh);closedir$dh;for my$arch (@arch){push@index,"dist/$os/$arch"}}}}my@index_sorted=sort_by_version@index;_mkpath dirname$to;open my$fh,'>',$to or die "Can't create file '$to': $!";print$fh "$_\n" for@index_sorted;close$fh;return$to}sub mirror_file {my$self=shift;my ($in,$to_dir)=@_;my$to=File::Spec->catfile($to_dir,basename$in);if ($self->{cache}){debug("NOT Mirroring '$in' to '$to_dir'");return$to}_mkpath($to_dir);debug("Mirroring '$in' to '$to_dir'");if (-e $to){debug("File '$to' exists. Skipping");return$to}if ($in =~ m/^http/){my$ua=$self->{ua}|| HTTP::Tiny->new;$ua->mirror($in,$to)}else {error "File '$in' does not exist" unless -f $in;_copy($in,$to)}return$to}1;
APP_STEW_REPO

$fatpacked{"App/stew/snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_SNAPSHOT';
  package App::stew::snapshot;use strict;use warnings;use File::Spec ();use List::Util qw(first);use Data::Dumper ();use Carp qw(croak);use App::stew::util qw(error slurp_file write_file);my%CACHE_REQUIRED;sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base}=$params{base};croak 'base is required' unless$self->{base};$self->{snapshot}={};$self->load;return$self}sub local_settings {my$self=shift;$self->{snapshot}->{_}||= {};return$self->{snapshot}->{_}}sub is_installed {my$self=shift;my ($package)=@_;if ($self->{snapshot}->{$package}){return 1}return 0}sub is_up_to_date {my$self=shift;my ($name,$version)=@_==1 ? split /_/,$_[0],2 : @_;return 0 unless$self->is_installed($name);return 0 unless$self->{snapshot}->{$name}->{version}eq $version;return 1}sub get_package {my$self=shift;my ($package)=@_;return$self->{snapshot}->{$package}}sub list_not_required {my$self=shift;my@not_required;for my$name (keys %{$self->{snapshot}}){push@not_required,$name unless$self->is_required($name)}return sort@not_required}sub is_dependency {my$self=shift;my ($name)=@_;my$info=$self->{snapshot}->{$name};error 'unknown package' unless$info;return!!$info->{dependency}}sub is_required {my$self=shift;my ($name)=@_;my$info=$self->{snapshot}->{$name};error 'unknown package' unless$info;return$CACHE_REQUIRED{$name}if exists$CACHE_REQUIRED{$name};return ($CACHE_REQUIRED{$name}=1)unless$info->{dependency};for my$dependant_name (keys %{$self->{snapshot}}){next if$name eq $dependant_name;my$dependant_info=$self->{snapshot}->{$dependant_name};next unless$dependant_info->{depends}&& (my@depends=@{$dependant_info->{depends}});if (my$depends=first {$name eq $_->{name}}@depends){my$is_required=$self->is_required($dependant_name);return$is_required if$is_required}}return ($CACHE_REQUIRED{$name}=0)}sub load {my$self=shift;my$install_file=$self->_install_file;my$installed={};if (-e $install_file){no strict;$installed=eval slurp_file($install_file)}$self->{snapshot}=$installed;return$self->{snapshot}}sub mark_installed {my$self=shift;my (%options)=@_;my$name=delete$options{name};$self->{snapshot}->{$name}={%options};$self->store;return$self}sub mark_uninstalled {my$self=shift;my ($name)=@_;delete$self->{snapshot}->{$name};$self->store;return$self}sub store {my$self=shift;write_file($self->_install_file,Data::Dumper::Dumper($self->{snapshot}));return$self}sub _install_file {my$self=shift;return File::Spec->catfile($self->{base},'stew.snapshot')}1;
APP_STEW_SNAPSHOT

$fatpacked{"App/stew/tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_TREE';
  package App::stew::tree;use strict;use warnings;use Carp qw(croak);use App::stew::file;use App::stew::util qw(error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{repo}=$params{repo}or croak 'repo required';$self->{index}=$params{index}or croak 'index required';return$self}sub build {my$self=shift;my ($stew_expr,%params)=@_;my$stew_name=$self->{index}->resolve($stew_expr);error "Can't find package satisfying '$stew_expr'" unless$stew_name;my$stew_file=$self->_download_stew($stew_name);my$stew=$self->_parse_stew($stew_file);my$tree={stew=>$stew,dependencies=>[]};return$tree if$params{seen}->{$stew_name};$params{seen}->{$stew_name}++;my@depends=$stew->depends;for my$depends (@depends){push @{$tree->{dependencies}},$self->build($depends,%params)}return$tree}sub flatten {my$self=shift;my ($tree)=@_;my@list;for my$dep (@{$tree->{dependencies}}){push@list,$self->flatten($dep)}push@list,$tree->{stew};return@list}sub flatten_dependencies {my$self=shift;my ($tree)=@_;my@list;for my$dep (@{$tree->{dependencies}}){push@list,$self->flatten($dep)}return@list}sub _download_stew {my$self=shift;my ($stew_name)=@_;return$self->{repo}->mirror_stew($stew_name)}sub _parse_stew {my$self=shift;my ($file)=@_;return App::stew::file->parse($file)}1;
APP_STEW_TREE

$fatpacked{"App/stew/uninstaller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_UNINSTALLER';
  package App::stew::uninstaller;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::util qw(info debug error _unlink);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base}=$params{base};$self->{prefix}=$params{prefix}|| 'local';return$self}sub uninstall {my$self=shift;my (@packages)=@_;my$snapshot=App::stew::snapshot->new(base=>$self->{base});$snapshot->load;for my$package (@packages){if (!$snapshot->is_installed($package)){warn "$package not installed. Skipping\n"}else {info sprintf "Uninstalling '%s'...",$package;my$info=$snapshot->get_package($package);for my$file (@{$info->{files}}){_unlink "$self->{base}/$self->{prefix}/$file"}$snapshot->mark_uninstalled($package)}}}1;
APP_STEW_UNINSTALLER

$fatpacked{"App/stew/util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_UTIL';
  package App::stew::util;use strict;use warnings;use base 'Exporter';our@EXPORT_OK=qw(info debug error slurp_file write_file cmd _chdir _mkpath _rmtree _copy _unlink _tree _tree_diff sort_by_version);use File::Find qw(find);use Carp qw(croak);use File::Copy qw(copy);use File::Basename qw(dirname);use File::Path qw(mkpath rmtree);sub slurp_file {my ($file)=@_;local $/;open my$fh,'<',$file or error("Can't read file '$file': $!");return <$fh>}sub write_file {my ($file,$content)=@_;open my$fh,'>',$file or error("Can't write file '$file': $!");print$fh $content;close$fh}sub debug {print STDERR @_,"\n" if$ENV{STEW_LOG_LEVEL};_log(@_)}sub info {_log(@_);warn join(' ',@_)."\n"}sub error {_log(@_);croak("ERROR: " .join(' ',@_))}sub _chdir {my ($dir)=@_;debug(qq{Entering '$dir'});die "Directory '$dir' does not exist" unless -d $dir;chdir($dir)}sub _mkpath {my ($dir)=@_;debug(qq{Creating '$dir'});mkpath($dir)}sub _rmtree {my ($dir)=@_;debug(qq{Removing '$dir'});rmtree($dir)}sub _copy {my ($from,$to)=@_;debug(qq{Copying '$from' -> '$to'});copy($from,$to)or croak "Cant copy '$from' -> '$to'"}sub _unlink {my ($file)=@_;debug(qq{Unlinking '$file'});unlink($file)}sub cmd {return unless @_;my$cmd=join ' && ',@_;$cmd="sh -c \"$cmd 2>&1\" 2>&1 >> $ENV{STEW_LOG_FILE}";debug($cmd);my$exit=system($cmd);error("Command failed: $cmd")if$exit}sub _log {open my$fh,'>>',$ENV{STEW_LOG_FILE}or die "Can't open logfile '$ENV{STEW_LOG_FILE}': $!";print$fh @_,"\n";close$fh}sub _tree {my ($dir,$prefix)=@_;my@tree;find(sub {return unless -f $_;my$name=$File::Find::name;if ($prefix){$name =~ s{^$prefix/?}{}}push@tree,$name},$dir);return [sort@tree]}sub _tree_diff {my ($tree1,$tree2)=@_;my@diff;my$diff_pos=0;for (my$pos=0;$pos < @$tree1;$pos++){while ($diff_pos < @$tree2 && $tree1->[$pos]ne $tree2->[$diff_pos]){push@diff,$tree2->[$diff_pos];$diff_pos++}if ($diff_pos < @$tree2 && $tree1->[$pos]eq $tree2->[$diff_pos]){$diff_pos++;next}last if$diff_pos >= @$tree2}while ($diff_pos < @$tree2){push@diff,$tree2->[$diff_pos];$diff_pos++}return \@diff}sub sort_by_version {my (@list)=@_;my%packages;for my$list (@list){if ($list =~ m{^dist/}){$packages{$list}=''}else {my ($pkg,$v,$tail)=$list =~ m/^(.*?)(\d+(?:\.\d+)*(?:[a-z]\d?)?)(\..*)/;die "Can't parse $list" unless$pkg && $v && $tail;$packages{"$pkg$v"}=$tail}}my@packages=sort keys%packages;my@sorted;for my$package (@packages){push@sorted,"$package$packages{$package}"}return@sorted}1;
APP_STEW_UTIL

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Module::Load;our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');load($package);$package->import()}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use Carp qw/croak/;use Config;use Text::ParseWords 3.24 qw/shellwords/;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return shellwords($string)}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use ExtUtils::Helpers::Unix qw/split_like_shell/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);my$newdirs;if ($arg =~ m#^~/#){$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs)}else {my@backup=File::Spec::Unix->splitdir(File::Spec::Unix->updir);$newdirs=File::Spec::Unix->catdir(@hdirs,@backup,@dirs)}$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use Config;use Carp qw/carp croak/;sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){_pl2bat(in=>$script,update=>1)}return}sub _pl2bat {my%opts=@_;$opts{ntargs}='-x -S %0 %*';$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9';$opts{stripsuffix}=qr/\.plx?/ unless exists$opts{stripsuffix};if (not exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//i;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}eq '-'}my$head=<<"EOT";$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail=<<'EOT';$tail =~ s/^\s+//gm;my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start='#!perl' unless$start =~ /^#!.*perl/;open my$in,'<',$opts{in}or croak "Can't open $opts{in}: $!";my@file=<$in>;close$in;for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= '#line '.(1+$headlines)."\n"}else {$line .= '#line '.($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=''}}open my$out,'>',$opts{out}or croak "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? ' -w' : ''),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close$out;return$opts{out}}sub split_like_shell {local ($_)=@_;my@argv;return@argv unless defined && length;my$arg='';my ($i,$quote_mode)=(0,0);while ($i < length){my$ch=substr $_,$i,1;my$next_ch=substr $_,$i+1,1;if ($ch eq '\\' && $next_ch eq '"'){$arg .= '"';$i++}elsif ($ch eq '\\' && $next_ch eq '\\'){$arg .= '\\';$i++}elsif ($ch eq '"' && $next_ch eq '"' && $quote_mode){$quote_mode=!$quote_mode;$arg .= '"';$i++}elsif ($ch eq '"' && $next_ch eq '"' &&!$quote_mode && ($i + 2==length()|| substr($_,$i + 2,1)eq ' ')){push@argv,$arg;$arg='';$i += 2}elsif ($ch eq '"'){$quote_mode=!$quote_mode}elsif ($ch =~ /\s/ &&!$quote_mode){push@argv,$arg if$arg;$arg='';++$i while substr($_,$i + 1,1)=~ /\s/}else {$arg .= $ch}$i++}push@argv,$arg if defined$arg && length$arg;return@argv}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
  	\@rem = '--*-Perl-*--
  	\@echo off
  	if "%OS%" == "Windows_NT" goto WinNT
  	perl $opts{otherargs}
  	\@set ErrorLevel=%ErrorLevel%
  	goto endofperl
  	:WinNT
  	perl $opts{ntargs}
  	\@set ErrorLevel=%ErrorLevel%
  	if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
  	if %errorlevel% == 9009 echo You do not have Perl in your PATH.
  	goto endofperl
  	\@rem ';
  EOT
  	__END__
  	:endofperl
  	@"%COMSPEC%" /c exit /b %ErrorLevel%
  EOT
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.011';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"Linux/Distribution.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LINUX_DISTRIBUTION';
  package Linux::Distribution;use 5.006000;use strict;use warnings;require Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(distribution_name distribution_version);our$VERSION='0.23';our$release_files_directory='/etc';our$standard_release_file='lsb-release';our%release_files=('gentoo-release'=>'gentoo','fedora-release'=>'fedora','centos-release'=>'centos','enterprise-release'=>'oracle enterprise linux','turbolinux-release'=>'turbolinux','mandrake-release'=>'mandrake','mandrakelinux-release'=>'mandrakelinux','debian_version'=>'debian','debian_release'=>'debian','SuSE-release'=>'suse','knoppix-version'=>'knoppix','yellowdog-release'=>'yellowdog','slackware-version'=>'slackware','slackware-release'=>'slackware','redflag-release'=>'redflag','redhat-release'=>'redhat','redhat_version'=>'redhat','conectiva-release'=>'conectiva','immunix-release'=>'immunix','tinysofa-release'=>'tinysofa','trustix-release'=>'trustix','adamantix_version'=>'adamantix','yoper-release'=>'yoper','arch-release'=>'arch','libranet_version'=>'libranet','va-release'=>'va-linux','pardus-release'=>'pardus','system-release'=>'amazon','CloudLinux-release'=>'CloudLinux',);our%version_match=('gentoo'=>'Gentoo Base System release (.*)','debian'=>'(.+)','suse'=>'VERSION = (.*)','fedora'=>'Fedora(?: Core)? release (\d+) \(','redflag'=>'Red Flag (?:Desktop|Linux) (?:release |\()(.*?)(?: \(.+)?\)','redhat'=>'Red Hat(?: Enterprise)? Linux(?: Server)? release (.*) \(','oracle enterprise linux'=>'Enterprise Linux Server release (.+) \(','slackware'=>'^Slackware (.+)$','pardus'=>'^Pardus (.+)$','centos'=>'^CentOS(?: Linux)? release (.+) \(','scientific'=>'^Scientific Linux release (.+) \(','amazon'=>'Amazon Linux AMI release (.+)$','CloudLinux'=>'CloudLinux Server release (\S+)');if ($^O ne 'linux'){}sub new {my%self=('DISTRIB_ID'=>'','DISTRIB_RELEASE'=>'','DISTRIB_CODENAME'=>'','DISTRIB_DESCRIPTION'=>'','release_file'=>'','pattern'=>'');return bless \%self}sub distribution_name {my$self=shift || new();my$distro;if ($distro=$self->_get_lsb_info()){return$distro if ($distro)}for (qw(enterprise-release fedora-release CloudLinux-release)){if (-f "$release_files_directory/$_" &&!-l "$release_files_directory/$_"){if (-f "$release_files_directory/$_" &&!-l "$release_files_directory/$_"){$self->{'DISTRIB_ID'}=$release_files{$_};$self->{'release_file'}=$_;return$self->{'DISTRIB_ID'}}}}for (keys%release_files){if (-f "$release_files_directory/$_" &&!-l "$release_files_directory/$_"){if (-f "$release_files_directory/$_" &&!-l "$release_files_directory/$_"){if ($release_files{$_}eq 'redhat'){for my$rhel_deriv ('centos','scientific',){$self->{'pattern'}=$version_match{$rhel_deriv};$self->{'release_file'}='redhat-release';if ($self->_get_file_info()){$self->{'DISTRIB_ID'}=$rhel_deriv;$self->{'release_file'}=$_;return$self->{'DISTRIB_ID'}}}$self->{'pattern'}=''}$self->{'release_file'}=$_;$self->{'DISTRIB_ID'}=$release_files{$_};return$self->{'DISTRIB_ID'}}}}undef}sub distribution_version {my$self=shift || new();my$release;return$release if ($release=$self->_get_lsb_info('DISTRIB_RELEASE'));if (!$self->{'DISTRIB_ID'}){$self->distribution_name()or die 'No version because no distro.'}$self->{'pattern'}=$version_match{$self->{'DISTRIB_ID'}};$release=$self->_get_file_info();$self->{'DISTRIB_RELEASE'}=$release;return$release}sub _get_lsb_info {my$self=shift;my$field=shift || 'DISTRIB_ID';my$tmp=$self->{'release_file'};if (-r "$release_files_directory/" .$standard_release_file){$self->{'release_file'}=$standard_release_file;$self->{'pattern'}=$field .'=["]?([^"]+)["]?';my$info=$self->_get_file_info();if ($info){$self->{$field}=$info;return$info}}$self->{'release_file'}=$tmp;$self->{'pattern'}='';undef}sub _get_file_info {my$self=shift;open my$fh,'<',"$release_files_directory/" .$self->{'release_file'}or die 'Cannot open file: '.$release_files_directory.'/' .$self->{'release_file'};my$info='';local $_;while (<$fh>){chomp $_;($info)=$_ =~ m/$self->{'pattern'}/;return "\L$info" if$info}undef}1;
LINUX_DISTRIBUTION

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.039';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Pod/Find.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_FIND';
  package Pod::Find;use strict;use vars qw($VERSION);$VERSION='1.63';require 5.005;use Carp;BEGIN {if ($] < 5.006){require Symbol;import Symbol}}use Exporter;use File::Spec;use File::Find;use Cwd qw(abs_path cwd);use vars qw(@ISA @EXPORT_OK $VERSION);@ISA=qw(Exporter);@EXPORT_OK=qw(&pod_find &simplify_name &pod_where &contains_pod);my$SIMPLIFY_RX;sub pod_find {my%opts;if(ref $_[0]){%opts=%{shift()}}$opts{-verbose}||= 0;$opts{-perl}||= 0;my (@search)=@_;if($opts{-script}){require Config;push(@search,$Config::Config{scriptdir})if -d $Config::Config{scriptdir};$opts{-perl}=1}if($opts{-inc}){if ($^O eq 'MacOS'){my@new_INC=@INC;for (@new_INC){if ($_ eq '.'){$_=':'}elsif ($_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e){$_=':'.$_}else {$_ =~ s{^\./}{:}}}push(@search,grep($_ ne File::Spec->curdir,@new_INC))}else {my%seen;my$curdir=File::Spec->curdir;for(@INC){next if $_ eq $curdir;my$path=abs_path($_);push(@search,$path)unless$seen{$path}++}}$opts{-perl}=1}if($opts{-perl}){require Config;if ($^O eq 'MacOS'){$SIMPLIFY_RX=qq!^(?i:\:?site_perl\:|\:?pod\:(?=.*?\\.pod\\z))*!}else {$SIMPLIFY_RX=qq!^(?i:site(_perl)?/|\Q$Config::Config{archname}\E/|\\d+\\.\\d+([_.]?\\d+)?/|pod/(?=.*?\\.pod\\z))*!}}my%dirs_visited;my%pods;my%names;my$pwd=cwd();for my$try (@search){unless(File::Spec->file_name_is_absolute($try)){$try=File::Spec->catfile($pwd,$try)}if ($^O eq 'VMS'){$try=VMS::Filespec::unixify($try)}else {$try=File::Spec->canonpath($try)}my$name;if(-f $try){if($name=_check_and_extract_name($try,$opts{-verbose})){_check_for_duplicates($try,$name,\%names,\%pods)}next}my$root_rx=$^O eq 'MacOS' ? qq!^\Q$try\E! : qq!^\Q$try\E/!;$root_rx=~ s|//$|/|;File::Find::find(sub {my$item=$File::Find::name;if(-d){if($item =~ m{/(?:RCS|CVS|SCCS|\.svn|\.hg|\.git|\.sync)$}){$File::Find::prune=1;return}elsif($dirs_visited{$item}){warn "Directory '$item' already seen, skipping.\n" if($opts{-verbose});$File::Find::prune=1;return}else {$dirs_visited{$item}=1}if($opts{-perl}&& /^(\d+\.[\d_]+)\z/s && eval "$1"!=$]){$File::Find::prune=1;warn "Perl $] version mismatch on $_, skipping.\n" if($opts{-verbose})}return}if($name=_check_and_extract_name($item,$opts{-verbose},$root_rx)){_check_for_duplicates($item,$name,\%names,\%pods)}},$try)}chdir$pwd;return%pods}sub _check_for_duplicates {my ($file,$name,$names_ref,$pods_ref)=@_;if($$names_ref{$name}){warn "Duplicate POD found (shadowing?): $name ($file)\n";warn '    Already seen in ',join(' ',grep($$pods_ref{$_}eq $name,keys %$pods_ref)),"\n"}else {$$names_ref{$name}=1}return $$pods_ref{$file}=$name}sub _check_and_extract_name {my ($file,$verbose,$root_rx)=@_;unless(-f $file && -T $file && ($file =~ /\.(pod|pm|plx?)\z/i || -x $file)){return}return unless contains_pod($file,$verbose);my$name=$file;if(defined$root_rx){$name =~ s/$root_rx//is;$name =~ s/$SIMPLIFY_RX//is if(defined$SIMPLIFY_RX)}else {if ($^O eq 'MacOS'){$name =~ s/^.*://s}else {$name =~ s{^.*/}{}s}}_simplify($name);$name =~ s{/+}{::}g;if ($^O eq 'MacOS'){$name =~ s{:+}{::}g}else {$name =~ s{/+}{::}g}return$name}sub simplify_name {my ($str)=@_;if ($^O eq 'MacOS'){$str =~ s/^.*://s}else {$str =~ s{^.*/}{}s}_simplify($str);return$str}sub _simplify {$_[0]=~ s/\.(pod|pm|plx?)\z//i;$_[0]=~ s/\.(bat|exe|cmd)\z//i if($^O =~ /mswin|os2/i);$_[0]=~ s/\.(com)\z//i if($^O eq 'VMS')}sub pod_where {my%options=('-inc'=>0,'-verbose'=>0,'-dirs'=>[File::Spec->curdir ],);if (defined $_[0]&& ref($_[0])eq 'HASH'){my$opt=shift;%options=(%options,%$opt)}carp 'Usage: pod_where({options}, $pod)' unless (scalar(@_));my$pod=shift;my@parts=split (/::/,$pod);my@search_dirs=@{$options{'-dirs'}};if ($options{'-inc'}){require Config;if ($^O eq 'MacOS' && $options{'-inc'}){my@new_INC=@INC;for (@new_INC){if ($_ eq '.'){$_=':'}elsif ($_ =~ s{^((?:\.\./)+)}{':' x (length($1)/3)}e){$_=':'.$_}else {$_ =~ s{^\./}{:}}}push (@search_dirs,@new_INC)}elsif ($options{'-inc'}){push (@search_dirs,@INC)}push (@search_dirs,$Config::Config{'scriptdir'})if -d $Config::Config{'scriptdir'}}warn 'Search path is: '.join(' ',@search_dirs)."\n" if$options{'-verbose'};Dir: foreach my$dir (@search_dirs){if (-d $dir){warn "Looking in directory $dir\n" if$options{'-verbose'};my$fullname=File::Spec->catfile($dir,@parts);$fullname=VMS::Filespec::unixify($fullname)if $^O eq 'VMS';warn "Filename is now $fullname\n" if$options{'-verbose'};for my$ext ('','.pod','.pm','.pl'){my$fullext=$fullname .$ext;if (-f $fullext && contains_pod($fullext,$options{'-verbose'})){warn "FOUND: $fullext\n" if$options{'-verbose'};return$fullext}}}else {warn "Directory $dir does not exist\n" if$options{'-verbose'};next Dir}if((File::Spec->case_tolerant || $^O =~ /macos|darwin|cygwin/i)&& -d File::Spec->catdir($dir,'pods')){$dir=File::Spec->catdir($dir,'pods');redo Dir}if(-d File::Spec->catdir($dir,'pod')){$dir=File::Spec->catdir($dir,'pod');redo Dir}}return}sub contains_pod {my$file=shift;my$verbose=0;$verbose=shift if @_;my$podfh;if ($] < 5.006){$podfh=gensym()}unless(open($podfh,"<$file")){warn "Error: $file is unreadable: $!\n";return}local $/=undef;my$pod=<$podfh>;close($podfh)|| die "Error closing $file: $!\n";unless($pod =~ /^=(head\d|pod|over|item|cut)\b/m){warn "No POD in $file, skipping.\n" if($verbose);return 0}return 1}1;
POD_FIND

$fatpacked{"Pod/InputObjects.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_INPUTOBJECTS';
  package Pod::InputObjects;use strict;use vars qw($VERSION);$VERSION='1.63';require 5.005;package Pod::InputSource;sub new {my$this=shift;my$class=ref($this)|| $this;my$self={-name=>'(unknown)',-handle=>undef,-was_cutting=>0,@_ };bless$self,$class;return$self}sub name {(@_ > 1)and $_[0]->{'-name'}=$_[1];return $_[0]->{'-name'}}*filename=\&name;sub handle {return $_[0]->{'-handle'}}sub was_cutting {(@_ > 1)and $_[0]->{-was_cutting}=$_[1];return $_[0]->{-was_cutting}}package Pod::Paragraph;sub new {my$this=shift;my$class=ref($this)|| $this;my$self={-name=>undef,-text=>(@_==1)? shift : undef,-file=>'<unknown-file>',-line=>0,-prefix=>'=',-separator=>' ',-ptree=>[],@_ };bless$self,$class;return$self}sub cmd_name {(@_ > 1)and $_[0]->{'-name'}=$_[1];return $_[0]->{'-name'}}*name=\&cmd_name;sub text {(@_ > 1)and $_[0]->{'-text'}=$_[1];return $_[0]->{'-text'}}sub raw_text {return $_[0]->{'-text'}unless (defined $_[0]->{'-name'});return $_[0]->{'-prefix'}.$_[0]->{'-name'}.$_[0]->{'-separator'}.$_[0]->{'-text'}}sub cmd_prefix {return $_[0]->{'-prefix'}}sub cmd_separator {return $_[0]->{'-separator'}}sub parse_tree {(@_ > 1)and $_[0]->{'-ptree'}=$_[1];return $_[0]->{'-ptree'}}*ptree=\&parse_tree;sub file_line {my@loc=($_[0]->{'-file'}|| '<unknown-file>',$_[0]->{'-line'}|| 0);return (wantarray)? @loc : join(':',@loc)}package Pod::InteriorSequence;sub new {my$this=shift;my$class=ref($this)|| $this;if (((@_ <= 2)or (@_ % 2))and $_[0]!~ /^-\w/){unshift @_,'-name'}if ((@_ % 2)!=0){splice @_,$#_,0,'-ptree'}my$self={-name=>(@_==1)? $_[0]: undef,-file=>'<unknown-file>',-line=>0,-ldelim=>'<',-rdelim=>'>',@_ };my$ptree=$self->{'-ptree'}|| new Pod::ParseTree();if (ref$ptree =~ /^(ARRAY)?$/){$ptree=new Pod::ParseTree($1 ? [$ptree]: $ptree)}$self->{'-ptree'}=$ptree;bless$self,$class;return$self}sub cmd_name {(@_ > 1)and $_[0]->{'-name'}=$_[1];return $_[0]->{'-name'}}*name=\&cmd_name;sub _set_child2parent_links {my ($self,@children)=@_;for (@children){next unless (length and ref and ref ne 'SCALAR');if (UNIVERSAL::isa($_,'Pod::InteriorSequence')or UNIVERSAL::can($_,'nested')){$_->nested($self)}}}sub _unset_child2parent_links {my$self=shift;$self->{'-parent_sequence'}=undef;my$ptree=$self->{'-ptree'};for (@$ptree){next unless (length and ref and ref ne 'SCALAR');$_->_unset_child2parent_links()if UNIVERSAL::isa($_,'Pod::InteriorSequence')}}sub prepend {my$self=shift;$self->{'-ptree'}->prepend(@_);_set_child2parent_links($self,@_);return$self}sub append {my$self=shift;$self->{'-ptree'}->append(@_);_set_child2parent_links($self,@_);return$self}sub nested {my$self=shift;(@_==1)and $self->{'-parent_sequence'}=shift;return$self->{'-parent_sequence'}|| undef}sub raw_text {my$self=shift;my$text=$self->{'-name'}.$self->{'-ldelim'};for ($self->{'-ptree'}->children){$text .= (ref $_)? $_->raw_text : $_}$text .= $self->{'-rdelim'};return$text}sub left_delimiter {(@_ > 1)and $_[0]->{'-ldelim'}=$_[1];return $_[0]->{'-ldelim'}}*ldelim=\&left_delimiter;sub right_delimiter {(@_ > 1)and $_[0]->{'-rdelim'}=$_[1];return $_[0]->{'-rdelim'}}*rdelim=\&right_delimiter;sub parse_tree {(@_ > 1)and $_[0]->{'-ptree'}=$_[1];return $_[0]->{'-ptree'}}*ptree=\&parse_tree;sub file_line {my@loc=($_[0]->{'-file'}|| '<unknown-file>',$_[0]->{'-line'}|| 0);return (wantarray)? @loc : join(':',@loc)}sub DESTROY {_unset_child2parent_links(@_)}package Pod::ParseTree;sub new {my$this=shift;my$class=ref($this)|| $this;my$self=(@_==1 and ref $_[0])? $_[0]: [];bless$self,$class;return$self}sub top {my$self=shift;if (@_ > 0){@{$self}=(@_==1 and ref $_[0])? ${@_}: @_}return$self}*parse_tree=*ptree=\&top;sub children {my$self=shift;if (@_ > 0){@{$self}=(@_==1 and ref $_[0])? ${@_}: @_}return @{$self}}use vars qw(@ptree);sub prepend {my$self=shift;local*ptree=$self;for (@_){next unless length;if (@ptree &&!(ref$ptree[0])&&!(ref $_)){$ptree[0]=$_ .$ptree[0]}else {unshift@ptree,$_}}}sub append {my$self=shift;local*ptree=$self;my$can_append=@ptree &&!(ref$ptree[-1]);for (@_){if (ref){push@ptree,$_}elsif(!length){next}elsif ($can_append){$ptree[-1].= $_}else {push@ptree,$_}}}sub raw_text {my$self=shift;my$text='';for (@$self){$text .= (ref $_)? $_->raw_text : $_}return$text}sub _unset_child2parent_links {my$self=shift;local*ptree=$self;for (@ptree){next unless (defined and length and ref and ref ne 'SCALAR');$_->_unset_child2parent_links()if UNIVERSAL::isa($_,'Pod::InteriorSequence')}}sub _set_child2parent_links {}sub DESTROY {_unset_child2parent_links(@_)}1;
POD_INPUTOBJECTS

$fatpacked{"Pod/Man.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_MAN';
  package Pod::Man;use 5.006;use strict;use warnings;use subs qw(makespace);use vars qw(@ISA %ESCAPES $PREAMBLE $VERSION);use Carp qw(carp croak);use Pod::Simple ();our$HAS_ENCODE;BEGIN {$HAS_ENCODE=eval {require Encode}}@ISA=qw(Pod::Simple);$VERSION='4.07';BEGIN {my$parent=defined (&Pod::Simple::DEBUG)? \&Pod::Simple::DEBUG : undef;unless (defined&DEBUG){*DEBUG=$parent || sub () {10}}}BEGIN {*ASCII=\&Pod::Simple::ASCII}BEGIN {*pretty=\&Pod::Simple::pretty}my%FORMATTING=(DEFAULT=>{cleanup=>1,convert=>1,guesswork=>1,literal=>0 },Data=>{cleanup=>0,convert=>0,guesswork=>0,literal=>0 },Verbatim=>{guesswork=>0,literal=>1 },C=>{guesswork=>0,literal=>1 },X=>{cleanup=>0,guesswork=>0 },);sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if (my$preserve_whitespace=$self->can ('preserve_whitespace')){$self->$preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/man MAN roff ROFF/);$self->merge_text (1);%$self=(%$self,@_);if ($$self{stderr}and not $$self{errors}){$$self{errors}='stderr'}delete $$self{stderr};if (not defined $$self{errors}){$$self{errors}='pod'}if ($$self{errors}eq 'stderr' || $$self{errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{errors}eq 'none'){$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};if ($$self{utf8}and!$HAS_ENCODE){if (!$ENV{PERL_CORE}){carp ('utf8 mode requested but Encode module not available,' .' falling back to non-utf8')}delete $$self{utf8}}$self->init_fonts;$self->init_quotes;$self->init_page;$$self{MAGIC_CPP}=1;$$self{MAGIC_EMDASH}=1;$$self{MAGIC_FUNC}=1;$$self{MAGIC_MANREF}=1;$$self{MAGIC_SMALLCAPS}=1;$$self{MAGIC_VARS}=1;return$self}sub toescape {(length ($_[0])> 1 ? '\f(' : '\f').$_[0]}sub init_fonts {my ($self)=@_;for (qw/fixed fixedbold fixeditalic fixedbolditalic/){my$font=$$self{$_};if (defined ($font)&& (length ($font)< 1 || length ($font)> 2)){croak qq(roff font should be 1 or 2 chars, not "$font")}}$$self{fixed}||= 'CW';$$self{fixedbold}||= 'CB';$$self{fixeditalic}||= 'CI';$$self{fixedbolditalic}||= 'CB';$$self{FONTS}={'000'=>'\fR','001'=>'\fI','010'=>'\fB','011'=>'\f(BI','100'=>toescape ($$self{fixed}),'101'=>toescape ($$self{fixeditalic}),'110'=>toescape ($$self{fixedbold}),'111'=>toescape ($$self{fixedbolditalic})}}sub init_quotes {my ($self)=(@_);$$self{quotes}||= '"';if ($$self{quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{quotes}}elsif (length ($$self{quotes})% 2==0){my$length=length ($$self{quotes})/ 2;$$self{LQUOTE}=substr ($$self{quotes},0,$length);$$self{RQUOTE}=substr ($$self{quotes},$length)}else {croak(qq(Invalid quote specification "$$self{quotes}"))}$$self{LQUOTE}=~ s/\"/\"\"/;$$self{RQUOTE}=~ s/\"/\"\"/}sub init_page {my ($self)=@_;my@version=($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);$version[2]||= 0;$version[2]*= 10 ** (3 - length$version[2]);for (@version){$_ += 0}my$version=join ('.',@version);$$self{center}='User Contributed Perl Documentation' unless defined $$self{center};$$self{release}='perl v' .$version unless defined $$self{release};$$self{indent}=4 unless defined $$self{indent};for (qw/center release/){$$self{$_}=~ s/\"/\"\"/g if $$self{$_}}}sub _handle_text {my ($self,$text)=@_;DEBUG > 3 and print "== $text\n";my$tag=$$self{PENDING}[-1];$$tag[2].= $self->format_text ($$tag[1],$text)}sub method_for_element {my ($self,$element)=@_;$element =~ tr/A-Z-/a-z_/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;DEBUG > 3 and print "++ $element (<",join ('> <',%$attrs),">)\n";my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){DEBUG > 2 and print "<$element> starts saving a tag\n";$$self{IN_NAME}=0 if ($element ne 'Para' && length ($element)> 1);my$formatting={%{$$self{PENDING}[-1][1]|| $FORMATTING{DEFAULT}},%{$FORMATTING{$element}|| {}},};push (@{$$self{PENDING}},[$attrs,$formatting,'' ]);DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n"}elsif (my$start_method=$self->can ("start_$method")){$self->$start_method ($attrs,'')}else {DEBUG > 2 and print "No $method start method, skipping\n"}}sub _handle_element_end {my ($self,$element)=@_;DEBUG > 3 and print "-- $element\n";my$method=$self->method_for_element ($element);if (my$cmd_method=$self->can ("cmd_$method")){DEBUG > 2 and print "</$element> stops saving a tag\n";my$tag=pop @{$$self{PENDING}};DEBUG > 4 and print "Popped: [",pretty ($tag),"]\n";DEBUG > 4 and print "Pending: [",pretty ($$self{PENDING}),"]\n";my$text=$self->$cmd_method ($$tag[0],$$tag[2]);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][2].= $text}else {$self->output ($text)}}}elsif (my$end_method=$self->can ("end_$method")){$self->$end_method ()}else {DEBUG > 2 and print "No $method end method, skipping\n"}}sub format_text {my ($self,$options,$text)=@_;my$guesswork=$$options{guesswork}&&!$$self{IN_NAME};my$cleanup=$$options{cleanup};my$convert=$$options{convert};my$literal=$$options{literal};if ($cleanup){$text =~ s/\\/\\e/g;$text =~ s/-/\\-/g;$text =~ s/_(?=_)/_\\|/g}if ($convert &&!$$self{utf8}&& ASCII){$text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg}if ($literal){$text =~ s/(?<!\\\*)\'/\\*\(Aq/g;$text =~ s/(?<!\\\*)\`/\\\`/g}if ($guesswork){$text=$self->guesswork ($text)}return$text}sub quote_literal {my$self=shift;local $_=shift;my$index='(?: \[.*\] | \{.*\} )?';return qq{"$_"} if $$self{IN_NAME};m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
         | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xso and return '\f(FS' .$_ .'\f(FE';return '\f(FS\*(C`' .$_ ."\\*(C'\\f(FE"}sub guesswork {my$self=shift;local $_=shift;DEBUG > 5 and print "   Guesswork called on [$_]\n";s{
          ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
          ( (?: [a-zA-Z\']+ \\-)+ )
          ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
          \b
      } {
          my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
          $hyphen ||= '';
          $main =~ s/\\-/-/g;
          $prefix . $hyphen . $main . $suffix;
      }egx;if ($$self{MAGIC_EMDASH}){s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx}if ($$self{MAGIC_SMALLCAPS}){s{
              ( ^ | [\s\(\"\'\`\[\{<>] | \\[ ]  )                     # (1)
              ( [A-Z] [A-Z] (?: [/A-Z+:\d_\$&] | \\- | [.,\"\s] )* )  # (2)
              (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\[ ] | $ )      # (3)
          } {
              $1 . '\s-1' . $2 . '\s0'
          }egx}if ($$self{MAGIC_FUNC}){s{
              ( \b | \\s-1 )
              ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
          } {
              $1 . '\f(IS' . $2 . '\f(IE'
          }egx}if ($$self{MAGIC_MANREF}){s{
              ( \b | \\s-1 )
              ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
              ( \( \d [a-z]* \) )
          } {
              $1 . '\f(IS' . $2 . '\f(IE\|' . $3
          }egx}if ($$self{MAGIC_VARS}){s{
             ( ^ | \s+ )
             ( [\$\@%] [\w:]+ )
             (?! \( )
          } {
              $1 . '\f(FS' . $2 . '\f(FE'
          }egx}s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;if ($$self{MAGIC_CPP}){s{ \b C\+\+ } {\\*\(C+}gx}DEBUG > 5 and print "   Guesswork returning [$_]\n";return $_}sub mapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);my$last='\fR';$text =~ s<
          \\f\((.)(.)
      > <
          my $sequence = '';
          my $f;
          if ($last ne '\fR') { $sequence = '\fP' }
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
          if ($f eq $last) {
              '';
          } else {
              if ($f ne '\fR') { $sequence .= $f }
              $last = $f;
              $sequence;
          }
      >gxe;return$text}sub textmapfonts {my ($self,$text)=@_;my ($fixed,$bold,$italic)=(0,0,0);my%magic=(F=>\$fixed,B=>\$bold,I=>\$italic);$text =~ s<
          \\f\((.)(.)
      > <
          ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
          $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
      >gxe;return$text}sub switchquotes {my ($self,$command,$text,$extra)=@_;$text =~ s/\\\*\([LR]\"/\"/g;my$c_is_quote=($$self{LQUOTE}=~ /\"/)|| ($$self{RQUOTE}=~ /\"/);my$fixedpat=join '|',@{$$self{FONTS}}{'100','101','110','111'};$fixedpat =~ s/\\/\\\\/g;$fixedpat =~ s/\(/\\\(/g;if ($text =~ m/\"/ || $text =~ m/$fixedpat/){$text =~ s/\"/\"\"/g;my$nroff=$text;my$troff=$text;$troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/){$nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;$nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;$troff =~ s/\\\*\(C[\'\`]//g}$nroff=qq("$nroff") .($extra ? " $extra" : '');$troff=qq("$troff") .($extra ? " $extra" : '');my$font_end="(?:\\f[PR]|\Q$$self{FONTS}{100}\E)";$nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f([PR])/$1/g;$nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)$font_end/\\fI$1\\fP/g;$nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)$font_end/\\fB$1\\fP/g;$nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)$font_end/\\f\(BI$1\\fP/g;if ($nroff ne $troff){return ".ie n $command $nroff\n.el $command $troff\n"}else {return "$command $nroff\n"}}else {$text=qq("$text") .($extra ? " $extra" : '');return "$command $text\n"}}sub protect {my ($self,$text)=@_;$text =~ s/^([.\'\\])/\\&$1/mg;return$text}sub makespace {my ($self)=@_;$self->output (".PD\n")if $$self{ITEMS}> 1;$$self{ITEMS}=0;$self->output ($$self{INDENT}> 0 ? ".Sp\n" : ".PP\n")if $$self{NEEDSPACE}}sub outindex {my ($self,$section,$index)=@_;my@entries=map {split m%\s*/\s*%}@{$$self{INDEX}};return unless ($section || @entries);$$self{INDEX}=[];my@output;if (@entries){push@output,['Xref',join (' ',@entries)]}if ($section){$index =~ s/\\-/-/g;$index =~ s/\\(?:s-?\d|.\(..|.)//g;push@output,[$section,$index ]}for (@output){my ($type,$entry)=@$_;$entry =~ s/\s+/ /g;$entry =~ s/\"/\"\"/g;$entry =~ s/\\/\\\\/g;$self->output (".IX $type " .'"' .$entry .'"' ."\n")}}sub output {my ($self,@text)=@_;if ($$self{ENCODE}){print {$$self{output_fh}}Encode::encode ('UTF-8',join ('',@text))}else {print {$$self{output_fh}}@text}}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){DEBUG and print "Document is contentless\n";$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}$$self{ENCODE}=0;if ($$self{utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my$flag=(PerlIO::get_layers ($$self{output_fh},@options))[-1];if ($flag & PerlIO::F_UTF8 ()){$$self{ENCODE}=0}}}if (!$$self{CONTENTLESS}){my ($name,$section);if (defined $$self{name}){$name=$$self{name};$section=$$self{section}|| 1}else {($name,$section)=$self->devise_title}my$date=defined($$self{date})? $$self{date}: $self->devise_date;$self->preamble ($name,$section,$date)unless$self->bare_output or DEBUG > 9}$$self{INDENT}=0;$$self{INDENTS}=[];$$self{INDEX}=[];$$self{IN_NAME}=0;$$self{ITEMS}=0;$$self{ITEMTYPES}=[];$$self{SHIFTWAIT}=0;$$self{SHIFTS}=[];$$self{PENDING}=[[]]}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}return if$self->bare_output;return if ($$self{CONTENTLESS}&&!$$self{ALWAYS_EMIT_SOMETHING});$self->output (q(.\" [End document]) ."\n")if DEBUG}sub devise_title {my ($self)=@_;my$name=$self->source_filename || '';my$section=$$self{section}|| 1;$section=3 if (!$$self{section}&& $name =~ /\.pm\z/i);$name =~ s/\.p(od|[lm])\z//i;if ($name =~ /^IO::File(?:=\w+)\(0x[\da-f]+\)$/i){$name=''}if ($name eq ''){$self->whine (1,'No name given for document');$name='STDIN'}if ($section !~ /^3/){require File::Basename;$name=uc File::Basename::basename ($name)}else {require File::Spec;my ($volume,$dirs,$file)=File::Spec->splitpath ($name);my@dirs=File::Spec->splitdir ($dirs);if (@dirs){my$cut=0;my$i;for ($i=0;$i < @dirs;$i++){if ($dirs[$i]=~ /perl/){$cut=$i + 1;$cut++ if ($dirs[$i + 1]&& $dirs[$i + 1]eq 'lib');last}}if ($cut > 0){splice (@dirs,0,$cut);shift@dirs if ($dirs[0]=~ /^(site|vendor)(_perl)?$/);shift@dirs if ($dirs[0]=~ /^[\d.]+$/);shift@dirs if ($dirs[0]=~ /^(.*-$^O|$^O-.*|$^O)$/)}shift@dirs if$dirs[0]eq 'lib';splice (@dirs,0,2)if ($dirs[0]eq 'blib' && $dirs[1]eq 'lib')}$name=join ('::',(grep {$_ ? $_ : ()}@dirs),$file)}return ($name,$section)}sub devise_date {my ($self)=@_;if (defined($ENV{POD_MAN_DATE})){return$ENV{POD_MAN_DATE}}my$time;if (defined($ENV{SOURCE_DATE_EPOCH})&& $ENV{SOURCE_DATE_EPOCH}!~ /\D/){$time=$ENV{SOURCE_DATE_EPOCH}}if (!defined$time){my$input=$self->source_filename;if ($input){$time=(stat($input))[9]|| time()}else {$time=time()}}my ($year,$month,$day)=(gmtime($time))[5,4,3];return sprintf("%04d-%02d-%02d",$year + 1900,$month + 1,$day)}sub preamble {my ($self,$name,$section,$date)=@_;my$preamble=$self->preamble_template (!$$self{utf8});my$index="$name $section";$index =~ s/\"/\"\"/g;for ($name,$section){if (/\s/){s/\"/\"\"/g;$_='"' .$_ .'"'}}$date =~ s/\"/\"\"/g;$preamble =~ s/\@CFONT\@/$$self{fixed}/;$preamble =~ s/\@LQUOTE\@/$$self{LQUOTE}/;$preamble =~ s/\@RQUOTE\@/$$self{RQUOTE}/;chomp$preamble;my$version=$self->version_report;$self->output (<<"----END OF HEADER----");$self->output (".\\\" [End of preamble]\n")if DEBUG}sub cmd_para {my ($self,$attrs,$text)=@_;my$line=$$attrs{start_line};$self->makespace;if ($$self{SHIFTWAIT}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT});$$self{SHIFTWAIT}=0}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG &&!$$self{IN_NAME};$text=reverse$text;$text =~ s/\A\s*?(?= \\|\S|\z)/\n/;$text=reverse$text;$self->output ($self->protect ($self->textmapfonts ($text)));$self->outindex;$$self{NEEDSPACE}=1;return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;return unless$text =~ /\S/;$text=reverse$text;$text =~ s/\A\s*/\n/;$text=reverse$text;my@lines=split (/\n/,$text);my$unbroken=0;for (@lines){last if /^\s*$/;$unbroken++}$unbroken=10 if ($unbroken > 12 &&!$$self{MAGIC_VNOPAGEBREAK_LIMIT});$text =~ s/^/\\&/gm;$self->makespace;$self->output (".Vb $unbroken\n$text.Ve\n");$$self{NEEDSPACE}=1;return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading_common {my ($self,$text,$line)=@_;$text =~ s/\s+$//;$text =~ s/\s*\n\s*/ /g;if ($$self{ITEMS}> 1){$$self{ITEMS}=0;$self->output (".PD\n")}$self->output (".\\\" [At source line $line]\n")if defined ($line)&& DEBUG;return$text}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\\s-?\d//g;$text=$self->heading_common ($text,$$attrs{start_line});my$isname=($text eq 'NAME' || $text =~ /\(NAME\)/);$self->output ($self->switchquotes ('.SH',$self->mapfonts ($text)));$self->outindex ('Header',$text)unless$isname;$$self{NEEDSPACE}=0;$$self{IN_NAME}=$isname;return ''}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->output ($self->switchquotes ('.SS',$self->mapfonts ($text)));$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=0;return ''}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ('\f(IS' .$text .'\f(IE')."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text=$self->heading_common ($text,$$attrs{start_line});$self->makespace;$self->output ($self->textmapfonts ($text)."\n");$self->outindex ('Subsection',$text);$$self{NEEDSPACE}=1;return ''}sub cmd_b {return $_[0]->{IN_NAME}? $_[2]: '\f(BS' .$_[2].'\f(BE'}sub cmd_i {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_f {return $_[0]->{IN_NAME}? $_[2]: '\f(IS' .$_[2].'\f(IE'}sub cmd_c {return $_[0]->quote_literal ($_[2])}sub cmd_x {my ($self,$attrs,$text)=@_;push (@{$$self{INDEX}},$text);return ''}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){my$to=$$attrs{to};if (defined$to){my$tag=$$self{PENDING}[-1];$to=$self->format_text ($$tag[1],$to)}if (not defined ($to)or $to eq $text){return "<$text>"}elsif ($$self{nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub over_common_start {my ($self,$type,$attrs)=@_;my$line=$$attrs{start_line};my$indent=$$attrs{indent};DEBUG > 3 and print " Starting =over $type (line $line, indent ",($indent || '?'),"\n";unless (defined ($indent)&& $indent =~ /^[-+]?\d{1,4}\s*$/){$indent=$$self{indent}}if (@{$$self{SHIFTS}}< @{$$self{INDENTS}}){$self->output (".RS $$self{INDENT}\n");push (@{$$self{SHIFTS}},$$self{INDENT})}push (@{$$self{INDENTS}},$$self{INDENT});push (@{$$self{ITEMTYPES}},$type);$$self{INDENT}=$indent + 0;$$self{SHIFTWAIT}=1}sub over_common_end {my ($self)=@_;DEBUG > 3 and print " Ending =over\n";$$self{INDENT}=pop @{$$self{INDENTS}};pop @{$$self{ITEMTYPES}};if (@{$$self{SHIFTS}}> @{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}if (@{$$self{INDENTS}}> 0){$self->output (".RE\n");$self->output (".RS $$self{INDENT}\n")}$$self{NEEDSPACE}=1;$$self{SHIFTWAIT}=0}sub start_over_bullet {my$s=shift;$s->over_common_start ('bullet',@_)}sub start_over_number {my$s=shift;$s->over_common_start ('number',@_)}sub start_over_text {my$s=shift;$s->over_common_start ('text',@_)}sub start_over_block {my$s=shift;$s->over_common_start ('block',@_)}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;my$line=$$attrs{start_line};DEBUG > 3 and print "  $type item (line $line): $text\n";$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item="\\\(bu";$text =~ s/\n*$/\n/}elsif ($type eq 'number'){$item=$$attrs{number}.'.'}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text='';$index=$item if ($item =~ /\w/)}if (@{$$self{SHIFTS}}==@{$$self{INDENTS}}){$self->output (".RE\n");pop @{$$self{SHIFTS}}}$self->output (".PD 0\n")if ($$self{ITEMS}==1);$item=$self->textmapfonts ($item);$self->output ($self->switchquotes ('.IP',$item,$$self{INDENT}));$$self{NEEDSPACE}=0;$$self{ITEMS}++;$$self{SHIFTWAIT}=0;if ($text){$text =~ s/\s*$/\n/;$self->makespace;$self->output ($self->protect ($self->textmapfonts ($text)));$$self{NEEDSPACE}=1}$self->outindex ($index ? ('Item',$index): ())}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->SUPER::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;return$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}@ESCAPES{0xA0 .. 0xFF}=("\\ ",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"\\%",undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,"A\\*`","A\\*'","A\\*^","A\\*~","A\\*:","A\\*o","\\*(Ae","C\\*,","E\\*`","E\\*'","E\\*^","E\\*:","I\\*`","I\\*'","I\\*^","I\\*:","\\*(D-","N\\*~","O\\*`","O\\*'","O\\*^","O\\*~","O\\*:",undef,"O\\*/","U\\*`","U\\*'","U\\*^","U\\*:","Y\\*'","\\*(Th","\\*8","a\\*`","a\\*'","a\\*^","a\\*~","a\\*:","a\\*o","\\*(ae","c\\*,","e\\*`","e\\*'","e\\*^","e\\*:","i\\*`","i\\*'","i\\*^","i\\*:","\\*(d-","n\\*~","o\\*`","o\\*'","o\\*^","o\\*~","o\\*:",undef,"o\\*/","u\\*`","u\\*'","u\\*^","u\\*:","y\\*'","\\*(th","y\\*:",)if ASCII;sub preamble_template {my ($self,$accents)=@_;my$preamble=<<'----END OF PREAMBLE----';if ($accents){$preamble .= <<'----END OF PREAMBLE----'}return$preamble}1;
  .\\" Automatically generated by $version
  .\\"
  .\\" Standard preamble:
  .\\" ========================================================================
  $preamble
  .\\" ========================================================================
  .\\"
  .IX Title "$index"
  .TH $name $section "$date" "$$self{release}" "$$self{center}"
  .\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
  .\\" way too many mistakes in technical documents.
  .if n .ad l
  .nh
  ----END OF HEADER----
  .de Sp \" Vertical space (when we can't use .PP)
  .if t .sp .5v
  .if n .sp
  ..
  .de Vb \" Begin verbatim text
  .ft @CFONT@
  .nf
  .ne \\$1
  ..
  .de Ve \" End verbatim text
  .ft R
  .fi
  ..
  .\" Set up some character translations and predefined strings.  \*(-- will
  .\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
  .\" double quote, and \*(R" will give a right double quote.  \*(C+ will
  .\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
  .\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
  .\" nothing in troff, for use with C<>.
  .tr \(*W-
  .ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
  .ie n \{\
  .    ds -- \(*W-
  .    ds PI pi
  .    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
  .    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
  .    ds L" ""
  .    ds R" ""
  .    ds C` @LQUOTE@
  .    ds C' @RQUOTE@
  'br\}
  .el\{\
  .    ds -- \|\(em\|
  .    ds PI \(*p
  .    ds L" ``
  .    ds R" ''
  .    ds C`
  .    ds C'
  'br\}
  .\"
  .\" Escape single quotes in literal strings from groff's Unicode transform.
  .ie \n(.g .ds Aq \(aq
  .el       .ds Aq '
  .\"
  .\" If the F register is >0, we'll generate index entries on stderr for
  .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
  .\" entries marked with X<> in POD.  Of course, you'll have to process the
  .\" output yourself in some meaningful fashion.
  .\"
  .\" Avoid warning from groff about undefined register 'F'.
  .de IX
  ..
  .if !\nF .nr F 0
  .if \nF>0 \{\
  .    de IX
  .    tm Index:\\$1\t\\n%\t"\\$2"
  ..
  .    if !\nF==2 \{\
  .        nr % 0
  .        nr F 2
  .    \}
  .\}
  ----END OF PREAMBLE----
  .\"
  .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
  .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
  .    \" fudge factors for nroff and troff
  .if n \{\
  .    ds #H 0
  .    ds #V .8m
  .    ds #F .3m
  .    ds #[ \f1
  .    ds #] \fP
  .\}
  .if t \{\
  .    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
  .    ds #V .6m
  .    ds #F 0
  .    ds #[ \&
  .    ds #] \&
  .\}
  .    \" simple accents for nroff and troff
  .if n \{\
  .    ds ' \&
  .    ds ` \&
  .    ds ^ \&
  .    ds , \&
  .    ds ~ ~
  .    ds /
  .\}
  .if t \{\
  .    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
  .    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
  .    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
  .    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
  .    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
  .    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
  .\}
  .    \" troff and (daisy-wheel) nroff accents
  .ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
  .ds 8 \h'\*(#H'\(*b\h'-\*(#H'
  .ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
  .ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
  .ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
  .ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
  .ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
  .ds ae a\h'-(\w'a'u*4/10)'e
  .ds Ae A\h'-(\w'A'u*4/10)'E
  .    \" corrections for vroff
  .if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
  .if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
  .    \" for low resolution devices (crt and lpr)
  .if \n(.H>23 .if \n(.V>19 \
  \{\
  .    ds : e
  .    ds 8 ss
  .    ds o a
  .    ds d- d\h'-1'\(ga
  .    ds D- D\h'-1'\(hy
  .    ds th \o'bp'
  .    ds Th \o'LP'
  .    ds ae ae
  .    ds Ae AE
  .\}
  .rm #[ #] #H #V #F C
  ----END OF PREAMBLE----
POD_MAN

$fatpacked{"Pod/ParseLink.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSELINK';
  package Pod::ParseLink;use 5.006;use strict;use warnings;use vars qw(@EXPORT @ISA $VERSION);use Exporter;@ISA=qw(Exporter);@EXPORT=qw(parselink);$VERSION='4.07';sub _parse_section {my ($link)=@_;$link =~ s/^\s+//;$link =~ s/\s+$//;return (undef,$1)if ($link =~ /^"\s*(.*?)\s*"$/);my ($page,$section)=split (/\s*\/\s*/,$link,2);$section =~ s/^"\s*(.*?)\s*"$/$1/ if$section;if ($page && $page =~ / / &&!defined ($section)){$section=$page;$page=undef}else {$page=undef unless$page;$section=undef unless$section}return ($page,$section)}sub _infer_text {my ($page,$section)=@_;my$inferred;if ($page &&!$section){$inferred=$page}elsif (!$page && $section){$inferred='"' .$section .'"'}elsif ($page && $section){$inferred='"' .$section .'" in ' .$page}return$inferred}sub parselink {my ($link)=@_;$link =~ s/\s+/ /g;my$text;if ($link =~ /\|/){($text,$link)=split (/\|/,$link,2)}if ($link =~ /\A\w+:[^:\s]\S*\Z/){my$inferred;if (defined ($text)&& length ($text)> 0){return ($text,$text,$link,undef,'url')}else {return ($text,$link,$link,undef,'url')}}else {my ($name,$section)=_parse_section ($link);my$inferred;if (defined ($text)&& length ($text)> 0){$inferred=$text}else {$inferred=_infer_text ($name,$section)}my$type=($name && $name =~ /\(\S*\)/)? 'man' : 'pod';return ($text,$inferred,$name,$section,$type)}}1;
POD_PARSELINK

$fatpacked{"Pod/ParseUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSEUTILS';
  package Pod::ParseUtils;use strict;use vars qw($VERSION);$VERSION='1.63';require 5.005;package Pod::List;use Carp;sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;$self->initialize();return$self}sub initialize {my$self=shift;$self->{-file}||= 'unknown';$self->{-start}||= 'unknown';$self->{-indent}||= 4;$self->{_items}=[];$self->{-type}||= ''}sub file {return (@_ > 1)? ($_[0]->{-file}=$_[1]): $_[0]->{-file}}sub start {return (@_ > 1)? ($_[0]->{-start}=$_[1]): $_[0]->{-start}}sub indent {return (@_ > 1)? ($_[0]->{-indent}=$_[1]): $_[0]->{-indent}}sub type {return (@_ > 1)? ($_[0]->{-type}=$_[1]): $_[0]->{-type}}sub rx {return (@_ > 1)? ($_[0]->{-rx}=$_[1]): $_[0]->{-rx}}sub item {my ($self,$item)=@_;if(defined$item){push(@{$self->{_items}},$item);return$item}else {return @{$self->{_items}}}}sub parent {return (@_ > 1)? ($_[0]->{-parent}=$_[1]): $_[0]->{-parent}}sub tag {return (@_ > 1)? ($_[0]->{-tag}=$_[1]): $_[0]->{-tag}}package Pod::Hyperlink;use Carp;sub new {my$this=shift;my$class=ref($this)|| $this;my$self=+{};bless$self,$class;$self->initialize();if(defined $_[0]){if(ref($_[0])){%$self=%{$_[0]};$self->_construct_text()}else {return unless($self->parse($_[0]))}}return$self}sub initialize {my$self=shift;$self->{-line}||= 'undef';$self->{-file}||= 'undef';$self->{-page}||= '';$self->{-node}||= '';$self->{-alttext}||= '';$self->{-type}||= 'undef';$self->{_warnings}=[]}sub parse {my$self=shift;local($_)=$_[0];my ($alttext,$page,$node,$type,$quoted)=(undef,'','','',0);$self->{_warnings}=[];s/\s*\n+\s*/ /g;if(s/^[\s\n]+//){$self->warning('ignoring leading whitespace in link')}if(s/[\s\n]+$//){$self->warning('ignoring trailing whitespace in link')}unless(length($_)){_invalid_link('empty link');return}my$page_rx='[\w.-]+(?:::[\w.-]+)*(?:[(](?:\d\w*|)[)]|)';if(/^($page_rx)$/o){$page=$1;$type='page'}elsif(m{^(.*?)\s*[|]\s*($page_rx)\s*/\s*"(.+)"$}o){($alttext,$page,$node)=($1,$2,$3);$type='section';$quoted=1}elsif(/^(.*?)\s*[|]\s*($page_rx)$/o){($alttext,$page)=($1,$2);$type='page'}elsif(m{^(.*?)\s*[|]\s*(?:/\s*|)"(.+)"$}){($alttext,$node)=($1,$2);$type='section';$quoted=1}elsif(m{^($page_rx)\s*/\s*"(.+)"$}o){($page,$node)=($1,$2);$type='section';$quoted=1}elsif(m{^($page_rx)\s*/\s*(.+)$}o){($page,$node)=($1,$2);$type='item'}elsif(m{^/?"(.+)"$}){$node=$1;$type='section';$quoted=1}elsif(m{^\s*/(.+)$}){$node=$1;$type='item'}elsif(/^ \s* (.*?) \s* [|] \s* (\w+:[^:\s] [^\s|]*?) \s* $/ix){($alttext,$node)=($1,$2);$type='hyperlink'}elsif(/^(\w+:[^:\s]\S*)$/i){$node=$1;$type='hyperlink'}elsif(m{^(.*?)\s*[|]\s*($page_rx)\s*/\s*(.+)$}o){($alttext,$page,$node)=($1,$2,$3);$type='item'}elsif(m{^(.*?)\s*[|]\s*/(.+)$}){($alttext,$node)=($1,$2)}else {$node=$_;$type='item'}$node =~ s/\s+/ /gs;if(defined$alttext){if(!length($alttext)){$alttext=$node || $page}}else {$alttext=''}if($page =~ /[(]\w*[)]$/){$self->warning("(section) in '$page' deprecated")}if(!$quoted && $node =~ m{[|/]} && $type ne 'hyperlink'){$self->warning("node '$node' contains non-escaped | or /")}if($alttext =~ m{[|/]}){$self->warning("alternative text '$node' contains non-escaped | or /")}$self->{-page}=$page;$self->{-node}=$node;$self->{-alttext}=$alttext;$self->{-type}=$type;$self->_construct_text();1}sub _construct_text {my$self=shift;my$alttext=$self->alttext();my$type=$self->type();my$section=$self->node();my$page=$self->page();my$page_ext='';$page =~ s/([(]\w*[)])$// && ($page_ext=$1);if($alttext){$self->{_text}=$alttext}elsif($type eq 'hyperlink'){$self->{_text}=$section}else {$self->{_text}=($section || '').(($page && $section)? ' in ' : '')."$page$page_ext"}if($alttext){$self->{_markup}="Q<$alttext>"}elsif($type eq 'hyperlink'){$self->{_markup}="Q<$section>"}else {$self->{_markup}=(!$section ? '' : "Q<$section>").($page ? ($section ? ' in ':'')."P<$page>$page_ext" : '')}}sub markup {return (@_ > 1)? ($_[0]->{_markup}=$_[1]): $_[0]->{_markup}}sub text {return $_[0]->{_text}}sub warning {my$self=shift;if(@_){push(@{$self->{_warnings}},@_);return @_}return @{$self->{_warnings}}}sub line {return (@_ > 1)? ($_[0]->{-line}=$_[1]): $_[0]->{-line}}sub file {return (@_ > 1)? ($_[0]->{-file}=$_[1]): $_[0]->{-file}}sub page {if (@_ > 1){$_[0]->{-page}=$_[1];$_[0]->_construct_text()}return $_[0]->{-page}}sub node {if (@_ > 1){$_[0]->{-node}=$_[1];$_[0]->_construct_text()}return $_[0]->{-node}}sub alttext {if (@_ > 1){$_[0]->{-alttext}=$_[1];$_[0]->_construct_text()}return $_[0]->{-alttext}}sub type {return (@_ > 1)? ($_[0]->{-type}=$_[1]): $_[0]->{-type}}sub link {my$self=shift;my$link=$self->page()|| '';if($self->node()){my$node=$self->node();$node =~ s/\|/E<verbar>/g;$node =~ s{/}{E<sol>}g;if($self->type()eq 'section'){$link .= ($link ? '/' : '').'"' .$node .'"'}elsif($self->type()eq 'hyperlink'){$link=$self->node()}else {$link .= '/' .$node}}if($self->alttext()){my$text=$self->alttext();$text =~ s/\|/E<verbar>/g;$text =~ s{/}{E<sol>}g;$link="$text|$link"}return$link}sub _invalid_link {my ($msg)=@_;$@=$msg;return}package Pod::Cache;sub new {my$this=shift;my$class=ref($this)|| $this;my$self=[];bless$self,$class;return$self}sub item {my ($self,%param)=@_;if(%param){my$item=Pod::Cache::Item->new(%param);push(@$self,$item);return$item}else {return @{$self}}}sub find_page {my ($self,$page)=@_;for(@$self){if($_->page()eq $page){return $_}}return}package Pod::Cache::Item;sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;$self->initialize();return$self}sub initialize {my$self=shift;$self->{-nodes}=[]unless(defined$self->{-nodes})}sub page {return (@_ > 1)? ($_[0]->{-page}=$_[1]): $_[0]->{-page}}sub description {return (@_ > 1)? ($_[0]->{-description}=$_[1]): $_[0]->{-description}}sub path {return (@_ > 1)? ($_[0]->{-path}=$_[1]): $_[0]->{-path}}sub file {return (@_ > 1)? ($_[0]->{-file}=$_[1]): $_[0]->{-file}}sub nodes {my ($self,@nodes)=@_;if(@nodes){push(@{$self->{-nodes}},@nodes);return@nodes}else {return @{$self->{-nodes}}}}sub find_node {my ($self,$node)=@_;my@search;push(@search,@{$self->{-nodes}})if($self->{-nodes});push(@search,@{$self->{-idx}})if($self->{-idx});for(@search){if($_->[0]eq $node){return $_->[1]}}return}sub idx {my ($self,@idx)=@_;if(@idx){push(@{$self->{-idx}},@idx);return@idx}else {return @{$self->{-idx}}}}1;
POD_PARSEUTILS

$fatpacked{"Pod/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PARSER';
  package Pod::Parser;use strict;use vars qw($VERSION @ISA %myData %myOpts @input_stack);$VERSION='1.63';require 5.005;use Pod::InputObjects;use Carp;use Exporter;BEGIN {if ($] < 5.006){require Symbol;import Symbol}}@ISA=qw(Exporter);sub command {my ($self,$cmd,$text,$line_num,$pod_para)=@_;$self->textblock($pod_para->raw_text(),$line_num,$pod_para)}sub verbatim {my ($self,$text,$line_num,$pod_para)=@_;my$out_fh=$self->{_OUTPUT};print$out_fh $text}sub textblock {my ($self,$text,$line_num,$pod_para)=@_;my$out_fh=$self->{_OUTPUT};print$out_fh $self->interpolate($text,$line_num)}sub interior_sequence {my ($self,$seq_cmd,$seq_arg,$pod_seq)=@_;return$pod_seq->raw_text()}sub new {my ($this,%params)=@_;my$class=ref($this)|| $this;my$self={%params };bless$self,$class;$self->initialize();return$self}sub initialize {}sub begin_pod {}sub begin_input {}sub end_input {}sub end_pod {}sub preprocess_line {my ($self,$text,$line_num)=@_;return$text}sub preprocess_paragraph {my ($self,$text,$line_num)=@_;return$text}sub parse_text {my$self=shift;local $_='';my%opts=(ref $_[0])? %{shift()}: ();my$expand_seq=$opts{'-expand_seq'}|| undef;my$expand_text=$opts{'-expand_text'}|| undef;my$expand_ptree=$opts{'-expand_ptree'}|| undef;my$text=shift;my$line=shift;my$file=$self->input_file();my$cmd="";my$xseq_sub=$expand_seq;my$xtext_sub=$expand_text;my$xptree_sub=$expand_ptree;if (defined$expand_seq and $expand_seq eq 'interior_sequence'){$xseq_sub=sub {my ($sself,$iseq)=@_;my$args=join('',$iseq->parse_tree->children);return$sself->interior_sequence($iseq->name,$args,$iseq)}}ref$xseq_sub or $xseq_sub=sub {shift()->$expand_seq(@_)};ref$xtext_sub or $xtext_sub=sub {shift()->$expand_text(@_)};ref$xptree_sub or $xptree_sub=sub {shift()->$expand_ptree(@_)};my$seq=Pod::ParseTree->new();my@seq_stack=($seq);my ($ldelim,$rdelim)=('','');$_=$text;my@tokens=split /([A-Z]<(?:<+(?:\r?\n|[ \t]))?)/;while (@tokens){$_=shift@tokens;if (/^([A-Z])(<(?:<+(?:\r?\n|[ \t]))?)$/){my$ldelim_orig;($cmd,$ldelim_orig)=($1,$2);($ldelim=$ldelim_orig)=~ s/\s+$//;($rdelim=$ldelim)=~ tr/</>/;$seq=Pod::InteriorSequence->new(-name=>$cmd,-ldelim=>$ldelim_orig,-rdelim=>$rdelim,-file=>$file,-line=>$line);(@seq_stack > 1)and $seq->nested($seq_stack[-1]);push@seq_stack,$seq}elsif (@seq_stack > 1){my ($seq_end,$post_seq)=('','');if (($ldelim eq '<' and /\A(.*?)(>)/s)or /\A(.*?)(\s+$rdelim)/s){$post_seq=substr($_,length($1)+ length($2));($_,$seq_end)=($1,$2);(length$post_seq)and unshift@tokens,$post_seq}if (length){$seq->append($expand_text ? &$xtext_sub($self,$_,$seq): $_);$_ .= $seq_end}if (length$seq_end){$seq->rdelim($seq_end);pop@seq_stack;$seq_stack[-1]->append($expand_seq ? &$xseq_sub($self,$seq): $seq);if(@seq_stack > 1){$cmd=$seq_stack[-1]->name;$ldelim=$seq_stack[-1]->ldelim;$rdelim=$seq_stack[-1]->rdelim}else {$cmd=$ldelim=$rdelim=''}}}elsif (length){$seq->append($expand_text ? &$xtext_sub($self,$_,$seq): $_)}$line += /\n/;$seq=$seq_stack[-1]}my$errorsub=(@seq_stack > 1)? $self->errorsub(): undef;while (@seq_stack > 1){($cmd,$file,$line)=($seq->name,$seq->file_line);$ldelim=$seq->ldelim;($rdelim=$ldelim)=~ tr/</>/;$rdelim =~ s/^(\S+)(\s*)$/$2$1/;pop@seq_stack;my$errmsg="*** ERROR: unterminated ${cmd}${ldelim}...${rdelim}"." at line $line in file $file\n";(ref$errorsub)and &{$errorsub}($errmsg)or (defined$errorsub)and $self->$errorsub($errmsg)or carp($errmsg);$seq_stack[-1]->append($expand_seq ? &$xseq_sub($self,$seq): $seq);$seq=$seq_stack[-1]}my$ptree=(pop@seq_stack)->parse_tree;return$expand_ptree ? &$xptree_sub($self,$ptree): $ptree}sub interpolate {my($self,$text,$line_num)=@_;my%parse_opts=(-expand_seq=>'interior_sequence');my$ptree=$self->parse_text(\%parse_opts,$text,$line_num);return join '',$ptree->children()}sub parse_paragraph {my ($self,$text,$line_num)=@_;local*myData=$self;local*myOpts=($myData{_PARSEOPTS}||= {});local $_;my$wantNonPods=$myOpts{'-want_nonPODs'};$myData{_CUTTING}=0 if$text =~ /^={1,2}\S/;$wantNonPods and $text=$self->preprocess_paragraph($text,$line_num);return if$myData{_CUTTING};if (exists$myData{_SELECTED_SECTIONS}){$self->is_selected($text)or return ($myData{_CUTTING}=1)}unless ($wantNonPods){$text=$self->preprocess_paragraph($text,$line_num);return 1 unless ((defined$text)and (length$text));return 1 if ($myData{_CUTTING})}my ($pfx,$cmd,$arg,$sep)=('','','','');my$pod_para=undef;if ($text =~ /^(={1,2})(?=\S)/){$pfx=$1;$_=substr($text,length$pfx);($cmd,$sep,$text)=split /(\s+)/,$_,2;$sep='' unless defined$sep;$text='' unless defined$text;if ($cmd eq 'cut'){$myData{_CUTTING}=1;return unless$myOpts{'-process_cut_cmd'}}}$pod_para=new Pod::Paragraph(-name=>$cmd,-text=>$text,-prefix=>$pfx,-separator=>$sep,-file=>$myData{_INFILE},-line=>$line_num);if ($myData{_WHITESPACE}and $myOpts{'-warnings'}and not ($text =~ /^\s+/ and ($myData{_PREVIOUS}||"")eq "verbatim")){my$errorsub=$self->errorsub();my$line=$line_num - 1;my$errmsg="*** WARNING: line containing nothing but whitespace"." in paragraph at line $line in file $myData{_INFILE}\n";(ref$errorsub)and &{$errorsub}($errmsg)or (defined$errorsub)and $self->$errorsub($errmsg)or carp($errmsg)}if (length$cmd){$self->command($cmd,$text,$line_num,$pod_para);$myData{_PREVIOUS}=$cmd}elsif ($text =~ /^\s+/){$self->verbatim($text,$line_num,$pod_para);$myData{_PREVIOUS}="verbatim"}else {$self->textblock($text,$line_num,$pod_para);$myData{_PREVIOUS}="textblock"}$myData{_WHITESPACE}=$text =~ /^[^\S\r\n]+\r*\Z/m ? 1 : 0;return 1}sub parse_from_filehandle {my$self=shift;my%opts=(ref $_[0]eq 'HASH')? %{shift()}: ();my ($in_fh,$out_fh)=@_;$in_fh=\*STDIN unless ($in_fh);local*myData=$self;local*myOpts=($myData{_PARSEOPTS}||= {});local $_;my$topstream=$self->_push_input_stream($in_fh,$out_fh);(exists$opts{-cutting})and $self->cutting($opts{-cutting});my ($textline,$paragraph)=('','');my ($nlines,$plines)=(0,0);$_=ref$in_fh;my$tied_fh=(/^(?:GLOB|FileHandle|IO::\w+)$/ or tied$in_fh);while (defined ($textline=$tied_fh ? <$in_fh> : $in_fh->getline)){$textline=$self->preprocess_line($textline,++$nlines);next unless ((defined$textline)&& (length$textline));if ((!length$paragraph)&& ($textline =~ /^==/)){$paragraph=$textline;$plines=1;$textline=''}else {$paragraph .= $textline;++$plines}next unless (($textline =~ /^[^\S\r\n]*[\r\n]*$/)&& (length$paragraph));parse_paragraph($self,$paragraph,($nlines - $plines)+ 1);$paragraph='';$plines=0}if (length$paragraph){parse_paragraph($self,$paragraph,($nlines - $plines)+ 1)}$self->_pop_input_stream()}sub parse_from_file {my$self=shift;my%opts=(ref $_[0]eq 'HASH')? %{shift()}: ();my ($infile,$outfile)=@_;my ($in_fh,$out_fh);if ($] < 5.006){($in_fh,$out_fh)=(gensym(),gensym())}my ($close_input,$close_output)=(0,0);local*myData=$self;local*_;if (defined$infile && ref$infile){if (ref($infile)=~ /^(SCALAR|ARRAY|HASH|CODE|REF)$/){croak "Input from $1 reference not supported!\n"}$myData{_INFILE}=${$infile};$in_fh=$infile}elsif (!defined($infile)||!length($infile)|| ($infile eq '-')|| ($infile =~ /^<&(?:STDIN|0)$/i)){$infile ||= '-';$myData{_INFILE}='<standard input>';$in_fh=\*STDIN}else {$myData{_INFILE}=$infile;open($in_fh,"< $infile")or croak "Can't open $infile for reading: $!\n";$close_input=1}if (ref$outfile){if (ref($outfile)=~ /^(ARRAY|HASH|CODE)$/){croak "Output to $1 reference not supported!\n"}elsif (ref($outfile)eq 'SCALAR'){croak "Output to SCALAR reference not supported!\n"}else {$myData{_OUTFILE}=${$outfile};$out_fh=$outfile}}elsif (!defined($outfile)||!length($outfile)|| ($outfile eq '-')|| ($outfile =~ /^>&?(?:STDOUT|1)$/i)){if (defined$myData{_TOP_STREAM}){$out_fh=$myData{_OUTPUT}}else {$outfile ||= '-';$myData{_OUTFILE}='<standard output>';$out_fh=\*STDOUT}}elsif ($outfile =~ /^>&(STDERR|2)$/i){$myData{_OUTFILE}='<standard error>';$out_fh=\*STDERR}else {$myData{_OUTFILE}=$outfile;(-d $outfile)and croak "$outfile is a directory, not POD input!\n";open($out_fh,"> $outfile")or croak "Can't open $outfile for writing: $!\n";$close_output=1}$self->parse_from_filehandle(\%opts,$in_fh,$out_fh);$close_input and close($in_fh)|| croak "Can't close $infile after reading: $!\n";$close_output and close($out_fh)|| croak "Can't close $outfile after writing: $!\n"}sub errorsub {return (@_ > 1)? ($_[0]->{_ERRORSUB}=$_[1]): $_[0]->{_ERRORSUB}}sub cutting {return (@_ > 1)? ($_[0]->{_CUTTING}=$_[1]): $_[0]->{_CUTTING}}sub parseopts {local*myData=shift;local*myOpts=($myData{_PARSEOPTS}||= {});return%myOpts if (@_==0);if (@_==1){local $_=shift;return ref($_)? $myData{_PARSEOPTS}=$_ : $myOpts{$_}}my@newOpts=(%myOpts,@_);$myData{_PARSEOPTS}={@newOpts }}sub output_file {return $_[0]->{_OUTFILE}}sub output_handle {return $_[0]->{_OUTPUT}}sub input_file {return $_[0]->{_INFILE}}sub input_handle {return $_[0]->{_INPUT}}sub input_streams {return $_[0]->{_INPUT_STREAMS}}sub top_stream {return $_[0]->{_TOP_STREAM}|| undef}sub _push_input_stream {my ($self,$in_fh,$out_fh)=@_;local*myData=$self;unless (defined$myData{_TOP_STREAM}){$out_fh=\*STDOUT unless (defined$out_fh);$myData{_CUTTING}=1;$myData{_INPUT_STREAMS}=[]}$myData{_OUTFILE}='(unknown)' unless (defined$myData{_OUTFILE});$myData{_OUTPUT}=$out_fh if (defined$out_fh);$in_fh=\*STDIN unless (defined$in_fh);$myData{_INFILE}='(unknown)' unless (defined$myData{_INFILE});$myData{_INPUT}=$in_fh;my$input_top=$myData{_TOP_STREAM}=new Pod::InputSource(-name=>$myData{_INFILE},-handle=>$in_fh,-was_cutting=>$myData{_CUTTING});local*input_stack=$myData{_INPUT_STREAMS};push(@input_stack,$input_top);$self->begin_pod()if (@input_stack==1);$self->begin_input();return$input_top}sub _pop_input_stream {my ($self)=@_;local*myData=$self;local*input_stack=$myData{_INPUT_STREAMS};$self->end_input()if (@input_stack > 0);$self->end_pod()if (@input_stack==1);my$old_top=pop(@input_stack);$myData{_CUTTING}=$old_top->was_cutting();my$input_top=undef;if (@input_stack > 0){$input_top=$myData{_TOP_STREAM}=$input_stack[-1];$myData{_INFILE}=$input_top->name();$myData{_INPUT}=$input_top->handle()}else {delete$myData{_TOP_STREAM};delete$myData{_INPUT_STREAMS}}return$input_top}1;
POD_PARSER

$fatpacked{"Pod/PlainText.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_PLAINTEXT';
  package Pod::PlainText;use strict;require 5.005;use Carp qw(carp croak);use Pod::Select ();use vars qw(@ISA %ESCAPES $VERSION);@ISA=qw(Pod::Select);$VERSION='2.07';BEGIN {if ($] < 5.006){require Symbol;import Symbol}}%ESCAPES=('amp'=>'&','lt'=>'<','gt'=>'>','quot'=>'"',"Aacute"=>"\xC1","aacute"=>"\xE1","Acirc"=>"\xC2","acirc"=>"\xE2","AElig"=>"\xC6","aelig"=>"\xE6","Agrave"=>"\xC0","agrave"=>"\xE0","Aring"=>"\xC5","aring"=>"\xE5","Atilde"=>"\xC3","atilde"=>"\xE3","Auml"=>"\xC4","auml"=>"\xE4","Ccedil"=>"\xC7","ccedil"=>"\xE7","Eacute"=>"\xC9","eacute"=>"\xE9","Ecirc"=>"\xCA","ecirc"=>"\xEA","Egrave"=>"\xC8","egrave"=>"\xE8","ETH"=>"\xD0","eth"=>"\xF0","Euml"=>"\xCB","euml"=>"\xEB","Iacute"=>"\xCD","iacute"=>"\xED","Icirc"=>"\xCE","icirc"=>"\xEE","Igrave"=>"\xCD","igrave"=>"\xED","Iuml"=>"\xCF","iuml"=>"\xEF","Ntilde"=>"\xD1","ntilde"=>"\xF1","Oacute"=>"\xD3","oacute"=>"\xF3","Ocirc"=>"\xD4","ocirc"=>"\xF4","Ograve"=>"\xD2","ograve"=>"\xF2","Oslash"=>"\xD8","oslash"=>"\xF8","Otilde"=>"\xD5","otilde"=>"\xF5","Ouml"=>"\xD6","ouml"=>"\xF6","szlig"=>"\xDF","THORN"=>"\xDE","thorn"=>"\xFE","Uacute"=>"\xDA","uacute"=>"\xFA","Ucirc"=>"\xDB","ucirc"=>"\xFB","Ugrave"=>"\xD9","ugrave"=>"\xF9","Uuml"=>"\xDC","uuml"=>"\xFC","Yacute"=>"\xDD","yacute"=>"\xFD","yuml"=>"\xFF","lchevron"=>"\xAB","rchevron"=>"\xBB",);sub initialize {my$self=shift;$$self{alt}=0 unless defined $$self{alt};$$self{indent}=4 unless defined $$self{indent};$$self{loose}=0 unless defined $$self{loose};$$self{sentence}=0 unless defined $$self{sentence};$$self{width}=76 unless defined $$self{width};$$self{INDENTS}=[];$$self{MARGIN}=$$self{indent};return$self->SUPER::initialize}sub command {my$self=shift;my$command=shift;return if$command eq 'pod';return if ($$self{EXCLUDE}&& $command ne 'end');if (defined $$self{ITEM}){$self->item ("\n");local $_="\n";$self->output($_)if($command eq 'back')}$command='cmd_' .$command;return$self->$command (@_)}sub verbatim {my$self=shift;return if $$self{EXCLUDE};$self->item if defined $$self{ITEM};local $_=shift;return if /^\s*$/;s/^(\s*\S+)/(' ' x $$self{MARGIN}) . $1/gme;return$self->output($_)}sub textblock {my$self=shift;return if $$self{EXCLUDE};if($$self{VERBATIM}){$self->output($_[0]);return}local $_=shift;my$line=shift;s{
          (
            L<                    # A link of the form L</something>.
                /
                (
                    [:\w]+        # The item has to be a simple word...
                    (\(\))?       # ...or simple function.
                )
            >
            (
                ,?\s+(and\s+)?    # Allow lots of them, conjuncted.
                L<  
                    /
                    (
                        [:\w]+
                        (\(\))?
                    )
                >
            )+
          )
      } {
          local $_ = $1;
          s%L</([^>]+)>%$1%g;
          my @items = split /(?:,?\s+(?:and\s+)?)/;
          my $string = "the ";
          my $i;
          for ($i = 0; $i < @items; $i++) {
              $string .= $items[$i];
              $string .= ", " if @items > 2 && $i != $#items;
              $string .= " and " if ($i == $#items - 1);
          }
          $string .= " entries elsewhere in this document";
          $string;
      }gex;$_=$self->interpolate ($_,$line);s/\s*$/\n/s;if (defined $$self{ITEM}){$self->item ($_ ."\n")}else {$self->output ($self->reformat ($_ ."\n"))}}sub interior_sequence {my$self=shift;my$command=shift;local $_=shift;return '' if ($command eq 'X' || $command eq 'Z');if ($command eq 'E'){return$ESCAPES{$_}if defined$ESCAPES{$_};carp "Unknown escape: E<$_>";return "E<$_>"}return if $_ eq '';if ($command eq 'S'){s/\s{2,}/ /g;tr/ /\01/;return $_}if ($command eq 'B'){return$self->seq_b ($_)}elsif ($command eq 'C'){return$self->seq_c ($_)}elsif ($command eq 'F'){return$self->seq_f ($_)}elsif ($command eq 'I'){return$self->seq_i ($_)}elsif ($command eq 'L'){return$self->seq_l ($_)}else {carp "Unknown sequence $command<$_>"}}sub preprocess_paragraph {my$self=shift;local $_=shift;1 while s/^(.*?)(\t+)/$1 . ' ' x (length ($2) * 8 - length ($1) % 8)/me;return $_}sub cmd_head1 {my$self=shift;local $_=shift;s/\s+$//s;$_=$self->interpolate ($_,shift);if ($$self{alt}){$self->output ("\n==== $_ ====\n\n")}else {$_ .= "\n" if $$self{loose};$self->output ($_ ."\n")}}sub cmd_head2 {my$self=shift;local $_=shift;s/\s+$//s;$_=$self->interpolate ($_,shift);if ($$self{alt}){$self->output ("\n==   $_   ==\n\n")}else {$_ .= "\n" if $$self{loose};$self->output (' ' x ($$self{indent}/ 2).$_ ."\n")}}sub cmd_head3 {my$self=shift;local $_=shift;s/\s+$//s;$_=$self->interpolate ($_,shift);if ($$self{alt}){$self->output ("\n= $_ =\n")}else {$_ .= "\n" if $$self{loose};$self->output (' ' x ($$self{indent}).$_ ."\n")}}*cmd_head4=\&cmd_head3;sub cmd_over {my$self=shift;local $_=shift;unless (/^[-+]?\d+\s+$/){$_=$$self{indent}}push (@{$$self{INDENTS}},$$self{MARGIN});$$self{MARGIN}+= ($_ + 0)}sub cmd_back {my$self=shift;$$self{MARGIN}=pop @{$$self{INDENTS}};unless (defined $$self{MARGIN}){carp 'Unmatched =back';$$self{MARGIN}=$$self{indent}}}sub cmd_item {my$self=shift;if (defined $$self{ITEM}){$self->item}local $_=shift;s/\s+$//s;$$self{ITEM}=$self->interpolate ($_)}sub cmd_begin {my$self=shift;local $_=shift;my ($kind)=/^(\S+)/ or return;if ($kind eq 'text'){$$self{VERBATIM}=1}else {$$self{EXCLUDE}=1}}sub cmd_end {my$self=shift;$$self{EXCLUDE}=0;$$self{VERBATIM}=0}sub cmd_for {my$self=shift;local $_=shift;my$line=shift;return unless s/^text\b[ \t]*\r?\n?//;$self->verbatim ($_,$line)}sub cmd_encoding {return}sub seq_b {return $_[0]{alt}? "``$_[1]''" : $_[1]}sub seq_c {return $_[0]{alt}? "``$_[1]''" : "`$_[1]'"}sub seq_f {return $_[0]{alt}? "\"$_[1]\"" : $_[1]}sub seq_i {return '*' .$_[1].'*'}sub seq_l {my$self=shift;local $_=shift;s/\s+/ /g;if (/^([^|]+)\|/){return $1}s/^\s+//;s/\s+$//;my ($manpage,$section)=('',$_);if (/^(?:https?|ftp|news):/){return $_}elsif (/^"\s*(.*?)\s*"$/){$section='"' .$1 .'"'}elsif (m/^[-:.\w]+(?:\(\S+\))?$/){($manpage,$section)=($_,'')}elsif (m{/}){($manpage,$section)=split (/\s*\/\s*/,$_,2)}my$text='';if (!length$section){$text="the $manpage manpage" if length$manpage}elsif ($section =~ /^[:\w]+(?:\(\))?/){$text .= 'the ' .$section .' entry';$text .= (length$manpage)? " in the $manpage manpage" : ' elsewhere in this document'}else {$section =~ s/^\"\s*//;$section =~ s/\s*\"$//;$text .= 'the section on "' .$section .'"';$text .= " in the $manpage manpage" if length$manpage}return$text}sub item {my$self=shift;local $_=shift;my$tag=$$self{ITEM};unless (defined$tag){carp 'item called without tag';return}undef $$self{ITEM};my$indent=$$self{INDENTS}[-1];unless (defined$indent){$indent=$$self{indent}}my$space=' ' x $indent;$space =~ s/^ /:/ if $$self{alt};if (!$_ || /^\s+$/ || ($$self{MARGIN}- $indent < length ($tag)+ 1)){my$margin=$$self{MARGIN};$$self{MARGIN}=$indent;my$output=$self->reformat ($tag);$output =~ s/[\r\n]*$/\n/;$self->output ($output);$$self{MARGIN}=$margin;$self->output ($self->reformat ($_))if /\S/}else {$_=$self->reformat ($_);s/^ /:/ if ($$self{alt}&& $indent > 0);my$tagspace=' ' x length$tag;s/^($space)$tagspace/$1$tag/ or carp 'Bizarre space in item';$self->output ($_)}}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{width}- $$self{MARGIN};while (length > $width){if (s/^([^\r\n]{0,$width})\s+// || s/^([^\r\n]{$width})//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}sub reformat {my$self=shift;local $_=shift;if ($$self{sentence}){s/ +$//mg;s/\.\r?\n/. \n/g;s/[\r\n]+/ /g;s/   +/  /g}else {s/\s+/ /g}return$self->wrap($_)}sub output {$_[1]=~ tr/\01/ /;print {$_[0]->output_handle}$_[1]}sub pod2text {my@args;while ($_[0]=~ /^-/){my$flag=shift;if ($flag eq '-a'){push (@args,alt=>1)}elsif ($flag =~ /^-(\d+)$/){push (@args,width=>$1)}else {unshift (@_,$flag);last}}my$parser=Pod::PlainText->new (@args);if (defined $_[1]){my$infh;if ($] < 5.006){$infh=gensym()}unless (open ($infh,$_[0])){croak ("Can't open $_[0] for reading: $!\n")}$_[0]=$infh;return$parser->parse_from_filehandle (@_)}else {return$parser->parse_from_file (@_)}}1;
POD_PLAINTEXT

$fatpacked{"Pod/Select.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_SELECT';
  package Pod::Select;use strict;use vars qw($VERSION @ISA @EXPORT $MAX_HEADING_LEVEL %myData @section_headings @selected_sections);$VERSION='1.63';require 5.005;use Carp;use Pod::Parser 1.04;@ISA=qw(Pod::Parser);@EXPORT=qw(&podselect);*MAX_HEADING_LEVEL=\3;sub _init_headings {my$self=shift;local*myData=$self;unless (defined$myData{_SECTION_HEADINGS}){local*section_headings=$myData{_SECTION_HEADINGS}=[];for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$section_headings[$i]=''}}}sub curr_headings {my$self=shift;$self->_init_headings()unless (defined$self->{_SECTION_HEADINGS});my@headings=@{$self->{_SECTION_HEADINGS}};return (@_ > 0 and $_[0]=~ /^\d+$/)? $headings[$_[0]- 1]: @headings}sub select {my ($self,@sections)=@_;local*myData=$self;local $_;my$add=($sections[0]eq '+')? shift(@sections): '';unless (@sections){delete$myData{_SELECTED_SECTIONS}unless ($add);return}$myData{_SELECTED_SECTIONS}=[]unless ($add && exists$myData{_SELECTED_SECTIONS});local*selected_sections=$myData{_SELECTED_SECTIONS};for my$spec (@sections){if (defined($_=_compile_section_spec($spec))){push(@selected_sections,$_)}else {carp qq{Ignoring section spec "$spec"!\n}}}}sub add_selection {my$self=shift;return$self->select('+',@_)}sub clear_selections {my$self=shift;return$self->select()}sub match_section {my$self=shift;my (@headings)=@_;local*myData=$self;my$selections=(exists$myData{_SELECTED_SECTIONS})? $myData{_SELECTED_SECTIONS}: undef;return 1 unless ((defined$selections)&& @{$selections});my@current_headings=$self->curr_headings();for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){(defined$headings[$i])or $headings[$i]=$current_headings[$i]}for my$section_spec (@{$selections}){my$match=1;for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){my$regex=$section_spec->[$i];my$negated=($regex =~ s/^\!//);$match &= ($negated ? ($headings[$i]!~ /${regex}/): ($headings[$i]=~ /${regex}/));last unless ($match)}return 1 if ($match)}return 0}sub is_selected {my ($self,$paragraph)=@_;local $_;local*myData=$self;$self->_init_headings()unless (defined$myData{_SECTION_HEADINGS});$_=$paragraph;if (/^=((?:sub)*)(?:head(?:ing)?|sec(?:tion)?)(\d*)\s+(.*?)\s*$/){my ($level,$heading)=($2,$3);$level=1 + (length($1)/ 3)if ((!length$level)|| (length $1));$myData{_SECTION_HEADINGS}->[$level - 1]=$heading;for (my$i=$level;$i < $MAX_HEADING_LEVEL;++$i){$myData{_SECTION_HEADINGS}->[$i]=''}}return$self->match_section()}sub podselect {my(@argv)=@_;my%defaults=();my$pod_parser=new Pod::Select(%defaults);my$num_inputs=0;my$output='>&STDOUT';my%opts;local $_;for (@argv){my$ref=ref($_);if ($ref && $ref eq 'HASH'){%opts=(%defaults,%{$_});%opts=map {my ($key,$val)=(lc $_,$opts{$_});$key =~ s/^(?=\w)/-/;$key =~ /^-se[cl]/ and $key='-sections';($key=>$val)}(keys%opts);(exists$opts{'-output'})and $output=$opts{'-output'};$pod_parser->select(@{$opts{'-sections'}})if ((defined$opts{'-sections'})&& ((ref$opts{'-sections'})eq 'ARRAY'))}elsif(!$ref || $ref eq 'GLOB'){$pod_parser->parse_from_file($_,$output);++$num_inputs}else {croak "Input from $ref reference not supported!\n"}}$pod_parser->parse_from_file('-')unless ($num_inputs > 0)}sub _compile_section_spec {my ($section_spec)=@_;my (@regexs,$negated);local $_=$section_spec;s{\\\\}{\001}g;s{\\/}{\002}g;@regexs=split(/\//,$_,$MAX_HEADING_LEVEL);for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$regexs[$i]='.*' unless ((defined$regexs[$i])&& (length$regexs[$i]))}my$bad_regexs=0;for (@regexs){$_ .= '.+' if ($_ eq '!');s{\001}{\\\\}g;s{\002}{\\/}g;$negated=s/^\!//;eval "m{$_}";if ($@){++$bad_regexs;carp qq{Bad regular expression /$_/ in "$section_spec": $@\n}}else {$_='^' .$_ unless (/^\^/);$_=$_ .'$' unless (/\$$/);$_='!' .$_ if ($negated)}}return (!$bad_regexs)? [@regexs ]: undef}1;
POD_SELECT

$fatpacked{"Pod/Text.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT';
  package Pod::Text;use 5.006;use strict;use warnings;use vars qw(@ISA @EXPORT %ESCAPES $VERSION);use Carp qw(carp croak);use Encode qw(encode);use Exporter ();use Pod::Simple ();@ISA=qw(Pod::Simple Exporter);@EXPORT=qw(pod2text);$VERSION='4.07';sub handle_code {my ($line,$number,$parser)=@_;$parser->output_code ($line ."\n")}sub new {my$class=shift;my$self=$class->SUPER::new;$self->nbsp_for_S (1);if ($self->can ('preserve_whitespace')){$self->preserve_whitespace (1)}else {$self->fullstop_space_harden (1)}$self->accept_targets (qw/text TEXT/);$self->merge_text (1);my%opts=@_;my@opts=map {("opt_$_",$opts{$_})}keys%opts;%$self=(%$self,@opts);if ($$self{opt_stderr}and not $$self{opt_errors}){$$self{opt_errors}='stderr'}delete $$self{opt_stderr};if (not defined $$self{opt_errors}){$$self{opt_errors}='pod'}if ($$self{opt_errors}eq 'stderr' || $$self{opt_errors}eq 'die'){$self->no_errata_section (1);$self->complain_stderr (1);if ($$self{opt_errors}eq 'die'){$$self{complain_die}=1}}elsif ($$self{opt_errors}eq 'pod'){$self->no_errata_section (0);$self->complain_stderr (0)}elsif ($$self{opt_errors}eq 'none'){$self->no_whining (1)}else {croak (qq(Invalid errors setting: "$$self{errors}"))}delete $$self{errors};$$self{opt_alt}=0 unless defined $$self{opt_alt};$$self{opt_indent}=4 unless defined $$self{opt_indent};$$self{opt_margin}=0 unless defined $$self{opt_margin};$$self{opt_loose}=0 unless defined $$self{opt_loose};$$self{opt_sentence}=0 unless defined $$self{opt_sentence};$$self{opt_width}=76 unless defined $$self{opt_width};$$self{opt_quotes}||= '"';if ($$self{opt_quotes}eq 'none'){$$self{LQUOTE}=$$self{RQUOTE}=''}elsif (length ($$self{opt_quotes})==1){$$self{LQUOTE}=$$self{RQUOTE}=$$self{opt_quotes}}elsif (length ($$self{opt_quotes})% 2==0){my$length=length ($$self{opt_quotes})/ 2;$$self{LQUOTE}=substr ($$self{opt_quotes},0,$length);$$self{RQUOTE}=substr ($$self{opt_quotes},$length)}else {croak qq(Invalid quote specification "$$self{opt_quotes}")}$self->code_handler (\&handle_code)if $$self{opt_code};return$self}sub _handle_text {my ($self,$text)=@_;my$tag=$$self{PENDING}[-1];$$tag[1].= $text}sub method_for_element {my ($self,$element)=@_;$element =~ tr/-/_/;$element =~ tr/A-Z/a-z/;$element =~ tr/_a-z0-9//cd;return$element}sub _handle_element_start {my ($self,$element,$attrs)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){push (@{$$self{PENDING}},[$attrs,'' ])}elsif ($self->can ("start_$method")){my$method='start_' .$method;$self->$method ($attrs,'')}}sub _handle_element_end {my ($self,$element)=@_;my$method=$self->method_for_element ($element);if ($self->can ("cmd_$method")){my$tag=pop @{$$self{PENDING}};my$method='cmd_' .$method;my$text=$self->$method (@$tag);if (defined$text){if (@{$$self{PENDING}}> 1){$$self{PENDING}[-1][1].= $text}else {$self->output ($text)}}}elsif ($self->can ("end_$method")){my$method='end_' .$method;$self->$method ()}}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){if (s/^([^\n]{0,$width})\s+// || s/^([^\n]{$width})//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}sub reformat {my$self=shift;local $_=shift;if ($$self{opt_sentence}){s/ +$//mg;s/\.\n/. \n/g;s/\n/ /g;s/   +/  /g}else {s/\s+/ /g}return$self->wrap ($_)}sub output {my ($self,@text)=@_;my$text=join ('',@text);$text =~ tr/\240\255/ /d;unless ($$self{opt_utf8}){my$encoding=$$self{encoding}|| '';if ($encoding && $encoding ne $$self{ENCODING}){$$self{ENCODING}=$encoding;eval {binmode ($$self{output_fh},":encoding($encoding)")}}}if ($$self{ENCODE}){print {$$self{output_fh}}encode ('UTF-8',$text)}else {print {$$self{output_fh}}$text}}sub output_code {$_[0]->output ($_[1])}sub start_document {my ($self,$attrs)=@_;if ($$attrs{contentless}&&!$$self{ALWAYS_EMIT_SOMETHING}){$$self{CONTENTLESS}=1}else {delete $$self{CONTENTLESS}}my$margin=$$self{opt_indent}+ $$self{opt_margin};$$self{INDENTS}=[];$$self{MARGIN}=$margin;$$self{PENDING}=[[]];$$self{ENCODING}='';$$self{ENCODE}=0;if ($$self{opt_utf8}){$$self{ENCODE}=1;eval {my@options=(output=>1,details=>1);my$flag=(PerlIO::get_layers ($$self{output_fh},@options))[-1];if ($flag & PerlIO::F_UTF8 ()){$$self{ENCODE}=0;$$self{ENCODING}='UTF-8'}}}return ''}sub end_document {my ($self)=@_;if ($$self{complain_die}&& $self->errors_seen){croak ("POD document had syntax errors")}}sub strip_format {my ($self,$string)=@_;return$string}sub item {my ($self,$text)=@_;my$tag=$$self{ITEM};unless (defined$tag){carp "Item called without tag";return}undef $$self{ITEM};my$indent=$$self{INDENTS}[-1];$indent=$$self{opt_indent}unless defined$indent;my$margin=' ' x $$self{opt_margin};my$tag_length=length ($self->strip_format ($tag));my$fits=($$self{MARGIN}- $indent >= $tag_length + 1);if (!$text || $text =~ /^\s+$/ ||!$fits){my$realindent=$$self{MARGIN};$$self{MARGIN}=$indent;my$output=$self->reformat ($tag);$output =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);$output =~ s/\n*$/\n/;$output .= "\n" if$text && $text =~ /^\s*$/;$self->output ($output);$$self{MARGIN}=$realindent;$self->output ($self->reformat ($text))if ($text && $text =~ /\S/)}else {my$space=' ' x $indent;$space =~ s/^$margin /$margin:/ if $$self{opt_alt};$text=$self->reformat ($text);$text =~ s/^$margin /$margin:/ if ($$self{opt_alt}&& $indent > 0);my$tagspace=' ' x $tag_length;$text =~ s/^($space)$tagspace/$1$tag/ or warn "Bizarre space in item";$self->output ($text)}}sub cmd_para {my ($self,$attrs,$text)=@_;$text =~ s/\s+$/\n/;if (defined $$self{ITEM}){$self->item ($text ."\n")}else {$self->output ($self->reformat ($text ."\n"))}return ''}sub cmd_verbatim {my ($self,$attrs,$text)=@_;$self->item if defined $$self{ITEM};return if$text =~ /^\s*$/;$text =~ s/^(\n*)([ \t]*\S+)/$1 . (' ' x $$self{MARGIN}) . $2/gme;$text =~ s/\s*$/\n\n/;$self->output ($text);return ''}sub cmd_data {my ($self,$attrs,$text)=@_;$text =~ s/^\n+//;$text =~ s/\n{0,2}$/\n/;$self->output ($text);return ''}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text =~ s/\s+$//;if ($$self{opt_alt}){my$closemark=reverse (split (//,$marker));my$margin=' ' x $$self{opt_margin};$self->output ("\n" ."$margin$marker $text $closemark" ."\n\n")}else {$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n")}return ''}sub cmd_head1 {my ($self,$attrs,$text)=@_;$self->heading ($text,0,'====')}sub cmd_head2 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}/ 2,'==  ')}sub cmd_head3 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 2 / 3 + 0.5,'=   ')}sub cmd_head4 {my ($self,$attrs,$text)=@_;$self->heading ($text,$$self{opt_indent}* 3 / 4 + 0.5,'-   ')}sub over_common_start {my ($self,$attrs)=@_;$self->item ("\n\n")if defined $$self{ITEM};my$indent=$$attrs{indent};unless (defined ($indent)&& $indent =~ /^\s*[-+]?\d{1,4}\s*$/){$indent=$$self{opt_indent}}push (@{$$self{INDENTS}},$$self{MARGIN});$$self{MARGIN}+= ($indent + 0);return ''}sub over_common_end {my ($self)=@_;$self->item ("\n\n")if defined $$self{ITEM};$$self{MARGIN}=pop @{$$self{INDENTS}};return ''}sub start_over_bullet {$_[0]->over_common_start ($_[1])}sub start_over_number {$_[0]->over_common_start ($_[1])}sub start_over_text {$_[0]->over_common_start ($_[1])}sub start_over_block {$_[0]->over_common_start ($_[1])}sub end_over_bullet {$_[0]->over_common_end}sub end_over_number {$_[0]->over_common_end}sub end_over_text {$_[0]->over_common_end}sub end_over_block {$_[0]->over_common_end}sub item_common {my ($self,$type,$attrs,$text)=@_;$self->item if defined $$self{ITEM};$text =~ s/\s+$//;my ($item,$index);if ($type eq 'bullet'){$item='*'}elsif ($type eq 'number'){$item=$$attrs{'~orig_content'}}else {$item=$text;$item =~ s/\s*\n\s*/ /g;$text=''}$$self{ITEM}=$item;if ($text){$text =~ s/\s*$/\n/;$self->item ($text)}return ''}sub cmd_item_bullet {my$self=shift;$self->item_common ('bullet',@_)}sub cmd_item_number {my$self=shift;$self->item_common ('number',@_)}sub cmd_item_text {my$self=shift;$self->item_common ('text',@_)}sub cmd_item_block {my$self=shift;$self->item_common ('block',@_)}sub cmd_b {return $_[0]{alt}? "``$_[2]''" : $_[2]}sub cmd_f {return $_[0]{alt}? "\"$_[2]\"" : $_[2]}sub cmd_i {return '*' .$_[2].'*'}sub cmd_x {return ''}sub cmd_c {my ($self,$attrs,$text)=@_;my$index='(?: \[.*\] | \{.*\} )?';$text =~ m{
        ^\s*
        (?:
           ( [\'\`\"] ) .* \1                             # already quoted
         | \` .* \'                                       # `quoted'
         | \$+ [\#^]? \S $index                           # special ($^Foo, $")
         | [\$\@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
         | [\$\@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
         | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
         | 0x [a-fA-F\d]+                                 # a hex constant
        )
        \s*\z
       }xo && return$text;return $$self{opt_alt}? "``$text''" : "$$self{LQUOTE}$text$$self{RQUOTE}"}sub cmd_l {my ($self,$attrs,$text)=@_;if ($$attrs{type}eq 'url'){if (not defined($$attrs{to})or $$attrs{to}eq $text){return "<$text>"}elsif ($$self{opt_nourls}){return$text}else {return "$text <$$attrs{to}>"}}else {return$text}}sub pod2text {my@args;while ($_[0]=~ /^-/){my$flag=shift;if ($flag eq '-a'){push (@args,alt=>1)}elsif ($flag =~ /^-(\d+)$/){push (@args,width=>$1)}else {unshift (@_,$flag);last}}my$parser=Pod::Text->new (@args);if (defined $_[1]){my@fhs=@_;local*IN;unless (open (IN,$fhs[0])){croak ("Can't open $fhs[0] for reading: $!\n");return}$fhs[0]=\*IN;$parser->output_fh ($fhs[1]);my$retval=$parser->parse_file ($fhs[0]);my$fh=$parser->output_fh ();close$fh;return$retval}else {$parser->output_fh (\*STDOUT);return$parser->parse_file (@_)}}sub parse_from_file {my$self=shift;$self->reinit;if (ref ($_[0])eq 'HASH'){my$opts=shift @_;if (defined ($$opts{-cutting})&&!$$opts{-cutting}){$$self{in_pod}=1;$$self{last_was_blank}=1}}my$retval=$self->Pod::Simple::parse_from_file (@_);my$fh=$self->output_fh ();my$oldfh=select$fh;my$oldflush=$|;$|=1;print$fh '';$|=$oldflush;select$oldfh;return$retval}sub parse_from_filehandle {my$self=shift;$self->parse_from_file (@_)}sub parse_file {my ($self,$in)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_file ($in)}sub parse_lines {my ($self,@lines)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_lines (@lines)}sub parse_string_document {my ($self,$doc)=@_;unless (defined $$self{output_fh}){$self->output_fh (\*STDOUT)}return$self->SUPER::parse_string_document ($doc)}1;
POD_TEXT

$fatpacked{"Pod/Text/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_COLOR';
  package Pod::Text::Color;use 5.006;use strict;use warnings;use Pod::Text ();use Term::ANSIColor qw(colored);use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='4.07';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head1 ($attrs,colored ($text,'bold'))}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,colored ($text,'bold'))}sub cmd_b {return colored ($_[2],'bold')}sub cmd_f {return colored ($_[2],'cyan')}sub cmd_i {return colored ($_[2],'yellow')}sub output_code {my ($self,$code)=@_;$code=colored ($code,'green');$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/\e\[[\d;]*m//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$char='(?:(?:\e\[[\d;]+m)*[^\n])';my$shortchar=$char ."{0,$width}";my$longchar=$char ."{$width}";while (length > $width){if (s/^($shortchar)\s+// || s/^($longchar)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;$output}1;
POD_TEXT_COLOR

$fatpacked{"Pod/Text/Overstrike.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_OVERSTRIKE';
  package Pod::Text::Overstrike;use 5.006;use strict;use warnings;use vars qw(@ISA $VERSION);use Pod::Text ();@ISA=qw(Pod::Text);$VERSION='4.07';sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head1 ($attrs,$text)}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/$1\b$1/g;return$self->SUPER::cmd_head2 ($attrs,$text)}sub cmd_head3 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head3 ($attrs,$text)}sub cmd_head4 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$text=$self->strip_format ($text);$text =~ s/(.)/_\b$1/g;return$self->SUPER::cmd_head4 ($attrs,$text)}sub heading {my ($self,$text,$indent,$marker)=@_;$self->item ("\n\n")if defined $$self{ITEM};$text .= "\n" if $$self{opt_loose};my$margin=' ' x ($$self{opt_margin}+ $indent);$self->output ($margin .$text ."\n");return ''}sub cmd_b {local $_=$_[0]->strip_format ($_[2]);s/(.)/$1\b$1/g;$_}sub cmd_f {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub cmd_i {local $_=$_[0]->strip_format ($_[2]);s/(.)/_\b$1/g;$_}sub output_code {my ($self,$code)=@_;$code =~ s/(.)/$1\b$1/g;$self->output ($code)}sub strip_format {my ($self,$text)=@_;$text =~ s/(.)[\b]\1/$1/g;$text =~ s/_[\b]//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};while (length > $width){my$char='(?:[^\n][\b])?[^\n]';if (s/^((?>$char){0,$width})(?:\Z|\s+)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_OVERSTRIKE

$fatpacked{"Pod/Text/Termcap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_TEXT_TERMCAP';
  package Pod::Text::Termcap;use 5.006;use strict;use warnings;use Pod::Text ();use POSIX ();use Term::Cap;use vars qw(@ISA $VERSION);@ISA=qw(Pod::Text);$VERSION='4.07';sub new {my ($self,@args)=@_;my ($ospeed,$term,$termios);$self=$self->SUPER::new (@args);unless (exists$ENV{TERMPATH}){my$home=exists$ENV{HOME}? "$ENV{HOME}/.termcap:" : '';$ENV{TERMPATH}="${home}/etc/termcap:/usr/share/misc/termcap:/usr/share/lib/termcap"}eval {$termios=POSIX::Termios->new};if ($@){$ospeed=9600}else {$termios->getattr;$ospeed=$termios->getospeed || 9600}eval {$term=Tgetent Term::Cap {TERM=>undef,OSPEED=>$ospeed}};$$self{BOLD}=$$term{_md}|| "\e[1m";$$self{UNDL}=$$term{_us}|| "\e[4m";$$self{NORM}=$$term{_me}|| "\e[m";unless (defined $$self{width}){$$self{opt_width}=$ENV{COLUMNS}|| $$term{_co}|| 80;$$self{opt_width}-= 2}return$self}sub cmd_head1 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head1 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_head2 {my ($self,$attrs,$text)=@_;$text =~ s/\s+$//;$self->SUPER::cmd_head2 ($attrs,"$$self{BOLD}$text$$self{NORM}")}sub cmd_b {my$self=shift;return "$$self{BOLD}$_[1]$$self{NORM}"}sub cmd_i {my$self=shift;return "$$self{UNDL}$_[1]$$self{NORM}"}sub output_code {my ($self,$code)=@_;$self->output ($$self{BOLD}.$code .$$self{NORM})}sub strip_format {my ($self,$text)=@_;$text =~ s/\Q$$self{BOLD}//g;$text =~ s/\Q$$self{UNDL}//g;$text =~ s/\Q$$self{NORM}//g;return$text}sub wrap {my$self=shift;local $_=shift;my$output='';my$spaces=' ' x $$self{MARGIN};my$width=$$self{opt_width}- $$self{MARGIN};my$codes="(?:\Q$$self{BOLD}\E|\Q$$self{UNDL}\E|\Q$$self{NORM}\E)";my$char="(?:$codes*[^\\n])";my$shortchar=$char ."{0,$width}";my$longchar=$char ."{$width}";while (length > $width){if (s/^($shortchar)\s+// || s/^($longchar)//){$output .= $spaces .$1 ."\n"}else {last}}$output .= $spaces .$_;$output =~ s/\s+$/\n\n/;return$output}1;
POD_TEXT_TERMCAP

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  package Pod::Usage;use strict;use vars qw($VERSION @ISA @EXPORT);$VERSION='1.68';require 5.006;use Carp;use Config;use Exporter;use File::Spec;@EXPORT=qw(&pod2usage);BEGIN {$Pod::Usage::Formatter ||= 'Pod::Text';eval "require $Pod::Usage::Formatter";die $@ if $@;@ISA=($Pod::Usage::Formatter)}our$MAX_HEADING_LEVEL=3;sub pod2usage {local($_)=shift;my%opts;if (@_ > 0){%opts=($_,@_)}elsif (!defined $_){$_=''}elsif (ref $_){%opts=%{$_}if (ref($_)eq 'HASH')}elsif (/^[-+]?\d+$/){$opts{'-exitval'}=$_}else {$_ and $opts{'-message'}=$_}%opts=map {my ($key,$val)=($_,$opts{$_});$key =~ s/^(?=\w)/-/;$key =~ /^-msg/i and $key='-message';$key =~ /^-exit/i and $key='-exitval';lc($key)=>$val}(keys%opts);if ((!defined$opts{'-exitval'})&& (!defined$opts{'-verbose'})){$opts{'-exitval'}=2;$opts{'-verbose'}=0}elsif (!defined$opts{'-exitval'}){$opts{'-exitval'}=($opts{'-verbose'}> 0)? 1 : 2}elsif (!defined$opts{'-verbose'}){$opts{'-verbose'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)}$opts{'-output'}=(lc($opts{'-exitval'})eq 'noexit' || $opts{'-exitval'}< 2)? \*STDOUT : \*STDERR unless (defined$opts{'-output'});$opts{'-input'}=$0 unless (defined$opts{'-input'});unless ((ref$opts{'-input'})|| (-e $opts{'-input'})){my$basename=$opts{'-input'};my$pathsep=($^O =~ /^(?:dos|os2|MSWin32)$/i)? ';' : (($^O eq 'MacOS' || $^O eq 'VMS')? ',' : ':');my$pathspec=$opts{'-pathlist'}|| $ENV{PATH}|| $ENV{PERL5LIB};my@paths=(ref$pathspec)? @$pathspec : split($pathsep,$pathspec);for my$dirname (@paths){$_=File::Spec->catfile($dirname,$basename)if length;last if (-e $_)&& ($opts{'-input'}=$_)}}my$parser=new Pod::Usage(USAGE_OPTIONS=>\%opts);if ($opts{'-verbose'}==0){$parser->select('(?:SYNOPSIS|USAGE)\s*')}elsif ($opts{'-verbose'}==1){my$opt_re='(?i)' .'(?:OPTIONS|ARGUMENTS)' .'(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';$parser->select('(?:SYNOPSIS|USAGE)\s*',$opt_re,"DESCRIPTION/$opt_re")}elsif ($opts{'-verbose'}>= 2 && $opts{'-verbose'}!=99){$parser->select('.*')}elsif ($opts{'-verbose'}==99){my$sections=$opts{'-sections'};$parser->select((ref$sections)? @$sections : $sections);$opts{'-verbose'}=1}my$progpath=$opts{'-perldoc'}? $opts{'-perldoc'}: File::Spec->catfile($Config{scriptdirexp}|| $Config{scriptdir},'perldoc');my$version=sprintf("%vd",$^V);if ($Config{versiononly}and $Config{startperl}=~ /\Q$version\E$/){$progpath .= $version}$opts{'-noperldoc'}=1 unless -e $progpath;if (!$opts{'-noperldoc'}and $opts{'-verbose'}>= 2 and!ref($opts{'-input'})and $opts{'-output'}==\*STDOUT){print {$opts{'-output'}}($opts{'-message'},"\n")if($opts{'-message'});if(defined$opts{-input}&& $opts{-input}=~ /^\s*(\S.*?)\s*$/){my$f=$1;my@perldoc_cmd=($progpath);if ($opts{'-perldocopt'}){$opts{'-perldocopt'}=~ s/^\s+|\s+$//g;push@perldoc_cmd,split(/\s+/,$opts{'-perldocopt'})}push@perldoc_cmd,('-F',$f);unshift@perldoc_cmd,$opts{'-perlcmd'}if$opts{'-perlcmd'};system(@perldoc_cmd);if($?){system(($Config{pager}|| $ENV{PAGER}|| '/bin/more'),$1)}}else {croak "Unspecified input file or insecure argument.\n"}}else {$parser->parse_from_file($opts{'-input'},$opts{'-output'})}exit($opts{'-exitval'})unless (lc($opts{'-exitval'})eq 'noexit')}sub new {my$this=shift;my$class=ref($this)|| $this;my%params=@_;my$self={%params};bless$self,$class;if ($self->can('initialize')){$self->initialize()}else {my%opts;for (qw(alt code indent loose margin quotes sentence stderr utf8 width)){my$val=$params{USAGE_OPTIONS}{"-$_"};$opts{$_}=$val if defined$val}$self=$self->SUPER::new(%opts);%$self=(%$self,%params)}return$self}sub _compile_section_spec {my ($section_spec)=@_;my (@regexs,$negated);local $_=$section_spec;s{\\\\}{\001}g;s{\\/}{\002}g;@regexs=split(/\//,$_,$MAX_HEADING_LEVEL);for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$regexs[$i]='.*' unless ((defined$regexs[$i])&& (length$regexs[$i]))}my$bad_regexs=0;for (@regexs){$_ .= '.+' if ($_ eq '!');s{\001}{\\\\}g;s{\002}{\\/}g;$negated=s/^\!//;eval "m{$_}";if ($@){++$bad_regexs;carp qq{Bad regular expression /$_/ in "$section_spec": $@\n}}else {$_='^' .$_ unless (/^\^/);$_=$_ .'$' unless (/\$$/);$_='!' .$_ if ($negated)}}return (!$bad_regexs)? [@regexs ]: undef}sub select {my ($self,@sections)=@_;if ($ISA[0]->can('select')){$self->SUPER::select(@sections)}else {my$add=($sections[0]eq '+')? shift(@sections): '';unless (@sections){delete$self->{USAGE_SELECT}unless ($add);return}$self->{USAGE_SELECT}=[]unless ($add && $self->{USAGE_SELECT});my$sref=$self->{USAGE_SELECT};for my$spec (@sections){my$cs=_compile_section_spec($spec);if (defined$cs){push(@$sref,$cs)}else {carp qq{Ignoring section spec "$spec"!\n}}}}}sub seq_i {return $_[1]}sub cmd_i {return $_[2]}sub _handle_element_end {my ($self,$element)=@_;if ($element eq 'head1'){$self->{USAGE_HEADINGS}=[$$self{PENDING}[-1][1]];if ($self->{USAGE_OPTIONS}->{-verbose}< 2){$$self{PENDING}[-1][1]=~ s/^\s*SYNOPSIS\s*$/USAGE/}}elsif ($element =~ /^head(\d+)$/ && $1){my$idx=$1 - 1;$self->{USAGE_HEADINGS}=[]unless($self->{USAGE_HEADINGS});$self->{USAGE_HEADINGS}->[$idx]=$$self{PENDING}[-1][1];splice(@{$self->{USAGE_HEADINGS}},$idx+1)}if ($element =~ /^head\d+$/){$$self{USAGE_SKIPPING}=1;if (!$$self{USAGE_SELECT}||!@{$$self{USAGE_SELECT}}){$$self{USAGE_SKIPPING}=0}else {my@headings=@{$$self{USAGE_HEADINGS}};for my$section_spec (@{$$self{USAGE_SELECT}}){my$match=1;for (my$i=0;$i < $MAX_HEADING_LEVEL;++$i){$headings[$i]='' unless defined$headings[$i];my$regex=$section_spec->[$i];my$negated=($regex =~ s/^\!//);$match &= ($negated ? ($headings[$i]!~ /${regex}/): ($headings[$i]=~ /${regex}/));last unless ($match)}if ($match){$$self{USAGE_SKIPPING}=0;last}}}if($self->{USAGE_OPTIONS}->{-verbose}< 2){local $_=$$self{PENDING}[-1][1];s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n";$$self{PENDING}[-1][1]=$_}}if ($$self{USAGE_SKIPPING}&& $element !~ m/^over-|^[BCFILSZ]$/){pop @{$$self{PENDING}}}else {$self->SUPER::_handle_element_end($element)}}sub start_document {my$self=shift;$self->SUPER::start_document();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_fh();print$out_fh "$msg\n"}sub begin_pod {my$self=shift;$self->SUPER::begin_pod();my$msg=$self->{USAGE_OPTIONS}->{-message}or return 1;my$out_fh=$self->output_handle();print$out_fh "$msg\n"}sub preprocess_paragraph {my$self=shift;local $_=shift;my$line=shift;if (($self->{USAGE_OPTIONS}->{-verbose}< 2)&& /^=head/){s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;s/\s*$/:/ unless (/:\s*$/);$_ .= "\n"}return$self->SUPER::preprocess_paragraph($_)}1;
POD_USAGE

$fatpacked{"TAP/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_BASE';
  package TAP::Base;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.36';use constant GOT_TIME_HIRES=>do {eval 'use Time::HiRes qw(time);';$@ ? 0 : 1};sub _initialize {my ($self,$arg_for,$ok_callback)=@_;my%ok_map=map {$_=>1}@$ok_callback;$self->{ok_callbacks}=\%ok_map;if (my$cb=delete$arg_for->{callbacks}){while (my ($event,$callback)=each %$cb){$self->callback($event,$callback)}}return$self}sub callback {my ($self,$event,$callback)=@_;my%ok_map=%{$self->{ok_callbacks}};$self->_croak('No callbacks may be installed')unless%ok_map;$self->_croak("Callback $event is not supported. Valid callbacks are " .join(', ',sort keys%ok_map))unless exists$ok_map{$event};push @{$self->{code_for}{$event}},$callback;return}sub _has_callbacks {my$self=shift;return keys %{$self->{code_for}}!=0}sub _callback_for {my ($self,$event)=@_;return$self->{code_for}{$event}}sub _make_callback {my$self=shift;my$event=shift;my$cb=$self->_callback_for($event);return unless defined$cb;return map {$_->(@_)}@$cb}sub get_time {return time()}sub time_is_hires {return GOT_TIME_HIRES}sub get_times {return [times()]}1;
TAP_BASE

$fatpacked{"TAP/Formatter/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_BASE';
  package TAP::Formatter::Base;use strict;use warnings;use base 'TAP::Base';use POSIX qw(strftime);my$MAX_ERRORS=5;my%VALIDATION_FOR;BEGIN {%VALIDATION_FOR=(directives=>sub {shift;shift},verbosity=>sub {shift;shift},normalize=>sub {shift;shift},timer=>sub {shift;shift},failures=>sub {shift;shift},comments=>sub {shift;shift},errors=>sub {shift;shift},color=>sub {shift;shift},jobs=>sub {shift;shift},show_count=>sub {shift;shift},stdout=>sub {my ($self,$ref)=@_;$self->_croak("option 'stdout' needs a filehandle")unless$self->_is_filehandle($ref);return$ref},);sub _is_filehandle {my ($self,$ref)=@_;return 0 if!defined$ref;return 1 if ref$ref eq 'GLOB';return 1 if!ref$ref && ref \$ref eq 'GLOB';return 1 if eval {$ref->can('print')};return 0}my@getter_setters=qw(_longest _printed_summary_header _colorizer);__PACKAGE__->mk_methods(@getter_setters,keys%VALIDATION_FOR)}our$VERSION='3.36';sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for);my%arg_for=%$arg_for;$self->verbosity(0);for my$name (keys%VALIDATION_FOR){my$property=delete$arg_for{$name};if (defined$property){my$validate=$VALIDATION_FOR{$name};$self->$name($self->$validate($property))}}if (my@props=keys%arg_for){$self->_croak("Unknown arguments to " .__PACKAGE__ ."::new (@props)")}$self->stdout(\*STDOUT)unless$self->stdout;if ($self->color){require TAP::Formatter::Color;$self->_colorizer(TAP::Formatter::Color->new)}return$self}sub verbose {shift->verbosity >= 1}sub quiet {shift->verbosity <= -1}sub really_quiet {shift->verbosity <= -2}sub silent {shift->verbosity <= -3}sub prepare {my ($self,@tests)=@_;my$longest=0;for my$test (@tests){$longest=length$test if length$test > $longest}$self->_longest($longest)}sub _format_now {strftime "[%H:%M:%S]",localtime}sub _format_name {my ($self,$test)=@_;my$name=$test;my$periods='.' x ($self->_longest + 2 - length$test);$periods=" $periods ";if ($self->timer){my$stamp=$self->_format_now();return "$stamp $name$periods"}else {return "$name$periods"}}sub open_test {die "Unimplemented."}sub _output_success {my ($self,$msg)=@_;$self->_output($msg)}sub summary {my ($self,$aggregate,$interrupted)=@_;return if$self->silent;my@t=$aggregate->descriptions;my$tests=\@t;my$runtime=$aggregate->elapsed_timestr;my$total=$aggregate->total;my$passed=$aggregate->passed;if ($self->timer){$self->_output($self->_format_now(),"\n")}$self->_failure_output("Test run interrupted!\n")if$interrupted;if ($aggregate->all_passed){$self->_output_success("All tests successful.\n")}if ($total!=$passed or $aggregate->has_problems){$self->_output("\nTest Summary Report");$self->_output("\n-------------------\n");for my$test (@$tests){$self->_printed_summary_header(0);my ($parser)=$aggregate->parsers($test);$self->_output_summary_failure('failed',['  Failed test:  ','  Failed tests:  ' ],$test,$parser);$self->_output_summary_failure('todo_passed',"  TODO passed:   ",$test,$parser);if (my$exit=$parser->exit){$self->_summary_test_header($test,$parser);$self->_failure_output("  Non-zero exit status: $exit\n")}elsif (my$wait=$parser->wait){$self->_summary_test_header($test,$parser);$self->_failure_output("  Non-zero wait status: $wait\n")}if (my@errors=$parser->parse_errors){my$explain;if (@errors > $MAX_ERRORS &&!$self->errors){$explain ="Displayed the first $MAX_ERRORS of " .scalar(@errors)." TAP syntax errors.\n" ."Re-run prove with the -p option to see them all.\n";splice@errors,$MAX_ERRORS}$self->_summary_test_header($test,$parser);$self->_failure_output(sprintf "  Parse errors: %s\n",shift@errors);for my$error (@errors){my$spaces=' ' x 16;$self->_failure_output("$spaces$error\n")}$self->_failure_output($explain)if$explain}}}my$files=@$tests;$self->_output("Files=$files, Tests=$total, $runtime\n");my$status=$aggregate->get_status;$self->_output("Result: $status\n")}sub _output_summary_failure {my ($self,$method,$name,$test,$parser)=@_;my$output=$method eq 'failed' ? '_failure_output' : '_output';if (my@r=$parser->$method()){$self->_summary_test_header($test,$parser);my ($singular,$plural)='ARRAY' eq ref$name ? @$name : ($name,$name);$self->$output(@r==1 ? $singular : $plural);my@results=$self->_balanced_range(40,@r);$self->$output(sprintf "%s\n"=>shift@results);my$spaces=' ' x 16;while (@results){$self->$output(sprintf "$spaces%s\n"=>shift@results)}}}sub _summary_test_header {my ($self,$test,$parser)=@_;return if$self->_printed_summary_header;my$spaces=' ' x ($self->_longest - length$test);$spaces=' ' unless$spaces;my$output=$self->_get_output_method($parser);my$wait=$parser->wait;defined$wait or $wait='(none)';$self->$output(sprintf "$test$spaces(Wstat: %s Tests: %d Failed: %d)\n",$wait,$parser->tests_run,scalar$parser->failed);$self->_printed_summary_header(1)}sub _output {my$self=shift;print {$self->stdout}@_}sub _failure_output {my$self=shift;$self->_output(@_)}sub _balanced_range {my ($self,$limit,@range)=@_;@range=$self->_range(@range);my$line="";my@lines;my$curr=0;while (@range){if ($curr < $limit){my$range=(shift@range).", ";$line .= $range;$curr += length$range}elsif (@range){$line =~ s/, $//;push@lines=>$line;$line='';$curr=0}}if ($line){$line =~ s/, $//;push@lines=>$line}return@lines}sub _range {my ($self,@numbers)=@_;@numbers=sort {$a <=> $b}@numbers;my ($min,@range);for my$i (0 .. $#numbers){my$num=$numbers[$i];my$next=$numbers[$i + 1 ];if (defined$next && $next==$num + 1){if (!defined$min){$min=$num}}elsif (defined$min){push@range=>"$min-$num";undef$min}else {push@range=>$num}}return@range}sub _get_output_method {my ($self,$parser)=@_;return$parser->has_problems ? '_failure_output' : '_output'}1;
TAP_FORMATTER_BASE

$fatpacked{"TAP/Formatter/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_COLOR';
  package TAP::Formatter::Color;use strict;use warnings;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use base 'TAP::Object';my$NO_COLOR;BEGIN {$NO_COLOR=0;if (IS_WIN32){eval 'use Win32::Console';if ($@){$NO_COLOR=$@}else {my$console=Win32::Console->new(STD_OUTPUT_HANDLE());my$fg=eval '$FG_LIGHTGRAY';my$bg=eval '$BG_BLACK';*set_color=sub {my ($self,$output,$color)=@_;my$var;if ($color eq 'reset'){$fg=eval '$FG_LIGHTGRAY';$bg=eval '$BG_BLACK'}elsif ($color =~ /^on_(.+)$/){$bg=eval '$BG_' .uc($1)}else {$fg=eval '$FG_' .uc($color)}$self->set_color('reset')unless defined$bg && defined$fg;$console->Attr($bg | $fg)}}}else {eval 'use Term::ANSIColor';if ($@){$NO_COLOR=$@}else {*set_color=sub {my ($self,$output,$color)=@_;$output->(color($color))}}}if ($NO_COLOR){*set_color=sub {}}}our$VERSION='3.36';sub _initialize {my$self=shift;if ($NO_COLOR){(my$error=$NO_COLOR)=~ s/ in \@INC .*//s;warn "Note: Cannot run tests in color: $error\n";return}return$self}sub can_color {return!$NO_COLOR}1;
TAP_FORMATTER_COLOR

$fatpacked{"TAP/Formatter/Console.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE';
  package TAP::Formatter::Console;use strict;use warnings;use base 'TAP::Formatter::Base';use POSIX qw(strftime);our$VERSION='3.36';sub open_test {my ($self,$test,$parser)=@_;my$class =$self->jobs > 1 ? 'TAP::Formatter::Console::ParallelSession' : 'TAP::Formatter::Console::Session';eval "require $class";$self->_croak($@)if $@;my$session=$class->new({name=>$test,formatter=>$self,parser=>$parser,show_count=>$self->show_count,});$session->header;return$session}sub _set_colors {my ($self,@colors)=@_;if (my$colorizer=$self->_colorizer){my$output_func=$self->{_output_func}||= sub {$self->_output(@_)};$colorizer->set_color($output_func,$_)for@colors}}sub _failure_color {my ($self)=@_;return$ENV{'HARNESS_SUMMARY_COLOR_FAIL'}|| 'red'}sub _success_color {my ($self)=@_;return$ENV{'HARNESS_SUMMARY_COLOR_SUCCESS'}|| 'green'}sub _output_success {my ($self,$msg)=@_;$self->_set_colors($self->_success_color());$self->_output($msg);$self->_set_colors('reset')}sub _failure_output {my$self=shift;$self->_set_colors($self->_failure_color());my$out=join '',@_;my$has_newline=chomp$out;$self->_output($out);$self->_set_colors('reset');$self->_output($/)if$has_newline}1;
TAP_FORMATTER_CONSOLE

$fatpacked{"TAP/Formatter/Console/ParallelSession.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_PARALLELSESSION';
  package TAP::Formatter::Console::ParallelSession;use strict;use warnings;use File::Spec;use File::Path;use Carp;use base 'TAP::Formatter::Console::Session';use constant WIDTH=>72;my%shared;sub _initialize {my ($self,$arg_for)=@_;$self->SUPER::_initialize($arg_for);my$formatter=$self->formatter;my$context=$shared{$formatter}||= $self->_create_shared_context;push @{$context->{active}},$self;return$self}sub _create_shared_context {my$self=shift;return {active=>[],tests=>0,fails=>0,}}our$VERSION='3.36';sub header {}sub _clear_ruler {my$self=shift;$self->formatter->_output("\r" .(' ' x WIDTH)."\r")}my$now=0;my$start;my$trailer='... )===';my$chop_length=WIDTH - length$trailer;sub _output_ruler {my ($self,$refresh)=@_;my$new_now=time;return if$new_now==$now and!$refresh;$now=$new_now;$start ||= $now;my$formatter=$self->formatter;return if$formatter->really_quiet;my$context=$shared{$formatter};my$ruler=sprintf '===( %7d;%d  ',$context->{tests},$now - $start;for my$active (@{$context->{active}}){my$parser=$active->parser;my$tests=$parser->tests_run;my$planned=$parser->tests_planned || '?';$ruler .= sprintf '%' .length($planned)."d/$planned  ",$tests}chop$ruler;$ruler .= ')===';if (length$ruler > WIDTH){$ruler =~ s/(.{$chop_length}).*/$1$trailer/o}else {$ruler .= '=' x (WIDTH - length($ruler))}$formatter->_output("\r$ruler")}sub result {my ($self,$result)=@_;my$formatter=$self->formatter;if ($result->is_test){my$context=$shared{$formatter};$context->{tests}++;my$active=$context->{active};if (@$active==1){return$self->SUPER::result($result)}$self->_output_ruler($self->parser->tests_run==1)}elsif ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n")}}sub clear_for_close {my$self=shift;my$formatter=$self->formatter;return if$formatter->really_quiet;my$context=$shared{$formatter};if (@{$context->{active}}==1){$self->SUPER::clear_for_close}else {$self->_clear_ruler}}sub close_test {my$self=shift;my$name=$self->name;my$parser=$self->parser;my$formatter=$self->formatter;my$context=$shared{$formatter};$self->SUPER::close_test;my$active=$context->{active};my@pos=grep {$active->[$_]->name eq $name}0 .. $#$active;die "Can't find myself" unless@pos;splice @$active,$pos[0],1;if (@$active > 1){$self->_output_ruler(1)}elsif (@$active==1){$active->[0]->SUPER::header}else {delete$shared{$formatter}}}1;
TAP_FORMATTER_CONSOLE_PARALLELSESSION

$fatpacked{"TAP/Formatter/Console/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_SESSION';
  package TAP::Formatter::Console::Session;use strict;use warnings;use base 'TAP::Formatter::Session';my@ACCESSOR;BEGIN {my@CLOSURE_BINDING=qw(header result clear_for_close close_test);for my$method (@CLOSURE_BINDING){no strict 'refs';*$method=sub {my$self=shift;return ($self->{_closures}||= $self->_closures)->{$method}->(@_)}}}our$VERSION='3.36';sub _get_output_result {my$self=shift;my@color_map=({test=>sub {$_->is_test &&!$_->is_ok},colors=>['red'],},{test=>sub {$_->is_test && $_->has_skip},colors=>['white','on_blue' ],},{test=>sub {$_->is_test && $_->has_todo},colors=>['yellow'],},);my$formatter=$self->formatter;my$parser=$self->parser;return$formatter->_colorizer ? sub {my$result=shift;for my$col (@color_map){local $_=$result;if ($col->{test}->()){$formatter->_set_colors(@{$col->{colors}});last}}$formatter->_output($self->_format_for_output($result));$formatter->_set_colors('reset')}: sub {$formatter->_output($self->_format_for_output(shift))}}sub _closures {my$self=shift;my$parser=$self->parser;my$formatter=$self->formatter;my$pretty=$formatter->_format_name($self->name);my$show_count=$self->show_count;my$really_quiet=$formatter->really_quiet;my$quiet=$formatter->quiet;my$verbose=$formatter->verbose;my$directives=$formatter->directives;my$failures=$formatter->failures;my$comments=$formatter->comments;my$output_result=$self->_get_output_result;my$output='_output';my$plan='';my$newline_printed=0;my$last_status_printed=0;return {header=>sub {$formatter->_output($pretty)unless$really_quiet},result=>sub {my$result=shift;if ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n")}return if$really_quiet;my$is_test=$result->is_test;if (!$plan){my$planned=$parser->tests_planned || '?';$plan="/$planned "}$output=$formatter->_get_output_method($parser);if ($show_count and $is_test){my$number=$result->number;my$now=CORE::time;if ($last_status_printed!=$now){$formatter->$output("\r$pretty$number$plan");$last_status_printed=$now}}if (!$quiet && ($verbose || ($is_test && $failures &&!$result->is_ok)|| ($comments && $result->is_comment)|| ($directives && $result->has_directive))){unless ($newline_printed){$formatter->_output("\n");$newline_printed=1}$output_result->($result);$formatter->_output("\n")}},clear_for_close=>sub {my$spaces =' ' x length('.' .$pretty .$plan .$parser->tests_run);$formatter->$output("\r$spaces")},close_test=>sub {if ($show_count &&!$really_quiet){$self->clear_for_close;$formatter->$output("\r$pretty")}$self->parser(undef);$self->{_closures}={};return if$really_quiet;if (my$skip_all=$parser->skip_all){$formatter->_output("skipped: $skip_all\n")}elsif ($parser->has_problems){$self->_output_test_failure($parser)}else {my$time_report=$self->time_report($formatter,$parser);$formatter->_output($self->_make_ok_line($time_report))}},}}1;
TAP_FORMATTER_CONSOLE_SESSION

$fatpacked{"TAP/Formatter/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE';
  package TAP::Formatter::File;use strict;use warnings;use TAP::Formatter::File::Session;use POSIX qw(strftime);use base 'TAP::Formatter::Base';our$VERSION='3.36';sub open_test {my ($self,$test,$parser)=@_;my$session=TAP::Formatter::File::Session->new({name=>$test,formatter=>$self,parser=>$parser,});$session->header;return$session}sub _should_show_count {return 0}1;
TAP_FORMATTER_FILE

$fatpacked{"TAP/Formatter/File/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE_SESSION';
  package TAP::Formatter::File::Session;use strict;use warnings;use base 'TAP::Formatter::Session';our$VERSION='3.36';sub result {my$self=shift;my$result=shift;my$parser=$self->parser;my$formatter=$self->formatter;if ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n");return}if (!$formatter->quiet && ($formatter->verbose || ($result->is_test && $formatter->failures &&!$result->is_ok)|| ($formatter->comments && $result->is_comment)|| ($result->has_directive && $formatter->directives))){$self->{results}.= $self->_format_for_output($result)."\n"}}sub close_test {my$self=shift;$self->parser(undef);my$parser=$self->parser;my$formatter=$self->formatter;my$pretty=$formatter->_format_name($self->name);return if$formatter->really_quiet;if (my$skip_all=$parser->skip_all){$formatter->_output($pretty ."skipped: $skip_all\n")}elsif ($parser->has_problems){$formatter->_output($pretty .($self->{results}? "\n" .$self->{results}: "\n"));$self->_output_test_failure($parser)}else {my$time_report=$self->time_report($formatter,$parser);$formatter->_output($pretty .($self->{results}? "\n" .$self->{results}: "").$self->_make_ok_line($time_report))}}1;
TAP_FORMATTER_FILE_SESSION

$fatpacked{"TAP/Formatter/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_SESSION';
  package TAP::Formatter::Session;use strict;use warnings;use base 'TAP::Base';my@ACCESSOR;BEGIN {@ACCESSOR=qw(name formatter parser show_count);for my$method (@ACCESSOR){no strict 'refs';*$method=sub {shift->{$method}}}}our$VERSION='3.36';sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for);my%arg_for=%$arg_for;for my$name (@ACCESSOR){$self->{$name}=delete$arg_for{$name}}if (!defined$self->show_count){$self->{show_count}=1}if ($self->show_count){$self->{show_count}=$self->_should_show_count}if (my@props=sort keys%arg_for){$self->_croak("Unknown arguments to " .__PACKAGE__ ."::new (@props)")}return$self}sub header {}sub result {}sub close_test {}sub clear_for_close {}sub _should_show_count {my$self=shift;return !$self->formatter->verbose && -t $self->formatter->stdout &&!$ENV{HARNESS_NOTTY}}sub _format_for_output {my ($self,$result)=@_;return$self->formatter->normalize ? $result->as_string : $result->raw}sub _output_test_failure {my ($self,$parser)=@_;my$formatter=$self->formatter;return if$formatter->really_quiet;my$tests_run=$parser->tests_run;my$tests_planned=$parser->tests_planned;my$total =defined$tests_planned ? $tests_planned : $tests_run;my$passed=$parser->passed;my$failed=$parser->failed + $total - $tests_run;my$exit=$parser->exit;if (my$exit=$parser->exit){my$wstat=$parser->wait;my$status=sprintf("%d (wstat %d, 0x%x)",$exit,$wstat,$wstat);$formatter->_failure_output("Dubious, test returned $status\n")}if ($failed==0){$formatter->_failure_output($total ? "All $total subtests passed " : 'No subtests run ')}else {$formatter->_failure_output("Failed $failed/$total subtests ");if (!$total){$formatter->_failure_output("\nNo tests run!")}}if (my$skipped=$parser->skipped){$passed -= $skipped;my$test='subtest' .($skipped!=1 ? 's' : '');$formatter->_output("\n\t(less $skipped skipped $test: $passed okay)")}if (my$failed=$parser->todo_passed){my$test=$failed > 1 ? 'tests' : 'test';$formatter->_output("\n\t($failed TODO $test unexpectedly succeeded)")}$formatter->_output("\n")}sub _make_ok_line {my ($self,$suffix)=@_;return "ok$suffix\n"}sub time_report {my ($self,$formatter,$parser)=@_;my@time_report;if ($formatter->timer){my$start_time=$parser->start_time;my$end_time=$parser->end_time;if (defined$start_time and defined$end_time){my$elapsed=$end_time - $start_time;push@time_report,$self->time_is_hires ? sprintf(' %8d ms',$elapsed * 1000): sprintf(' %8s s',$elapsed || '<1')}my$start_times=$parser->start_times();my$end_times=$parser->end_times();my$usr=$end_times->[0]- $start_times->[0];my$sys=$end_times->[1]- $start_times->[1];my$cusr=$end_times->[2]- $start_times->[2];my$csys=$end_times->[3]- $start_times->[3];push@time_report,sprintf('(%5.2f usr %5.2f sys + %5.2f cusr %5.2f csys = %5.2f CPU)',$usr,$sys,$cusr,$csys,$usr + $sys + $cusr + $csys)}return "@time_report"}1;
TAP_FORMATTER_SESSION

$fatpacked{"TAP/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS';
  package TAP::Harness;use strict;use warnings;use Carp;use File::Spec;use File::Path;use IO::Handle;use base 'TAP::Base';our$VERSION='3.36';$ENV{HARNESS_ACTIVE}=1;$ENV{HARNESS_VERSION}=$VERSION;END {delete$ENV{HARNESS_ACTIVE};delete$ENV{HARNESS_VERSION}}my%VALIDATION_FOR;my@FORMATTER_ARGS;sub _error {my$self=shift;return$self->{error}unless @_;$self->{error}=shift}BEGIN {@FORMATTER_ARGS=qw(directives verbosity timer failures comments errors stdout color show_count normalize);%VALIDATION_FOR=(lib=>sub {my ($self,$libs)=@_;$libs=[$libs]unless 'ARRAY' eq ref$libs;return [map {"-I$_"}@$libs ]},switches=>sub {shift;shift},exec=>sub {shift;shift},merge=>sub {shift;shift},aggregator_class=>sub {shift;shift},formatter_class=>sub {shift;shift},multiplexer_class=>sub {shift;shift},parser_class=>sub {shift;shift},scheduler_class=>sub {shift;shift},formatter=>sub {shift;shift},jobs=>sub {shift;shift},test_args=>sub {shift;shift},ignore_exit=>sub {shift;shift},rules=>sub {shift;shift},rulesfile=>sub {shift;shift},sources=>sub {shift;shift},version=>sub {shift;shift},trap=>sub {shift;shift},);for my$method (sort keys%VALIDATION_FOR){no strict 'refs';if ($method eq 'lib' || $method eq 'switches'){*{$method}=sub {my$self=shift;unless (@_){$self->{$method}||= [];return wantarray ? @{$self->{$method}}: $self->{$method}}$self->_croak("Too many arguments to method '$method'")if @_ > 1;my$args=shift;$args=[$args]unless ref$args;$self->{$method}=$args;return$self}}else {*{$method}=sub {my$self=shift;return$self->{$method}unless @_;$self->{$method}=shift}}}for my$method (@FORMATTER_ARGS){no strict 'refs';*{$method}=sub {my$self=shift;return$self->formatter->$method(@_)}}}{my@legal_callback=qw(parser_args made_parser before_runtests after_runtests after_test);my%default_class=(aggregator_class=>'TAP::Parser::Aggregator',formatter_class=>'TAP::Formatter::Console',multiplexer_class=>'TAP::Parser::Multiplexer',parser_class=>'TAP::Parser',scheduler_class=>'TAP::Parser::Scheduler',);sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for,\@legal_callback);my%arg_for=%$arg_for;for my$name (sort keys%VALIDATION_FOR){my$property=delete$arg_for{$name};if (defined$property){my$validate=$VALIDATION_FOR{$name};my$value=$self->$validate($property);if ($self->_error){$self->_croak}$self->$name($value)}}$self->jobs(1)unless defined$self->jobs;if (!defined$self->rules){$self->_maybe_load_rulesfile}local$default_class{formatter_class}='TAP::Formatter::File' unless -t ($arg_for{stdout}|| \*STDOUT)&&!$ENV{HARNESS_NOTTY};while (my ($attr,$class)=each%default_class){$self->$attr($self->$attr()|| $class)}unless ($self->formatter){my%formatter_args=(jobs=>$self->jobs);for my$name (@FORMATTER_ARGS){if (defined(my$property=delete$arg_for{$name})){$formatter_args{$name}=$property}}$self->formatter($self->_construct($self->formatter_class,\%formatter_args))}if (my@props=sort keys%arg_for){$self->_croak("Unknown arguments to TAP::Harness::new (@props)")}return$self}sub _maybe_load_rulesfile {my ($self)=@_;my ($rulesfile)=defined$self->rulesfile ? $self->rulesfile : defined($ENV{HARNESS_RULESFILE})? $ENV{HARNESS_RULESFILE}: grep {-r}qw(./testrules.yml t/testrules.yml);if (defined$rulesfile && -r $rulesfile){if (!eval {require CPAN::Meta::YAML;1}){warn "CPAN::Meta::YAML required to process $rulesfile" ;return}my$layer=$] lt "5.008" ? "" : ":encoding(UTF-8)";open my$fh,"<$layer",$rulesfile or die "Couldn't open $rulesfile: $!";my$yaml_text=do {local $/;<$fh>};my$yaml=CPAN::Meta::YAML->read_string($yaml_text)or die CPAN::Meta::YAML->errstr;$self->rules($yaml->[0])}return}}sub runtests {my ($self,@tests)=@_;my$aggregate=$self->_construct($self->aggregator_class);$self->_make_callback('before_runtests',$aggregate);$aggregate->start;my$finish=sub {my$interrupted=shift;$aggregate->stop;$self->summary($aggregate,$interrupted);$self->_make_callback('after_runtests',$aggregate)};my$run=sub {$self->aggregate_tests($aggregate,@tests);$finish->()};if ($self->trap){local$SIG{INT}=sub {print "\n";$finish->(1);exit};$run->()}else {$run->()}return$aggregate}sub summary {my ($self,@args)=@_;$self->formatter->summary(@args)}sub _after_test {my ($self,$aggregate,$job,$parser)=@_;$self->_make_callback('after_test',$job->as_array_ref,$parser);$aggregate->add($job->description,$parser)}sub _bailout {my ($self,$result)=@_;my$explanation=$result->explanation;die "FAILED--Further testing stopped" .($explanation ? ": $explanation\n" : ".\n")}sub _aggregate_parallel {my ($self,$aggregate,$scheduler)=@_;my$jobs=$self->jobs;my$mux=$self->_construct($self->multiplexer_class);RESULT: {FILL: while ($mux->parsers < $jobs){my$job=$scheduler->get_job;last FILL if!defined$job || $job->is_spinner;my ($parser,$session)=$self->make_parser($job);$mux->add($parser,[$session,$job ])}if (my ($parser,$stash,$result)=$mux->next){my ($session,$job)=@$stash;if (defined$result){$session->result($result);$self->_bailout($result)if$result->is_bailout}else {$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish}redo RESULT}}return}sub _aggregate_single {my ($self,$aggregate,$scheduler)=@_;JOB: while (my$job=$scheduler->get_job){next JOB if$job->is_spinner;my ($parser,$session)=$self->make_parser($job);while (defined(my$result=$parser->next)){$session->result($result);if ($result->is_bailout){1 while$parser->next;$self->_bailout($result)}}$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish}return}sub aggregate_tests {my ($self,$aggregate,@tests)=@_;my$jobs=$self->jobs;my$scheduler=$self->make_scheduler(@tests);local$ENV{HARNESS_IS_VERBOSE}=1 if$self->formatter->verbosity > 0;$self->formatter->prepare(map {$_->description}$scheduler->get_all);if ($self->jobs > 1){$self->_aggregate_parallel($aggregate,$scheduler)}else {$self->_aggregate_single($aggregate,$scheduler)}return}sub _add_descriptions {my$self=shift;return map {@$_==1 ? [$_->[0],$_->[0]]: $_}map {'ARRAY' eq ref $_ ? $_ : [$_]}@_}sub make_scheduler {my ($self,@tests)=@_;return$self->_construct($self->scheduler_class,tests=>[$self->_add_descriptions(@tests)],rules=>$self->rules)}sub _get_parser_args {my ($self,$job)=@_;my$test_prog=$job->filename;my%args=();$args{sources}=$self->sources if$self->sources;my@switches;@switches=$self->lib if$self->lib;push@switches=>$self->switches if$self->switches;$args{switches}=\@switches;$args{spool}=$self->_open_spool($test_prog);$args{merge}=$self->merge;$args{ignore_exit}=$self->ignore_exit;$args{version}=$self->version if$self->version;if (my$exec=$self->exec){$args{exec}=ref$exec eq 'CODE' ? $exec->($self,$test_prog): [@$exec,$test_prog ];if (not defined$args{exec}){$args{source}=$test_prog}elsif ((ref($args{exec})|| "")ne "ARRAY"){$args{source}=delete$args{exec}}}else {$args{source}=$test_prog}if (defined(my$test_args=$self->test_args)){if (ref($test_args)eq 'HASH'){if (exists($test_args->{$job->description })){$test_args=$test_args->{$job->description }}else {$self->_croak("TAP::Harness Can't find test_args for " .$job->description)}}$args{test_args}=$test_args}return \%args}sub make_parser {my ($self,$job)=@_;my$args=$self->_get_parser_args($job);$self->_make_callback('parser_args',$args,$job->as_array_ref);my$parser=$self->_construct($self->parser_class,$args);$self->_make_callback('made_parser',$parser,$job->as_array_ref);my$session=$self->formatter->open_test($job->description,$parser);return ($parser,$session)}sub finish_parser {my ($self,$parser,$session)=@_;$session->close_test;$self->_close_spool($parser);return$parser}sub _open_spool {my$self=shift;my$test=shift;if (my$spool_dir=$ENV{PERL_TEST_HARNESS_DUMP_TAP}){my$spool=File::Spec->catfile($spool_dir,$test);my ($vol,$dir,undef)=File::Spec->splitpath($spool);my$path=File::Spec->catpath($vol,$dir,'');eval {mkpath($path)};$self->_croak($@)if $@;my$spool_handle=IO::Handle->new;open($spool_handle,">$spool")or $self->_croak(" Can't write $spool ( $! ) ");return$spool_handle}return}sub _close_spool {my$self=shift;my ($parser)=@_;if (my$spool_handle=$parser->delete_spool){close($spool_handle)or $self->_croak(" Error closing TAP spool file( $! ) \n ")}return}sub _croak {my ($self,$message)=@_;unless ($message){$message=$self->_error}$self->SUPER::_croak($message);return}1;
TAP_HARNESS

$fatpacked{"TAP/Harness/Env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS_ENV';
  package TAP::Harness::Env;use strict;use warnings;use constant IS_VMS=>($^O eq 'VMS');use TAP::Object;use Text::ParseWords qw/shellwords/;our$VERSION='3.36';sub _filtered_inc_vms {my@inc=grep {!ref}@INC;@inc=grep {!/perl_root/i}@inc;my@default_inc=_default_inc();my@new_inc;my%seen;for my$dir (@inc){next if$seen{$dir}++;if ($dir eq ($default_inc[0]|| '')){shift@default_inc}else {push@new_inc,$dir}shift@default_inc while@default_inc and $seen{$default_inc[0]}}return@new_inc}my@inc;sub _default_inc {return@inc if@inc;local$ENV{PERL5LIB};local$ENV{PERLLIB};my$perl=$ENV{HARNESS_PERL}|| $^X;chomp(@inc=`"$perl" -e "print join qq[\\n], \@INC, q[]"`);return@inc}sub create {my$package=shift;my%input=%{shift || {}};my@libs=@{delete$input{libs}|| []};my@raw_switches=@{delete$input{switches}|| []};my@opt =(@raw_switches,shellwords($ENV{HARNESS_PERL_SWITCHES}|| ''));my@switches;while (my$opt=shift@opt){if ($opt =~ /^ -I (.*) $ /x){push@libs,length($1)? $1 : shift@opt}else {push@switches,$opt}}push@libs,_filtered_inc_vms()if IS_VMS;my$verbose =$ENV{HARNESS_VERBOSE}? $ENV{HARNESS_VERBOSE}!~ /\d/ ? 1 : $ENV{HARNESS_VERBOSE}: 0;my%args=(lib=>\@libs,timer=>$ENV{HARNESS_TIMER}|| 0,switches=>\@switches,color=>$ENV{HARNESS_COLOR}|| 0,verbosity=>$verbose,ignore_exit=>$ENV{HARNESS_IGNORE_EXIT}|| 0,);my$class=delete$input{harness_class}|| $ENV{HARNESS_SUBCLASS}|| 'TAP::Harness';if (defined(my$env_opt=$ENV{HARNESS_OPTIONS})){for my$opt (split /:/,$env_opt){if ($opt =~ /^j(\d*)$/){$args{jobs}=$1 || 9}elsif ($opt eq 'c'){$args{color}=1}elsif ($opt =~ m/^f(.*)$/){my$fmt=$1;$fmt =~ s/-/::/g;$args{formatter_class}=$fmt}elsif ($opt =~ m/^a(.*)$/){my$archive=$1;$class='TAP::Harness::Archive';$args{archive}=$archive}else {die "Unknown HARNESS_OPTIONS item: $opt\n"}}}return TAP::Object->_construct($class,{%args,%input })}1;
TAP_HARNESS_ENV

$fatpacked{"TAP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_OBJECT';
  package TAP::Object;use strict;use warnings;our$VERSION='3.36';sub new {my$class=shift;my$self=bless {},$class;return$self->_initialize(@_)}sub _initialize {return $_[0]}sub _croak {my$proto=shift;require Carp;Carp::croak(@_);return}sub _confess {my$proto=shift;require Carp;Carp::confess(@_);return}sub _construct {my ($self,$class,@args)=@_;$self->_croak("Bad module name $class")unless$class =~ /^ \w+ (?: :: \w+ ) *$/x;unless ($class->can('new')){local $@;eval "require $class";$self->_croak("Can't load $class: $@")if $@}return$class->new(@args)}sub mk_methods {my ($class,@methods)=@_;for my$method_name (@methods){my$method="${class}::$method_name";no strict 'refs';*$method=sub {my$self=shift;$self->{$method_name}=shift if @_;return$self->{$method_name}}}}1;
TAP_OBJECT

$fatpacked{"TAP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER';
  package TAP::Parser;use strict;use warnings;use TAP::Parser::Grammar ();use TAP::Parser::Result ();use TAP::Parser::ResultFactory ();use TAP::Parser::Source ();use TAP::Parser::Iterator ();use TAP::Parser::IteratorFactory ();use TAP::Parser::SourceHandler::Executable ();use TAP::Parser::SourceHandler::Perl ();use TAP::Parser::SourceHandler::File ();use TAP::Parser::SourceHandler::RawTAP ();use TAP::Parser::SourceHandler::Handle ();use Carp qw(confess);use base 'TAP::Base';our$VERSION='3.36';my$DEFAULT_TAP_VERSION=12;my$MAX_TAP_VERSION=13;$ENV{TAP_VERSION}=$MAX_TAP_VERSION;END {delete$ENV{TAP_VERSION}}BEGIN {__PACKAGE__->mk_methods(qw(_iterator _spool exec exit is_good_plan plan tests_planned tests_run wait version in_todo start_time end_time start_times end_times skip_all grammar_class result_factory_class iterator_factory_class));sub _stream {my$self=shift;$self->_iterator(@_)}}sub _default_grammar_class {'TAP::Parser::Grammar'}sub _default_result_factory_class {'TAP::Parser::ResultFactory'}sub _default_iterator_factory_class {'TAP::Parser::IteratorFactory'}sub next {my$self=shift;return ($self->{_iter}||= $self->_iter)->()}sub run {my$self=shift;while (defined(my$result=$self->next)){}}sub make_iterator_factory {shift->iterator_factory_class->new(@_)}sub make_grammar {shift->grammar_class->new(@_)}sub make_result {shift->result_factory_class->make_result(@_)}{my%initialize=(version=>$DEFAULT_TAP_VERSION,plan=>'',tests_run=>0,skipped=>[],todo=>[],passed=>[],failed=>[],actual_failed=>[],actual_passed=>[],todo_passed=>[],parse_errors=>[],);my@legal_callback=qw(test version plan comment bailout unknown yaml ALL ELSE EOF);my@class_overrides=qw(grammar_class result_factory_class iterator_factory_class);sub _initialize {my ($self,$arg_for)=@_;my%args=%{$arg_for || {}};$self->SUPER::_initialize(\%args,\@legal_callback);for my$key (@class_overrides){my$default_method="_default_$key";my$val=delete$args{$key}|| $self->$default_method();$self->$key($val)}my$iterator=delete$args{iterator};$iterator ||= delete$args{stream};my$tap=delete$args{tap};my$version=delete$args{version};my$raw_source=delete$args{source};my$sources=delete$args{sources};my$exec=delete$args{exec};my$merge=delete$args{merge};my$spool=delete$args{spool};my$switches=delete$args{switches};my$ignore_exit=delete$args{ignore_exit};my$test_args=delete$args{test_args}|| [];if (1 < grep {defined}$iterator,$tap,$raw_source,$exec){$self->_croak("You may only choose one of 'exec', 'tap', 'source' or 'iterator'")}if (my@excess=sort keys%args){$self->_croak("Unknown options: @excess")}my$type='';my$source=TAP::Parser::Source->new;if ($tap){$type='raw TAP';$source->raw(\$tap)}elsif ($exec){$type='exec ' .$exec->[0];$source->raw({exec=>$exec })}elsif ($raw_source){$type='source ' .ref($raw_source)|| $raw_source;$source->raw(ref($raw_source)? $raw_source : \$raw_source)}elsif ($iterator){$type='iterator ' .ref($iterator)}if ($source->raw){my$src_factory=$self->make_iterator_factory($sources);$source->merge($merge)->switches($switches)->test_args($test_args);$iterator=$src_factory->make_iterator($source)}unless ($iterator){$self->_croak("PANIC: could not determine iterator for input $type")}while (my ($k,$v)=each%initialize){$self->{$k}='ARRAY' eq ref$v ? []: $v}$self->version($version)if$version;$self->_iterator($iterator);$self->_spool($spool);$self->ignore_exit($ignore_exit);return$self}}sub passed {return @{$_[0]->{passed}}if ref $_[0]->{passed};return wantarray ? 1 .. $_[0]->{passed}: $_[0]->{passed}}sub failed {@{shift->{failed}}}sub actual_passed {return @{$_[0]->{actual_passed}}if ref $_[0]->{actual_passed};return wantarray ? 1 .. $_[0]->{actual_passed}: $_[0]->{actual_passed}}*actual_ok=\&actual_passed;sub actual_failed {@{shift->{actual_failed}}}sub todo {@{shift->{todo}}}sub todo_passed {@{shift->{todo_passed}}}sub todo_failed {warn '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';goto&todo_passed}sub skipped {@{shift->{skipped}}}sub pragma {my ($self,$pragma)=splice @_,0,2;return$self->{pragma}->{$pragma}unless @_;if (my$state=shift){$self->{pragma}->{$pragma}=1}else {delete$self->{pragma}->{$pragma}}return}sub pragmas {sort keys %{shift->{pragma}|| {}}}sub good_plan {warn 'good_plan() is deprecated.  Please use "is_good_plan()"';goto&is_good_plan}sub has_problems {my$self=shift;return $self->failed || $self->parse_errors || (!$self->ignore_exit && ($self->wait || $self->exit))}sub ignore_exit {shift->pragma('ignore_exit',@_)}sub parse_errors {@{shift->{parse_errors}}}sub _add_error {my ($self,$error)=@_;push @{$self->{parse_errors}}=>$error;return$self}sub _make_state_table {my$self=shift;my%states;my%planned_todo=();my%state_globals=(comment=>{},bailout=>{},yaml=>{},version=>{act=>sub {$self->_add_error('If TAP version is present it must be the first line of output')},},unknown=>{act=>sub {my$unk=shift;if ($self->pragma('strict')){$self->_add_error('Unknown TAP token: "' .$unk->raw .'"')}},},pragma=>{act=>sub {my ($pragma)=@_;for my$pr ($pragma->pragmas){if ($pr =~ /^ ([-+])(\w+) $/x){$self->pragma($2,$1 eq '+')}}},},);my%state_defaults=(plan=>{act=>sub {my ($plan)=@_;$self->tests_planned($plan->tests_planned);$self->plan($plan->plan);if ($plan->has_skip){$self->skip_all($plan->explanation || '(no reason given)')}$planned_todo{$_}++ for @{$plan->todo_list}},},test=>{act=>sub {my ($test)=@_;my ($number,$tests_run)=($test->number,++$self->{tests_run});if (defined$number && delete$planned_todo{$number}){$test->set_directive('TODO')}my$has_todo=$test->has_todo;$self->in_todo($has_todo);if (defined(my$tests_planned=$self->tests_planned)){if ($tests_run > $tests_planned){$test->is_unplanned(1)}}if (defined$number){if ($number!=$tests_run){my$count=$tests_run;$self->_add_error("Tests out of sequence.  Found " ."($number) but expected ($count)")}}else {$test->_number($number=$tests_run)}push @{$self->{todo}}=>$number if$has_todo;push @{$self->{todo_passed}}=>$number if$test->todo_passed;push @{$self->{skipped}}=>$number if$test->has_skip;push @{$self->{$test->is_ok ? 'passed' : 'failed' }}=>$number;push @{$self->{$test->is_actual_ok ? 'actual_passed' : 'actual_failed' }}=>$number},},yaml=>{act=>sub {},},);%states=(INIT=>{version=>{act=>sub {my ($version)=@_;my$ver_num=$version->version;if ($ver_num <= $DEFAULT_TAP_VERSION){my$ver_min=$DEFAULT_TAP_VERSION + 1;$self->_add_error("Explicit TAP version must be at least " ."$ver_min. Got version $ver_num");$ver_num=$DEFAULT_TAP_VERSION}if ($ver_num > $MAX_TAP_VERSION){$self->_add_error("TAP specified version $ver_num but " ."we don't know about versions later " ."than $MAX_TAP_VERSION");$ver_num=$MAX_TAP_VERSION}$self->version($ver_num);$self->_grammar->set_version($ver_num)},goto=>'PLAN' },plan=>{goto=>'PLANNED' },test=>{goto=>'UNPLANNED' },},PLAN=>{plan=>{goto=>'PLANNED' },test=>{goto=>'UNPLANNED' },},PLANNED=>{test=>{goto=>'PLANNED_AFTER_TEST' },plan=>{act=>sub {my ($version)=@_;$self->_add_error('More than one plan found in TAP output')},},},PLANNED_AFTER_TEST=>{test=>{goto=>'PLANNED_AFTER_TEST' },plan=>{act=>sub {},continue=>'PLANNED' },yaml=>{goto=>'PLANNED' },},GOT_PLAN=>{test=>{act=>sub {my ($plan)=@_;my$line=$self->plan;$self->_add_error("Plan ($line) must be at the beginning " ."or end of the TAP output");$self->is_good_plan(0)},continue=>'PLANNED' },plan=>{continue=>'PLANNED' },},UNPLANNED=>{test=>{goto=>'UNPLANNED_AFTER_TEST' },plan=>{goto=>'GOT_PLAN' },},UNPLANNED_AFTER_TEST=>{test=>{act=>sub {},continue=>'UNPLANNED' },plan=>{act=>sub {},continue=>'UNPLANNED' },yaml=>{goto=>'UNPLANNED' },},);for my$name (keys%states){my$st={%state_globals,%{$states{$name}}};for my$next (sort keys %{$st}){if (my$default=$state_defaults{$next}){for my$def (sort keys %{$default}){$st->{$next}->{$def}||= $default->{$def}}}}$states{$name}=$st}return \%states}sub get_select_handles {shift->_iterator->get_select_handles}sub _grammar {my$self=shift;return$self->{_grammar}=shift if @_;return$self->{_grammar}||= $self->make_grammar({iterator=>$self->_iterator,parser=>$self,version=>$self->version })}sub _iter {my$self=shift;my$iterator=$self->_iterator;my$grammar=$self->_grammar;my$spool=$self->_spool;my$state='INIT';my$state_table=$self->_make_state_table;$self->start_time($self->get_time);$self->start_times($self->get_times);my$next_state=sub {my$token=shift;my$type=$token->type;TRANS: {my$state_spec=$state_table->{$state}or die "Illegal state: $state";if (my$next=$state_spec->{$type}){if (my$act=$next->{act}){$act->($token)}if (my$cont=$next->{continue}){$state=$cont;redo TRANS}elsif (my$goto=$next->{goto}){$state=$goto}}else {confess("Unhandled token type: $type\n")}}return$token};my$end_handler=sub {$self->exit($iterator->exit);$self->wait($iterator->wait);$self->_finish;return};if ($self->_has_callbacks){return sub {my$result=eval {$grammar->tokenize};$self->_add_error($@)if $@;if (defined$result){$result=$next_state->($result);if (my$code=$self->_callback_for($result->type)){$_->($result)for @{$code}}else {$self->_make_callback('ELSE',$result)}$self->_make_callback('ALL',$result);print {$spool}$result->raw,"\n" if$spool}else {$result=$end_handler->();$self->_make_callback('EOF',$self)unless defined$result}return$result}}else {return sub {my$result=eval {$grammar->tokenize};$self->_add_error($@)if $@;if (defined$result){$result=$next_state->($result);print {$spool}$result->raw,"\n" if$spool}else {$result=$end_handler->()}return$result}}}sub _finish {my$self=shift;$self->end_time($self->get_time);$self->end_times($self->get_times);$self->_iterator(undef);$self->_grammar(undef);$self->{_iter}=sub {return}if $] >= 5.006;if (!$self->plan){$self->_add_error('No plan found in TAP output')}else {$self->is_good_plan(1)unless defined$self->is_good_plan}if ($self->tests_run!=($self->tests_planned || 0)){$self->is_good_plan(0);if (defined(my$planned=$self->tests_planned)){my$ran=$self->tests_run;$self->_add_error("Bad plan.  You planned $planned tests but ran $ran.")}}if ($self->tests_run!=($self->passed + $self->failed)){my$actual=$self->tests_run;my$passed=$self->passed;my$failed=$self->failed;$self->_croak("Panic: planned test count ($actual) did not equal " ."sum of passed ($passed) and failed ($failed) tests!")}$self->is_good_plan(0)unless defined$self->is_good_plan;unless ($self->parse_errors){if ($self->tests_run==@{$self->{passed}}){$self->{passed}=$self->tests_run}if ($self->tests_run==@{$self->{actual_passed}}){$self->{actual_passed}=$self->tests_run}}return$self}sub delete_spool {my$self=shift;return delete$self->{_spool}}1;
TAP_PARSER

$fatpacked{"TAP/Parser/Aggregator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_AGGREGATOR';
  package TAP::Parser::Aggregator;use strict;use warnings;use Benchmark;use base 'TAP::Object';our$VERSION='3.36';my%SUMMARY_METHOD_FOR;BEGIN {%SUMMARY_METHOD_FOR=map {$_=>$_}qw(failed parse_errors passed skipped todo todo_passed total wait exit);$SUMMARY_METHOD_FOR{total}='tests_run';$SUMMARY_METHOD_FOR{planned}='tests_planned';for my$method (keys%SUMMARY_METHOD_FOR){next if 'total' eq $method;no strict 'refs';*$method=sub {my$self=shift;return wantarray ? @{$self->{"descriptions_for_$method"}}: $self->{$method}}}}sub _initialize {my ($self)=@_;$self->{parser_for}={};$self->{parse_order}=[];for my$summary (keys%SUMMARY_METHOD_FOR){$self->{$summary}=0;next if 'total' eq $summary;$self->{"descriptions_for_$summary"}=[]}return$self}sub add {my ($self,$description,$parser)=@_;if (exists$self->{parser_for}{$description}){$self->_croak("You already have a parser for ($description)." ." Perhaps you have run the same test twice.")}push @{$self->{parse_order}}=>$description;$self->{parser_for}{$description}=$parser;while (my ($summary,$method)=each%SUMMARY_METHOD_FOR){next if ($method eq 'exit' || $method eq 'wait')&& $parser->ignore_exit;if (my$count=$parser->$method()){$self->{$summary}+= $count;push @{$self->{"descriptions_for_$summary"}}=>$description}}return$self}sub parsers {my$self=shift;return$self->_get_parsers(@_)if @_;my$descriptions=$self->{parse_order};my@parsers=@{$self->{parser_for}}{@$descriptions};return@parsers}sub _get_parsers {my ($self,@descriptions)=@_;my@parsers;for my$description (@descriptions){$self->_croak("A parser for ($description) could not be found")unless exists$self->{parser_for}{$description};push@parsers=>$self->{parser_for}{$description}}return wantarray ? @parsers : \@parsers}sub descriptions {@{shift->{parse_order}|| []}}sub start {my$self=shift;$self->{start_time}=Benchmark->new}sub stop {my$self=shift;$self->{end_time}=Benchmark->new}sub elapsed {my$self=shift;require Carp;Carp::croak q{Can't call elapsed without first calling start and then stop} unless defined$self->{start_time}&& defined$self->{end_time};return timediff($self->{end_time},$self->{start_time})}sub elapsed_timestr {my$self=shift;my$elapsed=$self->elapsed;return timestr($elapsed)}sub all_passed {my$self=shift;return $self->total && $self->total==$self->passed &&!$self->has_errors}sub get_status {my$self=shift;my$total=$self->total;my$passed=$self->passed;return ($self->has_errors || $total!=$passed)? 'FAIL' : $total ? 'PASS' : 'NOTESTS'}sub total {shift->{total}}sub has_problems {my$self=shift;return$self->todo_passed || $self->has_errors}sub has_errors {my$self=shift;return $self->failed || $self->parse_errors || $self->exit || $self->wait}sub todo_failed {warn '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';goto&todo_passed}1;
TAP_PARSER_AGGREGATOR

$fatpacked{"TAP/Parser/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_GRAMMAR';
  package TAP::Parser::Grammar;use strict;use warnings;use TAP::Parser::ResultFactory ();use TAP::Parser::YAMLish::Reader ();use base 'TAP::Object';our$VERSION='3.36';sub _initialize {my ($self,$args)=@_;$self->{iterator}=$args->{iterator};$self->{iterator}||= $args->{stream};$self->{parser}=$args->{parser};$self->set_version($args->{version}|| 12);return$self}my%language_for;{my$ok=qr/(?:not )?ok\b/;my$num=qr/\d+/;my%v12=(version=>{syntax=>qr/^TAP\s+version\s+(\d+)\s*\z/i,handler=>sub {my ($self,$line)=@_;my$version=$1;return$self->_make_version_token($line,$version,)},},plan=>{syntax=>qr/^1\.\.(\d+)\s*(.*)\z/,handler=>sub {my ($self,$line)=@_;my ($tests_planned,$tail)=($1,$2);my$explanation=undef;my$skip='';if ($tail =~ /^todo((?:\s+\d+)+)/){my@todo=split /\s+/,_trim($1);return$self->_make_plan_token($line,$tests_planned,'TODO','',\@todo)}elsif (0==$tests_planned){$skip='SKIP';($explanation)=$tail =~ /^#\s*SKIP\S*\s+(.*)/i}elsif ($tail !~ /^\s*$/){return$self->_make_unknown_token($line)}$explanation='' unless defined$explanation;return$self->_make_plan_token($line,$tests_planned,$skip,$explanation,[])},},simple_test=>{syntax=>qr/^($ok) \ ($num) (?:\ ([^#]+))? \z/x,handler=>sub {my ($self,$line)=@_;my ($ok,$num,$desc)=($1,$2,$3);return$self->_make_test_token($line,$ok,$num,$desc)},},test=>{syntax=>qr/^($ok) \s* ($num)? \s* (.*) \z/x,handler=>sub {my ($self,$line)=@_;my ($ok,$num,$desc)=($1,$2,$3);my ($dir,$explanation)=('','');if ($desc =~ m/^ ( [^\\\#]* (?: \\. [^\\\#]* )* )
                         \# \s* (SKIP|TODO) \b \s* (.*) $/ix){($desc,$dir,$explanation)=($1,$2,$3)}return$self->_make_test_token($line,$ok,$num,$desc,$dir,$explanation)},},comment=>{syntax=>qr/^#(.*)/,handler=>sub {my ($self,$line)=@_;my$comment=$1;return$self->_make_comment_token($line,$comment)},},bailout=>{syntax=>qr/^\s*Bail out!\s*(.*)/,handler=>sub {my ($self,$line)=@_;my$explanation=$1;return$self->_make_bailout_token($line,$explanation)},},);my%v13=(%v12,plan=>{syntax=>qr/^1\.\.(\d+)(?:\s*#\s*SKIP\b(.*))?\z/i,handler=>sub {my ($self,$line)=@_;my ($tests_planned,$explanation)=($1,$2);my$skip =(0==$tests_planned || defined$explanation)? 'SKIP' : '';$explanation='' unless defined$explanation;return$self->_make_plan_token($line,$tests_planned,$skip,$explanation,[])},},yaml=>{syntax=>qr/^ (\s+) (---.*) $/x,handler=>sub {my ($self,$line)=@_;my ($pad,$marker)=($1,$2);return$self->_make_yaml_token($pad,$marker)},},pragma=>{syntax=>qr/^ pragma \s+ ( [-+] \w+ \s* (?: , \s* [-+] \w+ \s* )* ) $/x,handler=>sub {my ($self,$line)=@_;my$pragmas=$1;return$self->_make_pragma_token($line,$pragmas)},},);%language_for=('12'=>{tokens=>\%v12,},'13'=>{tokens=>\%v13,setup=>sub {shift->{iterator}->handle_unicode},},)}sub set_version {my$self=shift;my$version=shift;if (my$language=$language_for{$version}){$self->{version}=$version;$self->{tokens}=$language->{tokens};if (my$setup=$language->{setup}){$self->$setup()}$self->_order_tokens}else {require Carp;Carp::croak("Unsupported syntax version: $version")}}sub _order_tokens {my$self=shift;my%copy=%{$self->{tokens}};my@ordered_tokens=grep {defined}map {delete$copy{$_}}qw(simple_test test comment plan);push@ordered_tokens,values%copy;$self->{ordered_tokens}=\@ordered_tokens}sub tokenize {my$self=shift;my$line=$self->{iterator}->next;unless (defined$line){delete$self->{parser};return}my$token;for my$token_data (@{$self->{ordered_tokens}}){if ($line =~ $token_data->{syntax}){my$handler=$token_data->{handler};$token=$self->$handler($line);last}}$token=$self->_make_unknown_token($line)unless$token;return$self->{parser}->make_result($token)}sub token_types {my$self=shift;return keys %{$self->{tokens}}}sub syntax_for {my ($self,$type)=@_;return$self->{tokens}->{$type}->{syntax}}sub handler_for {my ($self,$type)=@_;return$self->{tokens}->{$type}->{handler}}sub _make_version_token {my ($self,$line,$version)=@_;return {type=>'version',raw=>$line,version=>$version,}}sub _make_plan_token {my ($self,$line,$tests_planned,$directive,$explanation,$todo)=@_;if ($directive eq 'SKIP' && 0!=$tests_planned && $self->{version}< 13){warn "Specified SKIP directive in plan but more than 0 tests ($line)\n"}return {type=>'plan',raw=>$line,tests_planned=>$tests_planned,directive=>$directive,explanation=>_trim($explanation),todo_list=>$todo,}}sub _make_test_token {my ($self,$line,$ok,$num,$desc,$dir,$explanation)=@_;return {ok=>$ok,test_num=>(defined$num ? 0 + $num : undef),description=>_trim($desc),directive=>(defined$dir ? uc$dir : ''),explanation=>_trim($explanation),raw=>$line,type=>'test',}}sub _make_unknown_token {my ($self,$line)=@_;return {raw=>$line,type=>'unknown',}}sub _make_comment_token {my ($self,$line,$comment)=@_;return {type=>'comment',raw=>$line,comment=>_trim($comment)}}sub _make_bailout_token {my ($self,$line,$explanation)=@_;return {type=>'bailout',raw=>$line,bailout=>_trim($explanation)}}sub _make_yaml_token {my ($self,$pad,$marker)=@_;my$yaml=TAP::Parser::YAMLish::Reader->new;my$iterator=$self->{iterator};my$leader=length($pad);my$strip=qr{ ^ (\s{$leader}) (.*) $ }x;my@extra=($marker);my$reader=sub {return shift@extra if@extra;my$line=$iterator->next;return $2 if$line =~ $strip;return};my$data=$yaml->read($reader);chomp(my$raw=$yaml->get_raw);$raw =~ s/^/$pad/mg;return {type=>'yaml',raw=>$raw,data=>$data }}sub _make_pragma_token {my ($self,$line,$pragmas)=@_;return {type=>'pragma',raw=>$line,pragmas=>[split /\s*,\s*/,_trim($pragmas)],}}sub _trim {my$data=shift;return '' unless defined$data;$data =~ s/^\s+//;$data =~ s/\s+$//;return$data}1;
TAP_PARSER_GRAMMAR

$fatpacked{"TAP/Parser/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR';
  package TAP::Parser::Iterator;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.36';sub next {my$self=shift;my$line=$self->next_raw;if (defined($line)and $line =~ /^\s*not\s*$/){$line .= ($self->next_raw || '')}return$line}sub next_raw {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}sub handle_unicode {}sub get_select_handles {return}sub wait {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}sub exit {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}1;
TAP_PARSER_ITERATOR

$fatpacked{"TAP/Parser/Iterator/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_ARRAY';
  package TAP::Parser::Iterator::Array;use strict;use warnings;use base 'TAP::Parser::Iterator';our$VERSION='3.36';sub _initialize {my ($self,$thing)=@_;chomp @$thing;$self->{idx}=0;$self->{array}=$thing;$self->{exit}=undef;return$self}sub wait {shift->exit}sub exit {my$self=shift;return 0 if$self->{idx}>= @{$self->{array}};return}sub next_raw {my$self=shift;return$self->{array}->[$self->{idx}++ ]}1;
TAP_PARSER_ITERATOR_ARRAY

$fatpacked{"TAP/Parser/Iterator/Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_PROCESS';
  package TAP::Parser::Iterator::Process;use strict;use warnings;use Config;use IO::Handle;use base 'TAP::Parser::Iterator';my$IS_WIN32=($^O =~ /^(MS)?Win32$/);our$VERSION='3.36';{no warnings 'uninitialized';local$SIG{__DIE__}=undef;eval {require POSIX;&POSIX::WEXITSTATUS(0)};if ($@){*_wait2exit=sub {$_[1]>> 8}}else {*_wait2exit=sub {POSIX::WEXITSTATUS($_[1])}}}sub _use_open3 {my$self=shift;return unless$Config{d_fork}|| $IS_WIN32;for my$module (qw(IPC::Open3 IO::Select)){eval "use $module";return if $@}return 1}{my$got_unicode;sub _get_unicode {return$got_unicode if defined$got_unicode;eval 'use Encode qw(decode_utf8);';$got_unicode=$@ ? 0 : 1}}sub _initialize {my ($self,$args)=@_;my@command=@{delete$args->{command}|| []}or die "Must supply a command to execute";$self->{command}=[@command];my$chunk_size=delete$args->{_chunk_size}|| 65536;my$merge=delete$args->{merge};my ($pid,$err,$sel);if (my$setup=delete$args->{setup}){$setup->(@command)}my$out=IO::Handle->new;if ($self->_use_open3){my$xclose=\&IPC::Open3::xclose;no warnings;local*IPC::Open3::xclose=sub {my$fh=shift;no strict 'refs';return if (fileno($fh)==fileno(STDIN));$xclose->($fh)};if ($IS_WIN32){$err=$merge ? '' : '>&STDERR';eval {$pid=open3('<&STDIN',$out,$merge ? '' : $err,@command)};die "Could not execute (@command): $@" if $@;if ($] >= 5.006){binmode($out,":crlf")}}else {$err=$merge ? '' : IO::Handle->new;eval {$pid=open3('<&STDIN',$out,$err,@command)};die "Could not execute (@command): $@" if $@;$sel=$merge ? undef : IO::Select->new($out,$err)}}else {$err='';my$command =join(' ',map {$_ =~ /\s/ ? qq{"$_"} : $_}@command);open($out,"$command|")or die "Could not execute ($command): $!"}$self->{out}=$out;$self->{err}=$err;$self->{sel}=$sel;$self->{pid}=$pid;$self->{exit}=undef;$self->{chunk_size}=$chunk_size;if (my$teardown=delete$args->{teardown}){$self->{teardown}=sub {$teardown->(@command)}}return$self}sub handle_unicode {my$self=shift;if ($self->{sel}){if (_get_unicode()){my$next=$self->{_next}||= $self->_next;$self->{_next}=sub {my$line=$next->();return decode_utf8($line)if defined$line;return}}}else {if ($] >= 5.008){eval 'binmode($self->{out}, ":utf8")'}}}sub wait {shift->{wait}}sub exit {shift->{exit}}sub _next {my$self=shift;if (my$out=$self->{out}){if (my$sel=$self->{sel}){my$err=$self->{err};my@buf=();my$partial='';my$chunk_size=$self->{chunk_size};return sub {return shift@buf if@buf;READ: while (my@ready=$sel->can_read){for my$fh (@ready){my$got=sysread$fh,my ($chunk),$chunk_size;if ($got==0){$sel->remove($fh)}elsif ($fh==$err){print STDERR$chunk}else {$chunk=$partial .$chunk;$partial='';unless (substr($chunk,-1,1)eq "\n"){my$nl=rindex$chunk,"\n";if ($nl==-1){$partial=$chunk;redo READ}else {$partial=substr($chunk,$nl + 1);$chunk=substr($chunk,0,$nl)}}push@buf,split /\n/,$chunk;return shift@buf if@buf}}}if (length$partial){my$last=$partial;$partial='';return$last}$self->_finish;return}}else {return sub {if (defined(my$line=<$out>)){chomp$line;return$line}$self->_finish;return}}}else {return sub {$self->_finish;return}}}sub next_raw {my$self=shift;return ($self->{_next}||= $self->_next)->()}sub _finish {my$self=shift;my$status=$?;$self->{_next}=sub {return}if $] >= 5.006;if (defined$self->{pid}){if ($self->{pid}==waitpid($self->{pid},0)){$status=$?}}(delete$self->{out})->close if$self->{out};if ($self->{sel}){(delete$self->{err})->close;delete$self->{sel}}else {$status=$?}$status=0 if$IS_WIN32 && $status==-1;$self->{wait}=$status;$self->{exit}=$self->_wait2exit($status);if (my$teardown=$self->{teardown}){$teardown->()}return$self}sub get_select_handles {my$self=shift;return grep $_,($self->{out},$self->{err})}1;
TAP_PARSER_ITERATOR_PROCESS

$fatpacked{"TAP/Parser/Iterator/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_STREAM';
  package TAP::Parser::Iterator::Stream;use strict;use warnings;use base 'TAP::Parser::Iterator';our$VERSION='3.36';sub _initialize {my ($self,$thing)=@_;$self->{fh}=$thing;return$self}sub wait {shift->exit}sub exit {shift->{fh}? (): 0}sub next_raw {my$self=shift;my$fh=$self->{fh};if (defined(my$line=<$fh>)){chomp$line;return$line}else {$self->_finish;return}}sub _finish {my$self=shift;close delete$self->{fh}}1;
TAP_PARSER_ITERATOR_STREAM

$fatpacked{"TAP/Parser/IteratorFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATORFACTORY';
  package TAP::Parser::IteratorFactory;use strict;use warnings;use Carp qw(confess);use File::Basename qw(fileparse);use base 'TAP::Object';use constant handlers=>[];our$VERSION='3.36';sub _initialize {my ($self,$config)=@_;$self->config($config || {})->load_handlers;return$self}sub register_handler {my ($class,$dclass)=@_;confess("$dclass must implement can_handle & make_iterator methods!")unless UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');my$handlers=$class->handlers;push @{$handlers},$dclass unless grep {$_ eq $dclass}@{$handlers};return$class}sub config {my$self=shift;return$self->{config}unless @_;unless ('HASH' eq ref $_[0]){$self->_croak('Argument to &config must be a hash reference')}$self->{config}=shift;return$self}sub _last_handler {my$self=shift;return$self->{last_handler}unless @_;$self->{last_handler}=shift;return$self}sub _testing {my$self=shift;return$self->{testing}unless @_;$self->{testing}=shift;return$self}sub load_handlers {my ($self)=@_;for my$handler (keys %{$self->config}){my$sclass=$self->_load_handler($handler)}return$self}sub _load_handler {my ($self,$handler)=@_;my@errors;for my$dclass ("TAP::Parser::SourceHandler::$handler",$handler){return$dclass if UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');eval "use $dclass";if (my$e=$@){push@errors,$e;next}return$dclass if UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');push@errors,"handler '$dclass' does not implement can_handle & make_iterator"}$self->_croak("Cannot load handler '$handler': " .join("\n",@errors))}sub make_iterator {my ($self,$source)=@_;$self->_croak('no raw source defined!')unless defined$source->raw;$source->config($self->config)->assemble_meta;return$source->raw if ($source->meta->{is_object}&& UNIVERSAL::isa($source->raw,'TAP::Parser::SourceHandler'));my$sd_class=$self->detect_source($source);$self->_last_handler($sd_class);return if$self->_testing;my$iterator=$sd_class->make_iterator($source);return$iterator}sub detect_source {my ($self,$source)=@_;confess('no raw source ref defined!')unless defined$source->raw;my%handlers;for my$dclass (@{$self->handlers}){my$confidence=$dclass->can_handle($source);$handlers{$dclass}=$confidence if$confidence}if (!%handlers){my$raw_source_short=substr(${$source->raw},0,50);confess("Cannot detect source of '$raw_source_short'!");return}my@handlers=(map {$_}sort {$handlers{$a}cmp $handlers{$b}}keys%handlers);if ($ENV{TAP_HARNESS_SOURCE_FACTORY_VOTES}){warn("votes: ",join(', ',map {"$_: $handlers{$_}"}@handlers),"\n")}return pop@handlers}1;
TAP_PARSER_ITERATORFACTORY

$fatpacked{"TAP/Parser/Multiplexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_MULTIPLEXER';
  package TAP::Parser::Multiplexer;use strict;use warnings;use IO::Select;use base 'TAP::Object';use constant IS_WIN32=>$^O =~ /^(MS)?Win32$/;use constant IS_VMS=>$^O eq 'VMS';use constant SELECT_OK=>!(IS_VMS || IS_WIN32);our$VERSION='3.36';sub _initialize {my$self=shift;$self->{select}=IO::Select->new;$self->{avid}=[];$self->{count}=0;return$self}sub add {my ($self,$parser,$stash)=@_;if (SELECT_OK && (my@handles=$parser->get_select_handles)){my$sel=$self->{select};my@filenos=map {fileno $_}@handles;for my$h (@handles){$sel->add([$h,$parser,$stash,@filenos ])}$self->{count}++}else {push @{$self->{avid}},[$parser,$stash ]}}sub parsers {my$self=shift;return$self->{count}+ scalar @{$self->{avid}}}sub _iter {my$self=shift;my$sel=$self->{select};my$avid=$self->{avid};my@ready=();return sub {if (@$avid){my ($parser,$stash)=@{$avid->[0]};my$result=$parser->next;shift @$avid unless defined$result;return ($parser,$stash,$result)}unless (@ready){return unless$sel->count;@ready=$sel->can_read}my ($h,$parser,$stash,@handles)=@{shift@ready};my$result=$parser->next;unless (defined$result){$sel->remove(@handles);$self->{count}--;@ready=()}return ($parser,$stash,$result)}}sub next {my$self=shift;return ($self->{_iter}||= $self->_iter)->()}1;
TAP_PARSER_MULTIPLEXER

$fatpacked{"TAP/Parser/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT';
  package TAP::Parser::Result;use strict;use warnings;use base 'TAP::Object';BEGIN {my@attrs=qw(plan pragma test comment bailout version unknown yaml);no strict 'refs';for my$token (@attrs){my$method="is_$token";*$method=sub {return$token eq shift->type}}}our$VERSION='3.36';sub _initialize {my ($self,$token)=@_;if ($token){@{$self}{keys %$token }=values %$token}return$self}sub raw {shift->{raw}}sub type {shift->{type}}sub as_string {shift->{raw}}sub is_ok {1}sub passed {warn 'passed() is deprecated.  Please use "is_ok()"';shift->is_ok}sub has_directive {my$self=shift;return ($self->has_todo || $self->has_skip)}sub has_todo {'TODO' eq (shift->{directive}|| '')}sub has_skip {'SKIP' eq (shift->{directive}|| '')}sub set_directive {my ($self,$dir)=@_;$self->{directive}=$dir}1;
TAP_PARSER_RESULT

$fatpacked{"TAP/Parser/Result/Bailout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_BAILOUT';
  package TAP::Parser::Result::Bailout;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.36';sub explanation {shift->{bailout}}sub as_string {shift->{bailout}}1;
TAP_PARSER_RESULT_BAILOUT

$fatpacked{"TAP/Parser/Result/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_COMMENT';
  package TAP::Parser::Result::Comment;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.36';sub comment {shift->{comment}}sub as_string {shift->{raw}}1;
TAP_PARSER_RESULT_COMMENT

$fatpacked{"TAP/Parser/Result/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PLAN';
  package TAP::Parser::Result::Plan;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.36';sub plan {'1..' .shift->{tests_planned}}sub tests_planned {shift->{tests_planned}}sub directive {shift->{directive}}sub explanation {shift->{explanation}}sub todo_list {shift->{todo_list}}1;
TAP_PARSER_RESULT_PLAN

$fatpacked{"TAP/Parser/Result/Pragma.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PRAGMA';
  package TAP::Parser::Result::Pragma;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.36';sub pragmas {my@pragmas=@{shift->{pragmas}};return wantarray ? @pragmas : \@pragmas}1;
TAP_PARSER_RESULT_PRAGMA

$fatpacked{"TAP/Parser/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_TEST';
  package TAP::Parser::Result::Test;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.36';sub ok {shift->{ok}}sub number {shift->{test_num}}sub _number {my ($self,$number)=@_;$self->{test_num}=$number}sub description {shift->{description}}sub directive {shift->{directive}}sub explanation {shift->{explanation}}sub is_ok {my$self=shift;return if$self->is_unplanned;return$self->has_todo ? 1 : $self->ok !~ /not/}sub is_actual_ok {my$self=shift;return$self->{ok}!~ /not/}sub actual_passed {warn 'actual_passed() is deprecated.  Please use "is_actual_ok()"';goto&is_actual_ok}sub todo_passed {my$self=shift;return$self->has_todo && $self->is_actual_ok}sub todo_failed {warn 'todo_failed() is deprecated.  Please use "todo_passed()"';goto&todo_passed}sub as_string {my$self=shift;my$string=$self->ok ." " .$self->number;if (my$description=$self->description){$string .= " $description"}if (my$directive=$self->directive){my$explanation=$self->explanation;$string .= " # $directive $explanation"}return$string}sub is_unplanned {my$self=shift;return ($self->{unplanned}|| '')unless @_;$self->{unplanned}=!!shift;return$self}1;
TAP_PARSER_RESULT_TEST

$fatpacked{"TAP/Parser/Result/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_UNKNOWN';
  package TAP::Parser::Result::Unknown;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.36';1;
TAP_PARSER_RESULT_UNKNOWN

$fatpacked{"TAP/Parser/Result/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_VERSION';
  package TAP::Parser::Result::Version;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.36';sub version {shift->{version}}1;
TAP_PARSER_RESULT_VERSION

$fatpacked{"TAP/Parser/Result/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_YAML';
  package TAP::Parser::Result::YAML;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.36';sub data {shift->{data}}1;
TAP_PARSER_RESULT_YAML

$fatpacked{"TAP/Parser/ResultFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULTFACTORY';
  package TAP::Parser::ResultFactory;use strict;use warnings;use TAP::Parser::Result::Bailout ();use TAP::Parser::Result::Comment ();use TAP::Parser::Result::Plan ();use TAP::Parser::Result::Pragma ();use TAP::Parser::Result::Test ();use TAP::Parser::Result::Unknown ();use TAP::Parser::Result::Version ();use TAP::Parser::Result::YAML ();use base 'TAP::Object';our$VERSION='3.36';sub make_result {my ($proto,$token)=@_;my$type=$token->{type};return$proto->class_for($type)->new($token)}our%CLASS_FOR=(plan=>'TAP::Parser::Result::Plan',pragma=>'TAP::Parser::Result::Pragma',test=>'TAP::Parser::Result::Test',comment=>'TAP::Parser::Result::Comment',bailout=>'TAP::Parser::Result::Bailout',version=>'TAP::Parser::Result::Version',unknown=>'TAP::Parser::Result::Unknown',yaml=>'TAP::Parser::Result::YAML',);sub class_for {my ($class,$type)=@_;return$CLASS_FOR{$type}if exists$CLASS_FOR{$type};require Carp;Carp::croak("Could not determine class for result type '$type'")}sub register_type {my ($class,$type,$rclass)=@_;$CLASS_FOR{$type}=$rclass;return$class}1;
TAP_PARSER_RESULTFACTORY

$fatpacked{"TAP/Parser/Scheduler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER';
  package TAP::Parser::Scheduler;use strict;use warnings;use Carp;use TAP::Parser::Scheduler::Job;use TAP::Parser::Scheduler::Spinner;our$VERSION='3.36';sub new {my$class=shift;croak "Need a number of key, value pairs" if @_ % 2;my%args=@_;my$tests=delete$args{tests}|| croak "Need a 'tests' argument";my$rules=delete$args{rules}|| {par=>'**' };croak "Unknown arg(s): ",join ', ',sort keys%args if keys%args;my$self=bless {},$class;$self->_set_rules($rules,$tests);return$self}sub _set_rules {my ($self,$rules,$tests)=@_;my@tests=map {TAP::Parser::Scheduler::Job->new(@$_)}map {'ARRAY' eq ref $_ ? $_ : [$_,$_ ]}@$tests;my$schedule=$self->_rule_clause($rules,\@tests);$schedule=[[$schedule,@tests ]]if@tests;$self->{schedule}=$schedule}sub _rule_clause {my ($self,$rule,$tests)=@_;croak 'Rule clause must be a hash' unless 'HASH' eq ref$rule;my@type=keys %$rule;croak 'Rule clause must have exactly one key' unless@type==1;my%handlers=(par=>sub {[map {[$_]}@_ ]},seq=>sub {[[@_]]},);my$handler=$handlers{$type[0]}|| croak 'Unknown scheduler type: ',$type[0];my$val=$rule->{$type[0]};return$handler->(map {'HASH' eq ref $_ ? $self->_rule_clause($_,$tests): $self->_expand($_,$tests)}'ARRAY' eq ref$val ? @$val : $val)}sub _glob_to_regexp {my ($self,$glob)=@_;my$nesting;my$pattern;while (1){if ($glob =~ /\G\*\*/gc){$pattern .= '.*?'}elsif ($glob =~ /\G\*/gc){$pattern .= '[^/]*'}elsif ($glob =~ /\G\?/gc){$pattern .= '[^/]'}elsif ($glob =~ /\G\{/gc){$pattern .= '(?:';++$nesting}elsif ($nesting and $glob =~ /\G,/gc){$pattern .= '|'}elsif ($nesting and $glob =~ /\G\}/gc){$pattern .= ')';--$nesting}elsif ($glob =~ /\G(\\.)/gc){$pattern .= $1}elsif ($glob =~ /\G([\},])/gc){$pattern .= '\\' .$1}else {$glob =~ /\G([^{?*\\\},]*)/gc;$pattern .= quotemeta $1}return$pattern if pos$glob==length$glob}}sub _expand {my ($self,$name,$tests)=@_;my$pattern=$self->_glob_to_regexp($name);$pattern=qr/^ $pattern $/x;my@match=();for (my$ti=0;$ti < @$tests;$ti++ ){if ($tests->[$ti]->filename =~ $pattern){push@match,splice @$tests,$ti,1;$ti--}}return@match}sub get_all {my$self=shift;my@all=$self->_gather($self->{schedule});$self->{count}=@all;@all}sub _gather {my ($self,$rule)=@_;return unless defined$rule;return$rule unless 'ARRAY' eq ref$rule;return map {defined()? $self->_gather($_): ()}map {@$_}@$rule}sub get_job {my$self=shift;$self->{count}||= $self->get_all;my@jobs=$self->_find_next_job($self->{schedule});if (@jobs){--$self->{count};return$jobs[0]}return TAP::Parser::Scheduler::Spinner->new if$self->{count};return}sub _not_empty {my$ar=shift;return 1 unless 'ARRAY' eq ref$ar;for (@$ar){return 1 if _not_empty($_)}return}sub _is_empty {!_not_empty(@_)}sub _find_next_job {my ($self,$rule)=@_;my@queue=();my$index=0;while ($index < @$rule){my$seq=$rule->[$index];shift @$seq while @$seq && _is_empty($seq->[0]);if (@$seq){if (defined$seq->[0]){if ('ARRAY' eq ref$seq->[0]){push@queue,$seq}else {my$job=splice @$seq,0,1,undef;$job->on_finish(sub {shift @$seq});return$job}}++$index}else {splice @$rule,$index,1}}for my$seq (@queue){if (my@jobs=$self->_find_next_job($seq->[0])){return@jobs}}return}sub as_string {my$self=shift;return$self->_as_string($self->{schedule})}sub _as_string {my ($self,$rule,$depth)=(shift,shift,shift || 0);my$pad=' ' x 2;my$indent=$pad x $depth;if (!defined$rule){return "$indent(undef)\n"}elsif ('ARRAY' eq ref$rule){return unless @$rule;my$type=('par','seq')[$depth % 2 ];return join('',"$indent$type:\n",map {$self->_as_string($_,$depth + 1)}@$rule)}else {return "$indent'" .$rule->filename ."'\n"}}1;
TAP_PARSER_SCHEDULER

$fatpacked{"TAP/Parser/Scheduler/Job.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_JOB';
  package TAP::Parser::Scheduler::Job;use strict;use warnings;use Carp;our$VERSION='3.36';sub new {my ($class,$name,$desc,@ctx)=@_;return bless {filename=>$name,description=>$desc,@ctx ? (context=>\@ctx): (),},$class}sub on_finish {my ($self,$cb)=@_;$self->{on_finish}=$cb}sub finish {my$self=shift;if (my$cb=$self->{on_finish}){$cb->($self)}}sub filename {shift->{filename}}sub description {shift->{description}}sub context {@{shift->{context}|| []}}sub as_array_ref {my$self=shift;return [$self->filename,$self->description,$self->{context}||= []]}sub is_spinner {0}1;
TAP_PARSER_SCHEDULER_JOB

$fatpacked{"TAP/Parser/Scheduler/Spinner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_SPINNER';
  package TAP::Parser::Scheduler::Spinner;use strict;use warnings;use Carp;our$VERSION='3.36';sub new {bless {},shift}sub is_spinner {1}1;
TAP_PARSER_SCHEDULER_SPINNER

$fatpacked{"TAP/Parser/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCE';
  package TAP::Parser::Source;use strict;use warnings;use File::Basename qw(fileparse);use base 'TAP::Object';use constant BLK_SIZE=>512;our$VERSION='3.36';sub _initialize {my ($self)=@_;$self->meta({});$self->config({});return$self}sub raw {my$self=shift;return$self->{raw}unless @_;$self->{raw}=shift;return$self}sub meta {my$self=shift;return$self->{meta}unless @_;$self->{meta}=shift;return$self}sub has_meta {return scalar %{shift->meta}? 1 : 0}sub config {my$self=shift;return$self->{config}unless @_;$self->{config}=shift;return$self}sub merge {my$self=shift;return$self->{merge}unless @_;$self->{merge}=shift;return$self}sub switches {my$self=shift;return$self->{switches}unless @_;$self->{switches}=shift;return$self}sub test_args {my$self=shift;return$self->{test_args}unless @_;$self->{test_args}=shift;return$self}sub assemble_meta {my ($self)=@_;return$self->meta if$self->has_meta;my$meta=$self->meta;my$raw=$self->raw;$meta->{is_object}=UNIVERSAL::isa($raw,'UNIVERSAL')? 1 : 0;if ($meta->{is_object}){$meta->{class}=ref($raw)}else {my$ref=lc(ref($raw));$meta->{"is_$ref"}=1}if ($meta->{is_scalar}){my$source=$$raw;$meta->{length}=length($$raw);$meta->{has_newlines}=$$raw =~ /\n/ ? 1 : 0;if (!$meta->{has_newlines}and $meta->{length}< 1024){my$file={};$file->{exists}=-e $source ? 1 : 0;if ($file->{exists}){$meta->{file}=$file;$file->{stat}=[stat(_)];$file->{empty}=-z _ ? 1 : 0;$file->{size}=-s _;$file->{text}=-T _ ? 1 : 0;$file->{binary}=-B _ ? 1 : 0;$file->{read}=-r _ ? 1 : 0;$file->{write}=-w _ ? 1 : 0;$file->{execute}=-x _ ? 1 : 0;$file->{setuid}=-u _ ? 1 : 0;$file->{setgid}=-g _ ? 1 : 0;$file->{sticky}=-k _ ? 1 : 0;$meta->{is_file}=$file->{is_file}=-f _ ? 1 : 0;$meta->{is_dir}=$file->{is_dir}=-d _ ? 1 : 0;$meta->{is_symlink}=$file->{is_symlink}=-l $source ? 1 : 0;if ($file->{is_symlink}){$file->{lstat}=[lstat(_)]}($file->{basename},$file->{dir},$file->{ext})=map {defined $_ ? $_ : ''}fileparse($source,qr/\.[^.]*/);$file->{lc_ext}=lc($file->{ext});$file->{basename}.= $file->{ext}if$file->{ext};if (!$file->{is_dir}&& $file->{read}){eval {$file->{shebang}=$self->shebang($$raw)};if (my$e=$@){warn$e}}}}}elsif ($meta->{is_array}){$meta->{size}=$#$raw + 1}elsif ($meta->{is_hash}){}return$meta}{my%shebang_for;sub _read_shebang {my ($class,$file)=@_;open my$fh,'<',$file or die "Can't read $file: $!\n";my$got=read$fh,my ($buf),BLK_SIZE;defined$got or die "I/O error: $!\n";return $1 if$buf =~ /(.*)/;return}sub shebang {my ($class,$file)=@_;$shebang_for{$file}=$class->_read_shebang($file)unless exists$shebang_for{$file};return$shebang_for{$file}}}sub config_for {my ($self,$class)=@_;my ($abbrv_class)=($class =~ /(?:\:\:)?(\w+)$/);my$config=$self->config->{$abbrv_class}|| $self->config->{$class};return$config}1;
TAP_PARSER_SOURCE

$fatpacked{"TAP/Parser/SourceHandler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER';
  package TAP::Parser::SourceHandler;use strict;use warnings;use TAP::Parser::Iterator ();use base 'TAP::Object';our$VERSION='3.36';sub can_handle {my ($class,$args)=@_;$class->_croak("Abstract method 'can_handle' not implemented for $class!");return}sub make_iterator {my ($class,$args)=@_;$class->_croak("Abstract method 'make_iterator' not implemented for $class!");return}1;
TAP_PARSER_SOURCEHANDLER

$fatpacked{"TAP/Parser/SourceHandler/Executable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_EXECUTABLE';
  package TAP::Parser::SourceHandler::Executable;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Process ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.36';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;if ($meta->{is_file}){my$file=$meta->{file};return 0.85 if$file->{execute}&& $file->{binary};return 0.8 if$file->{lc_ext}eq '.bat';return 0.25 if$file->{execute}}elsif ($meta->{is_hash}){return 0.9 if$src->raw->{exec}}return 0}sub make_iterator {my ($class,$source)=@_;my$meta=$source->meta;my@command;if ($meta->{is_hash}){@command=@{$source->raw->{exec}|| []}}elsif ($meta->{is_scalar}){@command=${$source->raw}}elsif ($meta->{is_array}){@command=@{$source->raw}}$class->_croak('No command found in $source->raw!')unless@command;$class->_autoflush(\*STDOUT);$class->_autoflush(\*STDERR);push@command,@{$source->test_args || []};return$class->iterator_class->new({command=>\@command,merge=>$source->merge })}use constant iterator_class=>'TAP::Parser::Iterator::Process';sub _autoflush {my ($class,$flushed)=@_;my$old_fh=select$flushed;$|=1;select$old_fh}1;
TAP_PARSER_SOURCEHANDLER_EXECUTABLE

$fatpacked{"TAP/Parser/SourceHandler/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_FILE';
  package TAP::Parser::SourceHandler::File;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Stream ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.36';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;my$config=$src->config_for($class);return 0 unless$meta->{is_file};my$file=$meta->{file};return 0.9 if$file->{lc_ext}eq '.tap';if (my$exts=$config->{extensions}){return 0.9 if grep {lc($_)eq $file->{lc_ext}}@$exts}return 0}sub make_iterator {my ($class,$source)=@_;$class->_croak('$source->raw must be a scalar ref')unless$source->meta->{is_scalar};my$file=${$source->raw};my$fh;open($fh,'<',$file)or $class->_croak("error opening TAP source file '$file': $!");return$class->iterator_class->new($fh)}use constant iterator_class=>'TAP::Parser::Iterator::Stream';1;
TAP_PARSER_SOURCEHANDLER_FILE

$fatpacked{"TAP/Parser/SourceHandler/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_HANDLE';
  package TAP::Parser::SourceHandler::Handle;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Stream ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.36';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;return 0.9 if$meta->{is_object}&& UNIVERSAL::isa($src->raw,'IO::Handle');return 0.8 if$meta->{is_glob};return 0}sub make_iterator {my ($class,$source)=@_;$class->_croak('$source->raw must be a glob ref or an IO::Handle')unless$source->meta->{is_glob}|| UNIVERSAL::isa($source->raw,'IO::Handle');return$class->iterator_class->new($source->raw)}use constant iterator_class=>'TAP::Parser::Iterator::Stream';1;
TAP_PARSER_SOURCEHANDLER_HANDLE

$fatpacked{"TAP/Parser/SourceHandler/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_PERL';
  package TAP::Parser::SourceHandler::Perl;use strict;use warnings;use Config;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>($^O eq 'VMS');use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Process ();use Text::ParseWords qw(shellwords);use base 'TAP::Parser::SourceHandler::Executable';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.36';sub can_handle {my ($class,$source)=@_;my$meta=$source->meta;return 0 unless$meta->{is_file};my$file=$meta->{file};if (my$shebang=$file->{shebang}){return 0.9 if$shebang =~ /^#!.*\bperl/;return 0.3}return 0.8 if$file->{lc_ext}eq '.t';return 0.9 if$file->{lc_ext}eq '.pl';return 0.75 if$file->{dir}=~ /^t\b/;return 0.25}sub _autoflush_stdhandles {my ($class)=@_;$class->_autoflush(\*STDOUT);$class->_autoflush(\*STDERR)}sub make_iterator {my ($class,$source)=@_;my$meta=$source->meta;my$perl_script=${$source->raw};$class->_croak("Cannot find ($perl_script)")unless$meta->{is_file};$class->_autoflush_stdhandles;my ($libs,$switches)=$class->_mangle_switches($class->_filter_libs($class->_switches($source)));$class->_run($source,$libs,$switches)}sub _has_taint_switch {my($class,$switches)=@_;my$has_taint=grep {$_ eq "-T" || $_ eq "-t"}@{$switches};return$has_taint ? 1 : 0}sub _mangle_switches {my ($class,$libs,$switches)=@_;if ($class->_has_taint_switch($switches)){my@perl5lib=defined$ENV{PERL5LIB}? split /$Config{path_sep}/,$ENV{PERL5LIB}: ();return ($libs,[@{$switches},$class->_libs2switches([@$libs,@perl5lib]),defined$ENV{PERL5OPT}? shellwords($ENV{PERL5OPT}): ()],)}return ($libs,$switches)}sub _filter_libs {my ($class,@switches)=@_;my$path_sep=$Config{path_sep};my$path_re=qr{$path_sep};my@libs;my@filtered_switches;for (@switches){if (!/$path_re/ && m/ ^ ['"]? -I ['"]? (.*?) ['"]? $ /x){push@libs,$1}else {push@filtered_switches,$_}}return \@libs,\@filtered_switches}sub _iterator_hooks {my ($class,$source,$libs,$switches)=@_;my$setup=sub {if (@{$libs}and!$class->_has_taint_switch($switches)){$ENV{PERL5LIB}=join($Config{path_sep},grep {defined}@{$libs},$ENV{PERL5LIB})}};my$previous=$ENV{PERL5LIB};my$teardown=sub {if (defined$previous){$ENV{PERL5LIB}=$previous}else {delete$ENV{PERL5LIB}}};return ($setup,$teardown)}sub _run {my ($class,$source,$libs,$switches)=@_;my@command=$class->_get_command_for_switches($source,$switches)or $class->_croak("No command found!");my ($setup,$teardown)=$class->_iterator_hooks($source,$libs,$switches);return$class->_create_iterator($source,\@command,$setup,$teardown)}sub _create_iterator {my ($class,$source,$command,$setup,$teardown)=@_;return TAP::Parser::Iterator::Process->new({command=>$command,merge=>$source->merge,setup=>$setup,teardown=>$teardown,})}sub _get_command_for_switches {my ($class,$source,$switches)=@_;my$file=${$source->raw};my@args=@{$source->test_args || []};my$command=$class->get_perl;my@command=($command,@{$switches},$file,@args);return@command}sub _libs2switches {my$class=shift;return map {"-I$_"}grep {$_}@{$_[0]}}sub get_taint {my ($class,$shebang)=@_;return unless defined$shebang && $shebang =~ /^#!.*\bperl.*\s-\w*([Tt]+)/;return $1}sub _switches {my ($class,$source)=@_;my$file=${$source->raw};my@switches=@{$source->switches || []};my$shebang=$source->meta->{file}->{shebang};return unless defined$shebang;my$taint=$class->get_taint($shebang);push@switches,"-$taint" if defined$taint;if (IS_VMS){for (@switches){$_=qq["$_"]}}return@switches}sub get_perl {my$class=shift;return$ENV{HARNESS_PERL}if defined$ENV{HARNESS_PERL};return qq["$^X"] if IS_WIN32 && ($^X =~ /[^\w\.\/\\]/);return $^X}1;
TAP_PARSER_SOURCEHANDLER_PERL

$fatpacked{"TAP/Parser/SourceHandler/RawTAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_RAWTAP';
  package TAP::Parser::SourceHandler::RawTAP;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Array ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.36';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;return 0 if$meta->{file};if ($meta->{is_scalar}){return 0 unless$meta->{has_newlines};return 0.9 if ${$src->raw}=~ /\d\.\.\d/;return 0.7 if ${$src->raw}=~ /ok/;return 0.3}elsif ($meta->{is_array}){return 0.5}return 0}sub make_iterator {my ($class,$src)=@_;my$meta=$src->meta;my$tap_array;if ($meta->{is_scalar}){$tap_array=[split "\n"=>${$src->raw}]}elsif ($meta->{is_array}){$tap_array=$src->raw}$class->_croak('No raw TAP found in $source->raw')unless scalar$tap_array;return TAP::Parser::Iterator::Array->new($tap_array)}1;
TAP_PARSER_SOURCEHANDLER_RAWTAP

$fatpacked{"TAP/Parser/YAMLish/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_READER';
  package TAP::Parser::YAMLish::Reader;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.36';my%UNESCAPES=(z=>"\x00",a=>"\x07",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my$QQ_STRING=qr{ " (?:\\. | [^"])* " }x;my$HASH_LINE=qr{ ^ ($QQ_STRING|\S+) \s* : \s* (?: (.+?) \s* )? $ }x;my$IS_HASH_KEY=qr{ ^ [\w\'\"] }x;my$IS_END_YAML=qr{ ^ \.\.\. \s* $ }x;my$IS_QQ_STRING=qr{ ^ $QQ_STRING $ }x;sub read {my$self=shift;my$obj=shift;die "Must have a code reference to read input from" unless ref$obj eq 'CODE';$self->{reader}=$obj;$self->{capture}=[];$self->_next;return unless$self->{next};my$doc=$self->_read;my$dots=$self->_peek;die "Missing '...' at end of YAMLish" unless defined$dots and $dots =~ $IS_END_YAML;delete$self->{reader};delete$self->{next};return$doc}sub get_raw {join("\n",grep defined,@{shift->{capture}|| []})."\n"}sub _peek {my$self=shift;return$self->{next}unless wantarray;my$line=$self->{next};$line =~ /^ (\s*) (.*) $ /x;return ($2,length $1)}sub _next {my$self=shift;die "_next called with no reader" unless$self->{reader};my$line=$self->{reader}->();$self->{next}=$line;push @{$self->{capture}},$line}sub _read {my$self=shift;my$line=$self->_peek;if ($line =~ /^ --- (?: \s* (.+?)? \s* )? $/x){$self->_next;return$self->_read_scalar($1)if defined $1;my ($next,$indent)=$self->_peek;if ($next =~ /^ - /x){return$self->_read_array($indent)}elsif ($next =~ $IS_HASH_KEY){return$self->_read_hash($next,$indent)}elsif ($next =~ $IS_END_YAML){die "Premature end of YAMLish"}else {die "Unsupported YAMLish syntax: '$next'"}}else {die "YAMLish document header not found"}}sub _read_qq {my$self=shift;my$str=shift;unless ($str =~ s/^ " (.*?) " $/$1/x){die "Internal: not a quoted string"}$str =~ s/\\"/"/gx;$str =~ s/ \\ ( [tartan\\favez] | x([0-9a-fA-F]{2}) ) 
                   / (length($1) > 1) ? pack("H2", $2) : $UNESCAPES{$1} /gex;return$str}sub _read_scalar {my$self=shift;my$string=shift;return undef if$string eq '~';return {}if$string eq '{}';return []if$string eq '[]';if ($string eq '>' || $string eq '|'){my ($line,$indent)=$self->_peek;die "Multi-line scalar content missing" unless defined$line;my@multiline=($line);while (1){$self->_next;my ($next,$ind)=$self->_peek;last if$ind < $indent;my$pad=$string eq '|' ? (' ' x ($ind - $indent)): '';push@multiline,$pad .$next}return join(($string eq '>' ? ' ' : "\n"),@multiline)."\n"}if ($string =~ /^ ' (.*) ' $/x){(my$rv=$1)=~ s/''/'/g;return$rv}if ($string =~ $IS_QQ_STRING){return$self->_read_qq($string)}if ($string =~ /^['"]/){die __PACKAGE__ ." does not support multi-line quoted scalars"}return$string}sub _read_nested {my$self=shift;my ($line,$indent)=$self->_peek;if ($line =~ /^ -/x){return$self->_read_array($indent)}elsif ($line =~ $IS_HASH_KEY){return$self->_read_hash($line,$indent)}else {die "Unsupported YAMLish syntax: '$line'"}}sub _read_array {my ($self,$limit)=@_;my$ar=[];while (1){my ($line,$indent)=$self->_peek;last if$indent < $limit ||!defined$line || $line =~ $IS_END_YAML;if ($indent > $limit){die "Array line over-indented"}if ($line =~ /^ (- \s+) \S+ \s* : (?: \s+ | $ ) /x){$indent += length $1;$line =~ s/-\s+//;push @$ar,$self->_read_hash($line,$indent)}elsif ($line =~ /^ - \s* (.+?) \s* $/x){die "Unexpected start of YAMLish" if$line =~ /^---/;$self->_next;push @$ar,$self->_read_scalar($1)}elsif ($line =~ /^ - \s* $/x){$self->_next;push @$ar,$self->_read_nested}elsif ($line =~ $IS_HASH_KEY){$self->_next;push @$ar,$self->_read_hash($line,$indent,)}else {die "Unsupported YAMLish syntax: '$line'"}}return$ar}sub _read_hash {my ($self,$line,$limit)=@_;my$indent;my$hash={};while (1){die "Badly formed hash line: '$line'" unless$line =~ $HASH_LINE;my ($key,$value)=($self->_read_scalar($1),$2);$self->_next;if (defined$value){$hash->{$key}=$self->_read_scalar($value)}else {$hash->{$key}=$self->_read_nested}($line,$indent)=$self->_peek;last if$indent < $limit ||!defined$line || $line =~ $IS_END_YAML}return$hash}1;
TAP_PARSER_YAMLISH_READER

$fatpacked{"TAP/Parser/YAMLish/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_WRITER';
  package TAP::Parser::YAMLish::Writer;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.36';my$ESCAPE_CHAR=qr{ [ \x00-\x1f \" ] }x;my$ESCAPE_KEY=qr{ (?: ^\W ) | $ESCAPE_CHAR }x;my@UNPRINTABLE=qw(z x01 x02 x03 x04 x05 x06 a x08 t n v f r x0e x0f x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1a e x1c x1d x1e x1f);sub write {my$self=shift;die "Need something to write" unless @_;my$obj=shift;my$out=shift || \*STDOUT;die "Need a reference to something I can write to" unless ref$out;$self->{writer}=$self->_make_writer($out);$self->_write_obj('---',$obj);$self->_put('...');delete$self->{writer}}sub _make_writer {my$self=shift;my$out=shift;my$ref=ref$out;if ('CODE' eq $ref){return$out}elsif ('ARRAY' eq $ref){return sub {push @$out,shift}}elsif ('SCALAR' eq $ref){return sub {$$out .= shift()."\n"}}elsif ('GLOB' eq $ref || 'IO::Handle' eq $ref){return sub {print$out shift(),"\n"}}die "Can't write to $out"}sub _put {my$self=shift;$self->{writer}->(join '',@_)}sub _enc_scalar {my$self=shift;my$val=shift;my$rule=shift;return '~' unless defined$val;if ($val =~ /$rule/){$val =~ s/\\/\\\\/g;$val =~ s/"/\\"/g;$val =~ s/ ( [\x00-\x1f] ) / '\\' . $UNPRINTABLE[ ord($1) ] /gex;return qq{"$val"}}if (length($val)==0 or $val =~ /\s/){$val =~ s/'/''/;return "'$val'"}return$val}sub _write_obj {my$self=shift;my$prefix=shift;my$obj=shift;my$indent=shift || 0;if (my$ref=ref$obj){my$pad='  ' x $indent;if ('HASH' eq $ref){if (keys %$obj){$self->_put($prefix);for my$key (sort keys %$obj){my$value=$obj->{$key};$self->_write_obj($pad .$self->_enc_scalar($key,$ESCAPE_KEY).':',$value,$indent + 1)}}else {$self->_put($prefix,' {}')}}elsif ('ARRAY' eq $ref){if (@$obj){$self->_put($prefix);for my$value (@$obj){$self->_write_obj($pad .'-',$value,$indent + 1)}}else {$self->_put($prefix,' []')}}else {die "Don't know how to encode $ref"}}else {$self->_put($prefix,' ',$self->_enc_scalar($obj,$ESCAPE_CHAR))}}1;
TAP_PARSER_YAMLISH_WRITER

$fatpacked{"Test/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_HARNESS';
  package Test::Harness;use 5.006;use strict;use warnings;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>($^O eq 'VMS');use TAP::Harness ();use TAP::Parser::Aggregator ();use TAP::Parser::Source ();use TAP::Parser::SourceHandler::Perl ();use Text::ParseWords qw(shellwords);use Config;use base 'Exporter';BEGIN {eval q{use Time::HiRes 'time'};our$has_time_hires=!$@}our$VERSION='3.36';*verbose=*Verbose;*switches=*Switches;*debug=*Debug;$ENV{HARNESS_ACTIVE}=1;$ENV{HARNESS_VERSION}=$VERSION;END {delete$ENV{HARNESS_ACTIVE};delete$ENV{HARNESS_VERSION}}our@EXPORT=qw(&runtests);our@EXPORT_OK=qw(&execute_tests $verbose $switches);our$Verbose=$ENV{HARNESS_VERBOSE}|| 0;our$Debug=$ENV{HARNESS_DEBUG}|| 0;our$Switches='-w';our$Columns=$ENV{HARNESS_COLUMNS}|| $ENV{COLUMNS}|| 80;$Columns--;our$Timer=$ENV{HARNESS_TIMER}|| 0;our$Color=$ENV{HARNESS_COLOR}|| 0;our$IgnoreExit=$ENV{HARNESS_IGNORE_EXIT}|| 0;sub _has_taint {my$test=shift;return TAP::Parser::SourceHandler::Perl->get_taint(TAP::Parser::Source->shebang($test))}sub _aggregate {my ($harness,$aggregate,@tests)=@_;local$ENV{HARNESS_OPTIONS};_apply_extra_INC($harness);_aggregate_tests($harness,$aggregate,@tests)}sub _apply_extra_INC {my$harness=shift;$harness->callback(parser_args=>sub {my ($args,$test)=@_;push @{$args->{switches}},map {"-I$_"}_filtered_inc()})}sub _aggregate_tests {my ($harness,$aggregate,@tests)=@_;$aggregate->start();$harness->aggregate_tests($aggregate,@tests);$aggregate->stop()}sub runtests {my@tests=@_;local ($\,$,);my$harness=_new_harness();my$aggregate=TAP::Parser::Aggregator->new();_aggregate($harness,$aggregate,@tests);$harness->formatter->summary($aggregate);my$total=$aggregate->total;my$passed=$aggregate->passed;my$failed=$aggregate->failed;my@parsers=$aggregate->parsers;my$num_bad=0;for my$parser (@parsers){$num_bad++ if$parser->has_problems}die(sprintf("Failed %d/%d test programs. %d/%d subtests failed.\n",$num_bad,scalar@parsers,$failed,$total))if$num_bad;return$total && $total==$passed}sub _canon {my@list=sort {$a <=> $b}@_;my@ranges=();my$count=scalar@list;my$pos=0;while ($pos < $count){my$end=$pos + 1;$end++ while$end < $count && $list[$end]<= $list[$end - 1 ]+ 1;push@ranges,($end==$pos + 1)? $list[$pos]: join('-',$list[$pos],$list[$end - 1 ]);$pos=$end}return join(' ',@ranges)}sub _new_harness {my$sub_args=shift || {};my (@lib,@switches);my@opt=map {shellwords($_)}grep {defined}$Switches,$ENV{HARNESS_PERL_SWITCHES};while (my$opt=shift@opt){if ($opt =~ /^ -I (.*) $ /x){push@lib,length($1)? $1 : shift@opt}else {push@switches,$opt}}push@lib,_filtered_inc()if IS_VMS;my$verbosity=($Verbose ? ($Verbose !~ /\d/)? 1 : $Verbose : 0);my$args={timer=>$Timer,directives=>our$Directives,lib=>\@lib,switches=>\@switches,color=>$Color,verbosity=>$verbosity,ignore_exit=>$IgnoreExit,};$args->{stdout}=$sub_args->{out}if exists$sub_args->{out};my$class=$ENV{HARNESS_SUBCLASS}|| 'TAP::Harness';if (defined(my$env_opt=$ENV{HARNESS_OPTIONS})){for my$opt (split /:/,$env_opt){if ($opt =~ /^j(\d*)$/){$args->{jobs}=$1 || 9}elsif ($opt eq 'c'){$args->{color}=1}elsif ($opt =~ m/^f(.*)$/){my$fmt=$1;$fmt =~ s/-/::/g;$args->{formatter_class}=$fmt}elsif ($opt =~ m/^a(.*)$/){my$archive=$1;$class="TAP::Harness::Archive";$args->{archive}=$archive}else {die "Unknown HARNESS_OPTIONS item: $opt\n"}}}return TAP::Harness->_construct($class,$args)}sub _filtered_inc {my@inc=grep {!ref}@INC;if (IS_VMS){@inc=grep!/perl_root/i,@inc}elsif (IS_WIN32){s/[\\\/]+$// for@inc}my@default_inc=_default_inc();my@new_inc;my%seen;for my$dir (@inc){next if$seen{$dir}++;if ($dir eq ($default_inc[0]|| '')){shift@default_inc}else {push@new_inc,$dir}shift@default_inc while@default_inc and $seen{$default_inc[0]}}return@new_inc}{my@inc;sub _default_inc {return@inc if@inc;local$ENV{PERL5LIB};local$ENV{PERLLIB};my$perl=$ENV{HARNESS_PERL}|| $^X;chomp(@inc=`"$perl" -e "print join qq[\\n], \@INC, q[]"`);return@inc}}sub _check_sequence {my@list=@_;my$prev;while (my$next=shift@list){return if defined$prev && $next <= $prev;$prev=$next}return 1}sub execute_tests {my%args=@_;my$harness=_new_harness(\%args);my$aggregate=TAP::Parser::Aggregator->new();my%tot=(bonus=>0,max=>0,ok=>0,bad=>0,good=>0,files=>0,tests=>0,sub_skipped=>0,todo=>0,skipped=>0,bench=>undef,);$harness->callback(made_parser=>sub {my$parser=shift;$parser->callback(plan=>sub {my$plan=shift;if ($plan->directive eq 'SKIP'){$tot{skipped}++}})});_aggregate($harness,$aggregate,@{$args{tests}});$tot{bench}=$aggregate->elapsed;my@tests=$aggregate->descriptions;$tot{files}=$tot{tests}=scalar@tests;my%failedtests=();my%todo_passed=();for my$test (@tests){my ($parser)=$aggregate->parsers($test);my@failed=$parser->failed;my$wstat=$parser->wait;my$estat=$parser->exit;my$planned=$parser->tests_planned;my@errors=$parser->parse_errors;my$passed=$parser->passed;my$actual_passed=$parser->actual_passed;my$ok_seq=_check_sequence($parser->actual_passed);$estat ||= '' unless$wstat;$wstat ||= '';$tot{max}+= ($planned || 0);$tot{bonus}+= $parser->todo_passed;$tot{ok}+= $passed > $actual_passed ? $passed : $actual_passed;$tot{sub_skipped}+= $parser->skipped;$tot{todo}+= $parser->todo;if (@failed || $estat || @errors){$tot{bad}++;my$huh_planned=$planned ? undef : '??';my$huh_errors=$ok_seq ? undef : '??';$failedtests{$test}={'canon'=>$huh_planned || $huh_errors || _canon(@failed)|| '??','estat'=>$estat,'failed'=>$huh_planned || $huh_errors || scalar@failed,'max'=>$huh_planned || $planned,'name'=>$test,'wstat'=>$wstat }}else {$tot{good}++}my@todo=$parser->todo_passed;if (@todo){$todo_passed{$test}={'canon'=>_canon(@todo),'estat'=>$estat,'failed'=>scalar@todo,'max'=>scalar$parser->todo,'name'=>$test,'wstat'=>$wstat }}}return (\%tot,\%failedtests,\%todo_passed)}1;
TEST_HARNESS

$fatpacked{"Test/MonkeyMock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MONKEYMOCK';
  package Test::MonkeyMock;use strict;use warnings;require Carp;our$VERSION='0.09';my$registry={};my$magic_counter=0;sub new {my$class=shift;$class=ref$class if ref$class;my ($instance)=@_;my$new_package;if ($instance){$new_package=__PACKAGE__ .'::' .ref($instance).'::__instance__' .($magic_counter++);no strict 'refs';@{$new_package .'::ISA'}=(ref($instance))}else {$instance={};$new_package=__PACKAGE__ .'::' .($magic_counter++);no strict 'refs';@{$new_package .'::ISA'}=__PACKAGE__}no strict 'refs';for my$method (qw/mock mocked_called mocked_call_args mocked_call_stack mocked_return_args mocked_return_stack/){*{$new_package .'::' .$method}=sub {goto &$method}}bless$instance,$new_package;return$instance}sub mock {my$self=shift;my ($method,$code,%options)=@_;if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless my$orig_method=$self->can($method);if (exists$registry->{ref($self)}->{'mocks'}->{$method}){push @{$registry->{ref($self)}->{'mocks'}->{$method}},{code=>$code,orig_code=>$orig_method};return$self}my$ref_self=ref($self);my$package=__PACKAGE__;$ref_self =~ s/^${package}::(.*)::__instance__\d+/$1/;my$new_package=__PACKAGE__ .'::' .$ref_self .'::__instance__' .$magic_counter++;$registry->{$new_package}=$registry->{ref($self)};my$mocks=$registry->{$new_package}->{'mocks'}||= {};$mocks->{$method}=[{code=>$code,orig_code=>$orig_method,options=>\%options}];no strict 'refs';@{$new_package .'::ISA'}=ref($self);*{$new_package .'::' .$method}=sub {_dispatch($new_package,$method,@_)};bless$self,$new_package}else {my$mocks=$registry->{ref($self)}->{'mocks'}||= {};push @{$mocks->{$method}},{code=>$code,options=>\%options }}return$self}sub mocked_called {my$self=shift;my ($method)=@_;my$mocks=$registry->{ref($self)}->{'mocks'}||= {};my$calls=$registry->{ref($self)}->{'calls'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}return$calls->{$method}->{called}|| 0}sub mocked_call_args {my$self=shift;my ($method,$frame)=@_;$frame ||= 0;my$stack=$self->mocked_call_stack($method);Carp::croak("Unknown frame '$frame'")unless @$stack > $frame;return @{$stack->[$frame]}}sub mocked_call_stack {my$self=shift;my ($method)=@_;Carp::croak("Method is required")unless$method;my$calls=$registry->{ref($self)}->{'calls'}||= {};my$mocks=$registry->{ref($self)}->{'mocks'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}Carp::croak("Method '$method' was not called")unless exists$calls->{$method};return$calls->{$method}->{stack}}sub mocked_return_args {my$self=shift;my ($method,$frame)=@_;$frame ||= 0;my$stack=$self->mocked_return_stack($method);Carp::croak("Unknown frame '$frame'")unless @$stack > $frame;return @{$stack->[$frame]}}sub mocked_return_stack {my$self=shift;my ($method)=@_;Carp::croak("Method is required")unless$method;my$returns=$registry->{ref($self)}->{'returns'}||= {};my$mocks=$registry->{ref($self)}->{'mocks'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}Carp::croak("Method '$method' was not called")unless exists$returns->{$method};return$returns->{$method}->{stack}}sub can {my$self=shift;my ($method)=@_;if (ref($self)=~ m/__instance__/){return$self->can($method)}else {my$mocks=$registry->{ref($self)}->{'mocks'}||= {};return$mocks->{$method}->[0]->{code}}}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my ($method)=(split /::/,$AUTOLOAD)[-1];return if$method =~ /^[A-Z]+$/;return _dispatch(ref($self),$method,$self,@_)}sub _dispatch {my ($ref_self,$method,@args)=@_;my$calls=$registry->{$ref_self}->{'calls'}||= {};my$returns=$registry->{$ref_self}->{'returns'}||= {};my$mocks=$registry->{$ref_self}->{'mocks'}||= {};Carp::croak("Unmocked method '$method'")if!exists$mocks->{$method};for my$mock (@{$mocks->{$method}}){if (my$options=$mock->{options}){if (my$when=$options->{when}){next unless$when->(@args)}if (defined(my$frame=$options->{frame})){my$current_frame=$returns->{$method}->{stack}? @{$returns->{$method}->{stack}}: 0;next unless$frame==$current_frame}}$calls->{$method}->{called}++;push @{$calls->{$method}->{stack}},[@args[1 .. $#args]];my@result;if (my$code=$mock->{code}){@result=$code->(@args)}elsif (my$orig_code=$mock->{orig_code}){@result=$orig_code->(@args)}else {Carp::croak("Unmocked method '$method'")}push @{$returns->{$method}->{stack}},[@result];return wantarray ? @result : $result[0]}}1;
TEST_MONKEYMOCK

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use App::stew::cmdbuilder;
use App::stew::rc;

my $command = shift @ARGV;

my $rc       = App::stew::rc->new->load;
my $defaults = {%{$rc->{$command} || {}}, %{$rc->{_} || {}}};
my @defaults = map { $_ => $defaults->{$_} } keys %$defaults;

App::stew::cmdbuilder->new->build($command)->run(@defaults, @ARGV);

__END__

=head1 NAME

stew - Stew your binaries

=head1 SYNOPSIS

stew [command] [options...]

Available commands:

   install         install package
   uninstall       uninstall package
   build           build package without installing
   autoremove      remove not required dependencies
   list-installed  list installed packages
   exec            execute command in local environment
   help            detailed command help

=head1 COMMANDS

=over 4

=item B<install>

See L<App::stew::cmd::install>.

=item B<uninstall>

See L<App::stew::cmd::uninstall>.

=item B<build>

See L<App::stew::cmd::build>.

=item B<autoremove>

See L<App::stew::cmd::autoremove>.

=item B<list-installed>

See L<App::stew::cmd::list_installed>.

=item B<exec>

See L<App::stew::cmd::exec>.

=back

=head1 DESCRIPTION

B<stew> will read the given input file(s) and do something
useful with the contents thereof.

=cut
