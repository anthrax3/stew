#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/stew.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW';
  package App::stew;use 5.008001;use strict;use warnings;our$VERSION="0.01";1;
APP_STEW

$fatpacked{"App/stew/builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_BUILDER';
  package App::stew::builder;use strict;use warnings;use Cwd qw(abs_path getcwd);use Carp qw(croak);use File::Path qw(rmtree);use File::Basename qw(basename dirname);use App::stew::util qw(cmd info debug error _chdir _mkpath _copy _rmtree _tree);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{root_dir}=$params{root_dir};$self->{build_dir}=$params{build_dir};$self->{repo}=$params{repo};$self->{snapshot}=$params{snapshot};return$self}sub build {my$self=shift;my ($stew_tree,$mode)=@_;my$stew=$stew_tree->{stew};croak '$ENV{PREFIX} not defined' unless$ENV{PREFIX};_mkpath($ENV{PREFIX});info sprintf "Building '%s'...",$stew->package;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);my$cwd=getcwd();my$tree=[];eval {_rmtree$work_dir;_mkpath($work_dir);_chdir($work_dir);info sprintf "Checking dependencies...",$stew->package;$self->_resolve_dependencies($stew,$stew_tree);my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);my$dist_archive=basename$dist_path;my ($dist_name)=$dist_archive =~ m/^(.*)\.tar\.gz$/;_chdir($work_dir);$tree=$self->_build_from_source($stew,$dist_name);if (!$stew->is('cross-platform')){_chdir($work_dir);cmd("tar czhf $dist_archive -C $dist_name/$ENV{PREFIX}/ .");info sprintf "Saving '%s' as '$dist_path'...",$stew->package;_mkpath(dirname$dist_path);_copy$dist_archive,$dist_path}_chdir($cwd)}or do {my$e=$@;_chdir($cwd);die$e};return$tree}sub _build_from_source {my$self=shift;my ($stew,$dist_name)=@_;_mkpath($ENV{PREFIX});_mkpath$dist_name;$ENV{DESTDIR}=abs_path($dist_name);my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_mkpath$work_dir;_chdir($work_dir);if ($stew->url){my$src_file=$self->{repo}->mirror_file($stew->url,File::Spec->catfile($self->{repo}->{mirror_path},'src'));_copy($src_file,$work_dir)}else {my$src_file=$self->{repo}->mirror_src($stew->file);_copy($src_file,$work_dir);if (my@files=$stew->files){for my$file (@files){my$src_file=$self->{repo}->mirror_src($file);_copy($src_file,$work_dir)}}}info sprintf "Preparing '%s'...",$stew->package;$self->_run_stew_phase($stew,'prepare');info sprintf "Building '%s'...",$stew->package;$self->_run_stew_phase($stew,'build');info sprintf "Installing '%s'...",$stew->package;$self->_run_stew_phase($stew,'install');info sprintf "Cleaning '%s'...",$stew->package;$self->_run_stew_phase($stew,'cleanup');_chdir "$ENV{DESTDIR}/$ENV{PREFIX}";return _tree('.','.')}sub _run_stew_phase {my$self=shift;my ($stew,$phase)=@_;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_chdir($work_dir);my@commands=$stew->run($phase);cmd(@commands)}sub _resolve_dependencies {my$self=shift;my ($stew,$tree)=@_;my$build_dir=$self->{build_dir};my$work_dir=File::Spec->catfile($build_dir,$stew->package);my@makedepends=@{$tree->{make_dependencies}|| []};if (@makedepends){info "Found make dependencies: " .join(', ',map {$_->{stew}->package}@makedepends)}for my$tree (@makedepends){my$stew=$tree->{stew};_chdir($self->{root_dir});info sprintf "Preparing make dependency '%s'",$stew->package;$self->_run_stew_phase($stew,'prepare');_chdir($self->{root_dir});my$to=sprintf '%s/%s',$work_dir,$stew->package;if (!-e $to){cmd(sprintf "ln -s $build_dir/%s/%s $to",$stew->package,$stew->package)}}my@depends=@{$tree->{dependencies}|| []};for my$tree (@depends){my$stew=$tree->{stew};die$stew->package ." is not installed\n" unless$self->{snapshot}->is_up_to_date($stew->name,$stew->version)}}1;
APP_STEW_BUILDER

$fatpacked{"App/stew/cmd/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_BUILD';
  package App::stew::cmd::build;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::repo;use App::stew::builder;use App::stew::index;use App::stew::tree;use App::stew::env;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_repo;my$opt_os;my$opt_arch;my$opt_build_dir='build';my$opt_verbose;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"repo=s"=>\$opt_repo,"os=s"=>\$opt_os,"arch=s"=>\$opt_arch,"build-dir=s"=>\$opt_build_dir,"verbose"=>\$opt_verbose,)or die "error";chomp($opt_os //= `uname -s`);$opt_os=lc$opt_os;chomp($opt_arch //= `uname -m`);$opt_arch=lc$opt_arch;error("--base is required")unless$opt_base;error("--repo is required")unless$opt_repo;mkpath($opt_base);$opt_base=abs_path($opt_base);my$root_dir=abs_path(cwd());my$build_dir=abs_path($opt_build_dir);mkpath($build_dir);$ENV{STEW_LOG_LEVEL}=$opt_verbose ? 1 : 0;$ENV{STEW_LOG_FILE}="$build_dir/stew.log";unlink$ENV{STEW_LOG_FILE};my$repo=App::stew::repo->new(path=>$opt_repo,mirror_path=>"$build_dir/.cache",os=>$opt_os,arch=>$opt_arch);my$index=App::stew::index->new(repo=>$repo);my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;my@trees;for my$package (@argv){my$tree=App::stew::tree->new(repo=>$repo,index=>$index);my$dump=$tree->build($package);push@trees,$dump}$ENV{STEW_OS}=$opt_os;$ENV{STEW_ARCH}=$opt_arch;$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->setup;my$builder=App::stew::builder->new(root_dir=>$root_dir,build_dir=>$build_dir,repo=>$repo,snapshot=>$snapshot,);for my$tree (@trees){$builder->build($tree)}info "Done"}1;
APP_STEW_CMD_BUILD

$fatpacked{"App/stew/cmd/exec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_EXEC';
  package App::stew::cmd::exec;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::env;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,)or die "error";error("--base is required")unless$opt_base;$opt_base=abs_path($opt_base);$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->setup;system(@argv)}1;
APP_STEW_CMD_EXEC

$fatpacked{"App/stew/cmd/install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_INSTALL';
  package App::stew::cmd::install;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::repo;use App::stew::installer;use App::stew::snapshot;use App::stew::index;use App::stew::tree;use App::stew::env;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_repo;my$opt_os;my$opt_arch;my$opt_build='build';my$opt_dry_run;my$opt_verbose;my$opt_from_source;my$opt_reinstall;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"repo=s"=>\$opt_repo,"os=s"=>\$opt_os,"arch=s"=>\$opt_arch,"build=s"=>\$opt_build,"dry-run"=>\$opt_dry_run,"verbose"=>\$opt_verbose,"from-source"=>\$opt_from_source,"reinstall"=>\$opt_reinstall,)or die "error";chomp($opt_os //= `uname -s`);$opt_os=lc$opt_os;chomp($opt_arch //= `uname -m`);$opt_arch=lc$opt_arch;error("--base is required")unless$opt_base;error("--repo is required")unless$opt_repo;mkpath($opt_base);$opt_base=abs_path($opt_base);my$root_dir=abs_path(cwd());my$build_dir=abs_path($opt_build);mkpath($build_dir);$ENV{STEW_LOG_LEVEL}=$opt_verbose ? 1 : 0;$ENV{STEW_LOG_FILE}="$build_dir/stew.log";unlink$ENV{STEW_LOG_FILE};my$repo=App::stew::repo->new(path=>$opt_repo,mirror_path=>"$build_dir/.cache",os=>$opt_os,arch=>$opt_arch);my$index=App::stew::index->new(repo=>$repo);my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;my@trees;for my$package (@argv){my$tree=App::stew::tree->new(repo=>$repo,index=>$index);my$dump=$tree->build($package);push@trees,$dump}$ENV{STEW_OS}=$opt_os;$ENV{STEW_ARCH}=$opt_arch;$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->setup;my$builder=App::stew::installer->new(root_dir=>$root_dir,build_dir=>$build_dir,repo=>$repo,snapshot=>$snapshot,from_source=>$opt_from_source,reinstall=>$opt_reinstall,);for my$tree (@trees){$builder->build($tree)}info "Done"}1;
APP_STEW_CMD_INSTALL

$fatpacked{"App/stew/cmd/list_installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_LIST_INSTALLED';
  package App::stew::cmd::list_installed;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base)or die "error";error("--base is required")unless$opt_base;my$snapshot=App::stew::snapshot->new(base=>$opt_base)->load;for my$key (sort keys %$snapshot){print "$key $snapshot->{$key}->{version}\n"}}1;
APP_STEW_CMD_LIST_INSTALLED

$fatpacked{"App/stew/cmd/uninstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_UNINSTALL';
  package App::stew::cmd::uninstall;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::util qw(info debug error _unlink);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_verbose;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"verbose"=>\$opt_verbose,)or die "error";error("--base is required")unless$opt_base;my (@packages)=@argv;my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;for my$package (@packages){if (!$snapshot->is_installed($package)){warn "$package not installed. Skipping"}else {debug sprintf "Uninstalling '%s'...",$package;my$info=$snapshot->get_package($package);for my$file (@{$info->{files}}){_unlink "$opt_base/$opt_prefix/$file"}$snapshot->mark_uninstalled($package)}}}1;
APP_STEW_CMD_UNINSTALL

$fatpacked{"App/stew/env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_ENV';
  package App::stew::env;use strict;use warnings;use App::stew::util qw(debug);sub setup {_unshift_env(PATH=>"$ENV{PREFIX}/bin");_unshift_env(LIBPATH=>"$ENV{PREFIX}/lib");_unshift_env(LIBRARY_PATH=>"$ENV{PREFIX}/lib");_unshift_env(LD_LIBRARY_PATH=>"$ENV{PREFIX}/lib");_unshift_env(CPATH=>"$ENV{PREFIX}/include");_unshift_env(C_INCLUDE_PATH=>"$ENV{PREFIX}/include");_unshift_env(CPLUS_INCLUDE_PATH=>"$ENV{PREFIX}/include")}sub _unshift_env {my ($var,$value)=@_;if ($ENV{$var}){$ENV{$var}="$value:$ENV{$var}"}else {$ENV{$var}=$value}debug "Setting ENV{$var}=$ENV{$var}"}1;
APP_STEW_ENV

$fatpacked{"App/stew/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_FILE';
  package App::stew::file;use strict;use warnings;use App::stew::util qw(slurp_file error);sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub parse {my$class=shift;my ($stew_file,$type)=@_;my$content=slurp_file($stew_file);my$stew_class=$class->_sandbox($stew_file,$content,$type);return$stew_class->new}sub _sandbox {my$self=shift;my ($file,$content,$type)=@_;$type='' unless defined$type;my$class_name='stew::_build_' ._rand_str();my$package=<<"EOP";eval$package or error("Error compiling '$file': $@");return$class_name}sub _rand_str {my@alpha=('0' .. '9','a' .. 'z','A' .. 'Z');my$str='';$str .= $alpha[rand($#alpha)]for 1 .. 16;return$str}1;
      package $class_name;
      use strict;
      use warnings;
      my \$name;
      my \$version;
      my \$package;
      my \$file;
      my \@files;
      my \$url;
      my \@depends;
      my \@makedepends;
      my \@flags;
  
      sub new {
          my \$class = shift;
  
          my \$self = {};
          bless \$self, \$class;
  
          return \$self;
      }
  
      sub is_dependency     { '$type' eq 'depends' }
      sub is_makedependency { '$type' eq 'makedepends' }
  
      sub name        { \$name }
      sub version     { \$version }
      sub package     { \$package }
      sub file        { \$file }
      sub files       { \@files }
      sub url         { \$url }
      sub depends     { \@depends }
      sub makedepends { \@makedepends }
      sub flags       { \@flags }
  
      my \$phases = {};
      sub download(&) { \$phases->{download}    = shift }
      sub prepare(&)  { \$phases->{prepare}     = shift }
      sub build(&)    { \$phases->{build}       = shift }
      sub install(&)  { \$phases->{install}     = shift }
      sub cleanup(&)  { \$phases->{cleanup} = shift }
  
      sub phase { \$phases->{\$_[1]} }
  
      sub is {
          my \$self = shift;
          my (\$flag) = \@_;
  
          return !!grep { \$_ eq \$flag } \$self->flags;
      }
  
      sub run {
          my \$self = shift;
          my (\$phase) = \@_;
  
          if (\$phases->{\$phase}) {
              return \$phases->{\$phase}->()
          }
  
          return;
      }
      $content
      1;
  EOP
APP_STEW_FILE

$fatpacked{"App/stew/index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_INDEX';
  package App::stew::index;use strict;use warnings;use Carp qw(croak);use List::Util qw(first);use App::stew::util qw(error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{repo}=$params{repo}or croak 'repo required';return$self}sub resolve {my$self=shift;my ($need)=@_;my$name=$need;my$op;my$version;if ($need =~ m/^(.*?)(==|>=?|<=?)(.*)$/){$name=$1;$op=$2;$version=$3}$self->{index}||= $self->_read_index;my@packages;for my$package (@{$self->{index}}){push@packages,$package if$package->{name}eq $name}if (!$op){my$package=$packages[-1];return unless$package;return$package->{full}}elsif ($op eq '=='){my$package=first {$_->{version}eq $version}@packages;return unless$package;return$package->{full}}elsif ($op eq '>='){my$package=first {$_->{version}ge $version}@packages;return unless$package;return$package->{full}}elsif ($op eq '>'){my@packages=grep {$_->{version}gt $version}@packages;return unless@packages;return$packages[-1]->{full}}return}sub _read_index {my$self=shift;my$index_file=$self->{repo}->mirror_index;my@index;open my$fh,'<',$index_file or error "Can't read index file '$index_file': $!";for my$line (<$fh>){chomp$line;next unless$line =~ m/^stew\/(.*?)_(.*?)\.stew$/;push@index,{name=>$1,version=>$2,full=>"$1_$2" }}close$fh;return \@index}1;
APP_STEW_INDEX

$fatpacked{"App/stew/installer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_INSTALLER';
  package App::stew::installer;use strict;use warnings;use Cwd qw(abs_path getcwd);use Carp qw(croak);use File::Path qw(rmtree);use File::Basename qw(basename dirname);use App::stew::builder;use App::stew::util qw(cmd info debug error _chdir _mkpath _rmtree _copy _unlink _tree _tree_diff);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{root_dir}=$params{root_dir};$self->{build_dir}=$params{build_dir};$self->{repo}=$params{repo};$self->{snapshot}=$params{snapshot};$self->{from_source}=$params{from_source};$self->{reinstall}=$params{reinstall};return$self}sub build {my$self=shift;my ($stew_tree,$mode)=@_;my$stew=$stew_tree->{stew};my$reinstall=!$mode && $self->{reinstall};my$from_source=!$mode && $self->{from_source};if (!$reinstall && $self->{snapshot}->is_up_to_date($stew->name,$stew->version)){info sprintf "'%s' is up to date",$stew->package;return}croak '$ENV{PREFIX} not defined' unless$ENV{PREFIX};_mkpath($ENV{PREFIX});info sprintf "Building & installing '%s'...",$stew->package;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_rmtree$work_dir;_mkpath($work_dir);my$cwd=getcwd();my$tree=[];eval {info sprintf "Resolving dependencies...",$stew->package;$self->_resolve_dependencies($stew,$stew_tree);if ($stew->is('cross-platform')){info sprintf 'Cross platform package';my$builder=$self->_build_builder;$tree=$builder->build($stew_tree);my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);my$dist_archive=basename$dist_path;my ($dist_name)=$dist_archive =~ m/^(.*)\.tar\.gz$/;_chdir$work_dir;_chdir "$dist_name/$ENV{PREFIX}";cmd("cp --remove-destination -ra * $ENV{PREFIX}/")}else {my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);eval {$self->{repo}->mirror_dist($stew->name,$stew->version)};if ($from_source ||!-f $dist_path){my$builder=$self->_build_builder;$tree=$builder->build($stew_tree)}$self->_install_from_binary($stew,$dist_path)}_chdir($cwd)}or do {my$e=$@;_chdir($cwd);die$e};info sprintf "Done installing '%s'",$stew->package;$self->{snapshot}->mark_installed($stew->name,$stew->version,$tree);return$self}sub _install_from_binary {my$self=shift;my ($stew,$dist_path)=@_;info sprintf "Installing '%s' from binaries '%s'...",$stew->package,$dist_path;my$basename=basename$dist_path;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_chdir$work_dir;my ($dist_name)=$basename =~ m/^(.*)\.tar\.gz$/;_rmtree$dist_name;_mkpath$dist_name;_copy($dist_path,"$dist_name/$basename");_chdir$dist_name;cmd("tar xzf $basename");_unlink$basename;cmd("cp --remove-destination -ra * $ENV{PREFIX}/");return _tree(".",".")}sub _resolve_dependencies {my$self=shift;my ($stew,$tree)=@_;my@depends=@{$tree->{dependencies}|| []};if (@depends){info "Found dependencies: " .join(', ',map {$_->{stew}->package}@depends)}for my$tree (@depends){my$stew=$tree->{stew};_chdir($self->{root_dir});$self->build($tree,'dep');_chdir($self->{root_dir})}}sub _build_builder {my$self=shift;return App::stew::builder->new(root_dir=>$self->{root_dir},build_dir=>$self->{build_dir},repo=>$self->{repo},snapshot=>$self->{snapshot},)}1;
APP_STEW_INSTALLER

$fatpacked{"App/stew/repo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_REPO';
  package App::stew::repo;use strict;use warnings;use HTTP::Tiny;use File::Basename qw(dirname basename);use File::Path ();use Carp qw(croak);use App::stew::util qw(error debug _copy _mkpath);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{path}=$params{path}or croak 'path required';$self->{path}.= '/' unless$self->{path}=~ m{/$};$self->{mirror_path}=$params{mirror_path}or croak 'mirror_path required';$self->{mirror_path}.= '/' unless$self->{mirror_path}=~ m{/$};$self->{os}=$params{os}or croak 'os required';$self->{arch}=$params{arch}or croak 'arch required';$self->{ua}=$params{ua};return$self}sub mirror_stew {my$self=shift;my ($name)=@_;my$full_name=$self->{path}.File::Spec->catfile('stew',$name .'.stew');return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'stew'))}sub mirror_src {my$self=shift;my ($filename)=@_;my$full_name=$self->{path}.File::Spec->catfile('src',$filename);return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'src'))}sub mirror_dist_dest {my$self=shift;my ($name,$version)=@_;my$os=$self->{os};my$arch=$self->{arch};return File::Spec->catfile($self->{mirror_path},'dist',$os,$arch,"${name}_${version}_$os-$arch.tar.gz")}sub mirror_dist {my$self=shift;my ($name,$version)=@_;croak 'name required' unless$name;croak 'version required ' unless$version;my$os=$self->{os};my$arch=$self->{arch};my$full_name=$self->{path}.File::Spec->catfile('dist',$os,$arch,"${name}_${version}_$os-$arch.tar.gz");return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'dist',$os,$arch))}sub mirror_index {my$self=shift;my@index;if ($self->{path}=~ m/^http/){my$ua=$self->{ua}|| HTTP::Tiny->new;for my$type (qw(stew src)){my$response=$ua->get("$self->{path}$type");if ($response->{success}){my$content=$response->{content};while ($content =~ m#<a href="(.*?\.(?:stew|tar\.gz))">.*?</a>#g){push@index,"$type/$1"}}}}else {for my$type (qw(stew src)){opendir my$dh,"$self->{path}/$type" or error "Can't open directory '$self->{path}/$type': $!";push@index,map {"$type/$_"}grep {!/^\./ && -f "$self->{path}/$type/$_"}readdir($dh);closedir$dh}}my$to=File::Spec->catfile($self->{mirror_path},'index');_mkpath dirname$to;open my$fh,'>',$to or die "Can't create file '$to': $!";print$fh "$_\n" for sort@index;close$fh;return$to}sub mirror_file {my$self=shift;my ($in,$to_dir)=@_;_mkpath($to_dir);debug("Mirroring '$in' to '$to_dir'");my$to=File::Spec->catfile($to_dir,basename$in);if (-e $to){debug("File '$to' exists. Skipping");return$to}if ($in =~ m/^http/){my$ua=$self->{ua}|| HTTP::Tiny->new;$ua->mirror($in,$to)}else {error "File '$in' does not exist" unless -f $in;_copy($in,$to)}return$to}1;
APP_STEW_REPO

$fatpacked{"App/stew/snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_SNAPSHOT';
  package App::stew::snapshot;use strict;use warnings;use File::Spec ();use Data::Dumper ();use Carp qw(croak);use App::stew::util qw(slurp_file write_file);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base}=$params{base};croak 'base is required' unless$self->{base};$self->{snapshot}={};$self->load;return$self}sub is_installed {my$self=shift;my ($package)=@_;if ($self->{snapshot}->{$package}){return 1}return 0}sub is_up_to_date {my$self=shift;my ($package,$version)=@_;return 0 unless$self->is_installed($package);return 0 unless$self->{snapshot}->{$package}->{version}eq $version;return 1}sub get_package {my$self=shift;my ($package)=@_;return$self->{snapshot}->{$package}}sub load {my$self=shift;my$install_file=$self->_install_file;my$installed={};if (-e $install_file){no strict;$installed=eval slurp_file($install_file)}$self->{snapshot}=$installed;return$self->{snapshot}}sub mark_installed {my$self=shift;my ($name,$version,$files)=@_;$self->{snapshot}->{$name}={version=>$version,files=>$files};$self->store;return$self}sub mark_uninstalled {my$self=shift;my ($name)=@_;delete$self->{snapshot}->{$name};$self->store;return$self}sub store {my$self=shift;write_file($self->_install_file,Data::Dumper::Dumper($self->{snapshot}));return$self}sub _install_file {my$self=shift;return File::Spec->catfile($self->{base},'stew.snapshot')}1;
APP_STEW_SNAPSHOT

$fatpacked{"App/stew/tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_TREE';
  package App::stew::tree;use strict;use warnings;use Carp qw(croak);use App::stew::file;use App::stew::util qw(error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{repo}=$params{repo}or croak 'repo required';$self->{index}=$params{index}or croak 'index required';return$self}sub build {my$self=shift;my ($stew_expr,$type)=@_;my$stew_name=$self->{index}->resolve($stew_expr);error "Can't find package satisfying '$stew_expr'" unless$stew_name;my$stew_file=$self->_download_stew($stew_name,$type);my$stew=$self->_parse_stew($stew_file,$type);my$tree={stew=>$stew,make_dependencies=>[],dependencies=>[]};my@makedepends=$stew->makedepends;for my$makedepends (@makedepends){push @{$tree->{make_dependencies}},$self->build($makedepends,'makedepends')}my@depends=$stew->depends;for my$depends (@depends){push @{$tree->{dependencies}},$self->build($depends,'depends')}return$tree}sub flatten {my$self=shift;my ($tree)=@_;my@list;for my$make_dep (@{$tree->{make_dependencies}}){push@list,$self->flatten($make_dep)}for my$dep (@{$tree->{dependencies}}){push@list,$self->flatten($dep)}push@list,$tree->{stew};return@list}sub flatten_dependencies {my$self=shift;my ($tree)=@_;my@list;for my$make_dep (@{$tree->{make_dependencies}}){push@list,$self->flatten($make_dep)}for my$dep (@{$tree->{dependencies}}){push@list,$self->flatten($dep)}return@list}sub _download_stew {my$self=shift;my ($stew_name)=@_;return$self->{repo}->mirror_stew($stew_name)}sub _parse_stew {my$self=shift;my ($file,$type)=@_;return App::stew::file->parse($file,$type)}1;
APP_STEW_TREE

$fatpacked{"App/stew/util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_UTIL';
  package App::stew::util;use strict;use warnings;use base 'Exporter';our@EXPORT_OK=qw(info debug error slurp_file write_file cmd _chdir _mkpath _rmtree _copy _unlink _tree _tree_diff);use File::Find qw(find);use Carp qw(croak);use File::Copy qw(copy);use File::Basename qw(dirname);use File::Path qw(mkpath rmtree);sub slurp_file {my ($file)=@_;local $/;open my$fh,'<',$file or error("Can't read file '$file': $!");return <$fh>}sub write_file {my ($file,$content)=@_;open my$fh,'>',$file or error("Can't write file '$file': $!");print$fh $content;close$fh}sub debug {print STDERR @_,"\n" if$ENV{STEW_LOG_LEVEL};_log(@_)}sub info {_log(@_);warn join(' ',@_)."\n"}sub error {_log(@_);croak("ERROR: " .join(' ',@_))}sub _chdir {my ($dir)=@_;debug(qq{Entering '$dir'});die "Directory '$dir' does not exist" unless -d $dir;chdir($dir)}sub _mkpath {my ($dir)=@_;debug(qq{Creating '$dir'});mkpath($dir)}sub _rmtree {my ($dir)=@_;debug(qq{Removing '$dir'});rmtree($dir)}sub _copy {my ($from,$to)=@_;debug(qq{Copying '$from' -> '$to'});copy($from,$to)or croak "Cant copy '$from' -> '$to'"}sub _unlink {my ($file)=@_;debug(qq{Unlinking '$file'});unlink($file)}sub cmd {return unless @_;my$cmd=join ' && ',@_;$cmd="sh -c \"$cmd 2>&1\" 2>&1 >> $ENV{STEW_LOG_FILE}";debug($cmd);my$exit=system($cmd);error("Command failed: $cmd")if$exit}sub _log {open my$fh,'>>',$ENV{STEW_LOG_FILE}or die "Can't open logfile '$ENV{STEW_LOG_FILE}': $!";print$fh @_,"\n";close$fh}sub _tree {my ($dir,$prefix)=@_;my@tree;find(sub {return unless -f $_;my$name=$File::Find::name;if ($prefix){$name =~ s{^$prefix/?}{}}push@tree,$name},$dir);return [sort@tree]}sub _tree_diff {my ($tree1,$tree2)=@_;my@diff;my$diff_pos=0;for (my$pos=0;$pos < @$tree1;$pos++){while ($diff_pos < @$tree2 && $tree1->[$pos]ne $tree2->[$diff_pos]){push@diff,$tree2->[$diff_pos];$diff_pos++}if ($diff_pos < @$tree2 && $tree1->[$pos]eq $tree2->[$diff_pos]){$diff_pos++;next}last if$diff_pos >= @$tree2}while ($diff_pos < @$tree2){push@diff,$tree2->[$diff_pos];$diff_pos++}return \@diff}1;
APP_STEW_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use App::stew::util qw(error);
use App::stew::cmd::install;
use App::stew::cmd::build;
use App::stew::cmd::list_installed;
use App::stew::cmd::uninstall;
use App::stew::cmd::exec;

my $command = shift @ARGV;

if (!$command) {
}
elsif ($command eq 'install') {
    App::stew::cmd::install->new()->run(@ARGV);
}
elsif ($command eq 'build') {
    App::stew::cmd::build->new()->run(@ARGV);
}
elsif ($command eq 'list-installed') {
    App::stew::cmd::list_installed->new()->run(@ARGV);
}
elsif ($command eq 'uninstall') {
    App::stew::cmd::uninstall->new()->run(@ARGV);
}
elsif ($command eq 'exec') {
    App::stew::cmd::exec->new()->run(@ARGV);
}
else {
    error qq{Unknown command '$command'};
}
