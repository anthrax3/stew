#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Prove.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE';
  package App::Prove;use strict;use warnings;use TAP::Harness::Env;use Text::ParseWords qw(shellwords);use File::Spec;use Getopt::Long;use App::Prove::State;use Carp;use base 'TAP::Object';our$VERSION='3.35';use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>$^O eq 'VMS';use constant IS_UNIXY=>!(IS_VMS || IS_WIN32);use constant STATE_FILE=>IS_UNIXY ? '.prove' : '_prove';use constant RC_FILE=>IS_UNIXY ? '.proverc' : '_proverc';use constant PLUGINS=>'App::Prove::Plugin';my@ATTR;BEGIN {@ATTR=qw(archive argv blib show_count color directives exec failures comments formatter harness includes modules plugins jobs lib merge parse quiet really_quiet recurse backwards shuffle taint_fail taint_warn timer verbose warnings_fail warnings_warn show_help show_man show_version state_class test_args state dry extensions ignore_exit rules state_manager normalize sources tapversion trap);__PACKAGE__->mk_methods(@ATTR)}sub _initialize {my$self=shift;my$args=shift || {};my@is_array=qw(argv rc_opts includes modules state plugins rules sources);for my$key (@is_array){$self->{$key}=[]}for my$attr (@ATTR){if (exists$args->{$attr}){$self->{$attr}=$args->{$attr}}}$self->state_class('App::Prove::State');return$self}sub add_rc_file {my ($self,$rc_file)=@_;local*RC;open RC,"<$rc_file" or croak "Can't read $rc_file ($!)";while (defined(my$line=<RC>)){push @{$self->{rc_opts}},grep {defined and not /^#/}$line =~ m{ ' ([^']*) ' | " ([^"]*) " | (\#.*) | (\S+) }xg}close RC}sub process_args {my$self=shift;my@rc=RC_FILE;unshift@rc,glob '~/' .RC_FILE if IS_UNIXY;my@args;while (defined(my$arg=shift)){if ($arg eq '--norc'){@rc=()}elsif ($arg eq '--rc'){defined(my$rc=shift)or croak "Missing argument to --rc";push@rc,$rc}elsif ($arg =~ m{^--rc=(.+)$}){push@rc,$1}else {push@args,$arg}}if (defined(my$stop_at=_first_pos('::',@args))){my@test_args=splice@args,$stop_at;shift@test_args;$self->{test_args}=\@test_args}$self->add_rc_file($_)for grep -f,@rc;unshift@args,@{$self->{rc_opts}};if (my@bad=map {"-$_"}grep {/^-(man|help)$/}@args){die "Long options should be written with two dashes: ",join(', ',@bad),"\n"}{local@ARGV=@args;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through));GetOptions('v|verbose'=>\$self->{verbose},'f|failures'=>\$self->{failures},'o|comments'=>\$self->{comments},'l|lib'=>\$self->{lib},'b|blib'=>\$self->{blib},'s|shuffle'=>\$self->{shuffle},'color!'=>\$self->{color},'colour!'=>\$self->{color},'count!'=>\$self->{show_count},'c'=>\$self->{color},'D|dry'=>\$self->{dry},'ext=s@'=>sub {my ($opt,$val)=@_;push @{$self->{extensions}||= []},$val},'harness=s'=>\$self->{harness},'ignore-exit'=>\$self->{ignore_exit},'source=s@'=>$self->{sources},'formatter=s'=>\$self->{formatter},'r|recurse'=>\$self->{recurse},'reverse'=>\$self->{backwards},'p|parse'=>\$self->{parse},'q|quiet'=>\$self->{quiet},'Q|QUIET'=>\$self->{really_quiet},'e|exec=s'=>\$self->{exec},'m|merge'=>\$self->{merge},'I=s@'=>$self->{includes},'M=s@'=>$self->{modules},'P=s@'=>$self->{plugins},'state=s@'=>$self->{state},'directives'=>\$self->{directives},'h|help|?'=>\$self->{show_help},'H|man'=>\$self->{show_man},'V|version'=>\$self->{show_version},'a|archive=s'=>\$self->{archive},'j|jobs=i'=>\$self->{jobs},'timer'=>\$self->{timer},'T'=>\$self->{taint_fail},'t'=>\$self->{taint_warn},'W'=>\$self->{warnings_fail},'w'=>\$self->{warnings_warn},'normalize'=>\$self->{normalize},'rules=s@'=>$self->{rules},'tapversion=s'=>\$self->{tapversion},'trap'=>\$self->{trap},)or croak('Unable to continue');$self->{argv}=[@ARGV]}return}sub _first_pos {my$want=shift;for (0 .. $#_){return $_ if $_[$_]eq $want}return}sub _help {my ($self,$verbosity)=@_;eval('use Pod::Usage 1.12 ()');if (my$err=$@){die 'Please install Pod::Usage for the --help option ' .'(or try `perldoc prove`.)' ."\n ($@)"}Pod::Usage::pod2usage({-verbose=>$verbosity });return}sub _color_default {my$self=shift;return -t STDOUT &&!$ENV{HARNESS_NOTTY}&&!IS_WIN32}sub _get_args {my$self=shift;my%args;$args{trap}=1 if$self->trap;if (defined$self->color ? $self->color : $self->_color_default){$args{color}=1}if (!defined$self->show_count){$args{show_count}=1}else {$args{show_count}=$self->show_count}if ($self->archive){$self->require_harness(archive=>'TAP::Harness::Archive');$args{archive}=$self->archive}if (my$jobs=$self->jobs){$args{jobs}=$jobs}if (my$harness_opt=$self->harness){$self->require_harness(harness=>$harness_opt)}if (my$formatter=$self->formatter){$args{formatter_class}=$formatter}for my$handler (@{$self->sources}){my ($name,$config)=$self->_parse_source($handler);$args{sources}->{$name}=$config}if ($self->ignore_exit){$args{ignore_exit}=1}if ($self->taint_fail && $self->taint_warn){die '-t and -T are mutually exclusive'}if ($self->warnings_fail && $self->warnings_warn){die '-w and -W are mutually exclusive'}for my$a (qw(lib switches)){my$method="_get_$a";my$val=$self->$method();$args{$a}=$val if defined$val}my%verb_map=(verbose=>1,quiet=>-1,really_quiet=>-2,);my@verb_adj=grep {$_}map {$self->$_()? $verb_map{$_}: 0}keys%verb_map;die "Only one of verbose, quiet or really_quiet should be specified\n" if@verb_adj > 1;$args{verbosity}=shift@verb_adj || 0;for my$a (qw(merge failures comments timer directives normalize)){$args{$a}=1 if$self->$a()}$args{errors}=1 if$self->parse;$args{exec}=[split(/\s+/,$self->exec)]if (defined($self->exec));$args{version}=$self->tapversion if defined($self->tapversion);if (defined(my$test_args=$self->test_args)){$args{test_args}=$test_args}if (@{$self->rules}){my@rules;for (@{$self->rules}){if (/^par=(.*)/){push@rules,$1}elsif (/^seq=(.*)/){push@rules,{seq=>$1 }}}$args{rules}={par=>[@rules]}}$args{harness_class}=$self->{harness_class}if$self->{harness_class};return \%args}sub _find_module {my ($self,$class,@search)=@_;croak "Bad module name $class" unless$class =~ /^ \w+ (?: :: \w+ ) *$/x;for my$pfx (@search){my$name=join('::',$pfx,$class);eval "require $name";return$name unless $@}eval "require $class";return$class unless $@;return}sub _load_extension {my ($self,$name,@search)=@_;my@args=();if ($name =~ /^(.*?)=(.*)/){$name=$1;@args=split(/,/,$2)}if (my$class=$self->_find_module($name,@search)){$class->import(@args);if ($class->can('load')){$class->load({app_prove=>$self,args=>[@args]})}}else {croak "Can't load module $name"}}sub _load_extensions {my ($self,$ext,@search)=@_;$self->_load_extension($_,@search)for @$ext}sub _parse_source {my ($self,$handler)=@_;(my$opt_name=lc$handler)=~ s/::/-/g;local@ARGV=@{$self->{argv}};my%config;Getopt::Long::GetOptions("$opt_name-option=s%"=>sub {my ($name,$k,$v)=@_;if ($v =~ /(?<!\\)=/){croak "Option $name must be consistently used as a hash" if exists$config{$k}&& ref$config{$k}ne 'HASH';$config{$k}||= {};my ($hk,$hv)=split /(?<!\\)=/,$v,2;$config{$k}{$hk}=$hv}else {$v =~ s/\\=/=/g;if (exists$config{$k}){$config{$k}=[$config{$k}]unless ref$config{$k}eq 'ARRAY';push @{$config{$k}}=>$v}else {$config{$k}=$v}}});$self->{argv}=\@ARGV;return ($handler,\%config)}sub run {my$self=shift;unless ($self->state_manager){$self->state_manager($self->state_class->new({store=>STATE_FILE }))}if ($self->show_help){$self->_help(1)}elsif ($self->show_man){$self->_help(2)}elsif ($self->show_version){$self->print_version}elsif ($self->dry){print "$_\n" for$self->_get_tests}else {$self->_load_extensions($self->modules);$self->_load_extensions($self->plugins,PLUGINS);local$ENV{TEST_VERBOSE}=1 if$self->verbose;return$self->_runtests($self->_get_args,$self->_get_tests)}return 1}sub _get_tests {my$self=shift;my$state=$self->state_manager;my$ext=$self->extensions;$state->extensions($ext)if defined$ext;if (defined(my$state_switch=$self->state)){$state->apply_switch(@$state_switch)}my@tests=$state->get_tests($self->recurse,@{$self->argv});$self->_shuffle(@tests)if$self->shuffle;@tests=reverse@tests if$self->backwards;return@tests}sub _runtests {my ($self,$args,@tests)=@_;my$harness=TAP::Harness::Env->create($args);my$state=$self->state_manager;$harness->callback(after_test=>sub {$state->observe_test(@_)});$harness->callback(after_runtests=>sub {$state->commit(@_)});my$aggregator=$harness->runtests(@tests);return!$aggregator->has_errors}sub _get_switches {my$self=shift;my@switches;if ($self->taint_fail){push@switches,'-T'}elsif ($self->taint_warn){push@switches,'-t'}if ($self->warnings_fail){push@switches,'-W'}elsif ($self->warnings_warn){push@switches,'-w'}return@switches ? \@switches : ()}sub _get_lib {my$self=shift;my@libs;if ($self->lib){push@libs,'lib'}if ($self->blib){push@libs,'blib/lib','blib/arch'}if (@{$self->includes}){push@libs,@{$self->includes}}@libs=map {File::Spec->rel2abs($_)}@libs;return@libs ? \@libs : ()}sub _shuffle {my$self=shift;my$i=@_;while ($i){my$j=rand$i--;@_[$i,$j ]=@_[$j,$i ]}return}sub require_harness {my ($self,$for,$class)=@_;my ($class_name)=$class =~ /^(\w+(?:::\w+)*)/;$class =~ s!^(\w+(?:::\w+)*)=(.*)$!$1 split(/,/,q{$2})!;eval("use $class;");die "$class_name is required to use the --$for feature: $@" if $@;$self->{harness_class}=$class_name;return}sub print_version {my$self=shift;require TAP::Harness;printf("TAP::Harness v%s and Perl v%vd\n",$TAP::Harness::VERSION,$^V);return}1;
APP_PROVE

$fatpacked{"App/Prove/State.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE';
  package App::Prove::State;use strict;use warnings;use File::Find;use File::Spec;use Carp;use App::Prove::State::Result;use TAP::Parser::YAMLish::Reader ();use TAP::Parser::YAMLish::Writer ();use base 'TAP::Base';BEGIN {__PACKAGE__->mk_methods('result_class')}use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant NEED_GLOB=>IS_WIN32;our$VERSION='3.35';sub new {my$class=shift;my%args=%{shift || {}};my$self=bless {select=>[],seq=>1,store=>delete$args{store},extensions=>(delete$args{extensions}|| ['.t']),result_class=>(delete$args{result_class}|| 'App::Prove::State::Result'),},$class;$self->{_}=$self->result_class->new({tests=>{},generation=>1,});my$store=$self->{store};$self->load($store)if defined$store && -f $store;return$self}sub extensions {my$self=shift;$self->{extensions}=shift if @_;return$self->{extensions}}sub results {my$self=shift;$self->{_}|| $self->result_class->new}sub commit {my$self=shift;if ($self->{should_save}){$self->save}}sub apply_switch {my$self=shift;my@opts=@_;my$last_gen=$self->results->generation - 1;my$last_run_time=$self->results->last_run_time;my$now=$self->get_time;my@switches=map {split /,/}@opts;my%handler=(last=>sub {$self->_select(limit=>shift,where=>sub {$_->generation >= $last_gen},order=>sub {$_->sequence})},failed=>sub {$self->_select(limit=>shift,where=>sub {$_->result!=0},order=>sub {-$_->result})},passed=>sub {$self->_select(limit=>shift,where=>sub {$_->result==0})},all=>sub {$self->_select(limit=>shift)},todo=>sub {$self->_select(limit=>shift,where=>sub {$_->num_todo!=0},order=>sub {-$_->num_todo})},hot=>sub {$self->_select(limit=>shift,where=>sub {defined $_->last_fail_time},order=>sub {$now - $_->last_fail_time})},slow=>sub {$self->_select(limit=>shift,order=>sub {-$_->elapsed})},fast=>sub {$self->_select(limit=>shift,order=>sub {$_->elapsed})},new=>sub {$self->_select(limit=>shift,order=>sub {-$_->mtime})},old=>sub {$self->_select(limit=>shift,order=>sub {$_->mtime})},fresh=>sub {$self->_select(limit=>shift,where=>sub {$_->mtime >= $last_run_time})},save=>sub {$self->{should_save}++},adrian=>sub {unshift@switches,qw(hot all save)},);while (defined(my$ele=shift@switches)){my ($opt,$arg)=($ele =~ /^([^:]+):(.*)/)? ($1,$2): ($ele,undef);my$code=$handler{$opt}|| croak "Illegal state option: $opt";$code->($arg)}return}sub _select {my ($self,%spec)=@_;push @{$self->{select}},\%spec}sub get_tests {my$self=shift;my$recurse=shift;my@argv=@_;my%seen;my@selected=$self->_query;unless (@argv || @{$self->{select}}){@argv=$recurse ? '.' : 't';croak qq{No tests named and '@argv' directory not found} unless -d $argv[0]}push@selected,$self->_get_raw_tests($recurse,@argv)if@argv;return grep {!$seen{$_}++}@selected}sub _query {my$self=shift;if (my@sel=@{$self->{select}}){warn "No saved state, selection will be empty\n" unless$self->results->num_tests;return map {$self->_query_clause($_)}@sel}return}sub _query_clause {my ($self,$clause)=@_;my@got;my$results=$self->results;my$where=$clause->{where}|| sub {1};for my$name ($results->test_names){next unless -f $name;local $_=$results->test($name);push@got,$name if$where->()}if (my$order=$clause->{order}){@got=map {$_->[0]}sort {(defined$b->[1]<=> defined$a->[1])|| (($a->[1]|| 0)<=> ($b->[1]|| 0))}map {[$_,do {local $_=$results->test($_);$order->()}]}@got}if (my$limit=$clause->{limit}){@got=splice@got,0,$limit if@got > $limit}return@got}sub _get_raw_tests {my$self=shift;my$recurse=shift;my@argv=@_;my@tests;if (NEED_GLOB){eval "use File::Glob::Windows";@argv=map {glob "$_"}@argv}my$extensions=$self->{extensions};for my$arg (@argv){if ('-' eq $arg){push@argv=><STDIN>;chomp(@argv);next}push@tests,sort -d $arg ? $recurse ? $self->_expand_dir_recursive($arg,$extensions): map {glob(File::Spec->catfile($arg,"*$_"))}@{$extensions}: $arg}return@tests}sub _expand_dir_recursive {my ($self,$dir,$extensions)=@_;my@tests;my$ext_string=join('|',map {quotemeta}@{$extensions});find({follow=>1,follow_skip=>2,wanted=>sub {-f && /(?:$ext_string)$/ && push@tests=>$File::Find::name}},$dir);return@tests}sub observe_test {my ($self,$test_info,$parser)=@_;my$name=$test_info->[0];my$fail=scalar($parser->failed)+ ($parser->has_problems ? 1 : 0);my$todo=scalar($parser->todo);my$start_time=$parser->start_time;my$end_time=$parser->end_time,my$test=$self->results->test($name);$test->sequence($self->{seq}++);$test->generation($self->results->generation);$test->run_time($end_time);$test->result($fail);$test->num_todo($todo);$test->elapsed($end_time - $start_time);$test->parser($parser);if ($fail){$test->total_failures($test->total_failures + 1);$test->last_fail_time($end_time)}else {$test->total_passes($test->total_passes + 1);$test->last_pass_time($end_time)}}sub save {my ($self)=@_;my$store=$self->{store}or return;$self->results->last_run_time($self->get_time);my$writer=TAP::Parser::YAMLish::Writer->new;local*FH;open FH,">$store" or croak "Can't write $store ($!)";$writer->write($self->results->raw,\*FH);close FH}sub load {my ($self,$name)=@_;my$reader=TAP::Parser::YAMLish::Reader->new;local*FH;open FH,"<$name" or croak "Can't read $name ($!)";$self->{_}=$self->result_class->new($reader->read(sub {my$line=<FH>;defined$line && chomp$line;return$line}));close FH;$self->_regen_seq;$self->_prune_and_stamp;$self->results->generation($self->results->generation + 1)}sub _prune_and_stamp {my$self=shift;my$results=$self->results;my@tests=$self->results->tests;for my$test (@tests){my$name=$test->name;if (my@stat=stat$name){$test->mtime($stat[9])}else {$results->remove($name)}}}sub _regen_seq {my$self=shift;for my$test ($self->results->tests){$self->{seq}=$test->sequence + 1 if defined$test->sequence && $test->sequence >= $self->{seq}}}1;
APP_PROVE_STATE

$fatpacked{"App/Prove/State/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT';
  package App::Prove::State::Result;use strict;use warnings;use Carp 'croak';use App::Prove::State::Result::Test;use constant STATE_VERSION=>1;our$VERSION='3.35';sub new {my ($class,$arg_for)=@_;$arg_for ||= {};my%instance_data=%$arg_for;$instance_data{version}=$class->state_version;my$tests=delete$instance_data{tests}|| {};my$self=bless \%instance_data=>$class;$self->_initialize($tests);return$self}sub _initialize {my ($self,$tests)=@_;my%tests;while (my ($name,$test)=each %$tests){$tests{$name}=$self->test_class->new({%$test,name=>$name})}$self->tests(\%tests);return$self}sub state_version {STATE_VERSION}sub test_class {return 'App::Prove::State::Result::Test'}my%methods=(generation=>{method=>'generation',default=>0 },last_run_time=>{method=>'last_run_time',default=>undef },);while (my ($key,$description)=each%methods){my$default=$description->{default};no strict 'refs';*{$description->{method}}=sub {my$self=shift;if (@_){$self->{$key}=shift;return$self}return$self->{$key}|| $default}}sub tests {my$self=shift;if (@_){$self->{tests}=shift;return$self}my%tests=%{$self->{tests}};my@tests=sort {$a->sequence <=> $b->sequence}values%tests;return wantarray ? @tests : \@tests}sub test {my ($self,$name)=@_;croak("test() requires a test name")unless defined$name;my$tests=$self->{tests}||= {};if (my$test=$tests->{$name}){return$test}else {my$test=$self->test_class->new({name=>$name });$self->{tests}->{$name}=$test;return$test}}sub test_names {my$self=shift;return map {$_->name}$self->tests}sub remove {my ($self,$name)=@_;delete$self->{tests}->{$name};return$self}sub num_tests {keys %{shift->{tests}}}sub raw {my$self=shift;my%raw=%$self;my%tests;for my$test ($self->tests){$tests{$test->name }=$test->raw}$raw{tests}=\%tests;return \%raw}1;
APP_PROVE_STATE_RESULT

$fatpacked{"App/Prove/State/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PROVE_STATE_RESULT_TEST';
  package App::Prove::State::Result::Test;use strict;use warnings;our$VERSION='3.35';my%methods=(name=>{method=>'name' },elapsed=>{method=>'elapsed',default=>0 },gen=>{method=>'generation',default=>1 },last_pass_time=>{method=>'last_pass_time',default=>undef },last_fail_time=>{method=>'last_fail_time',default=>undef },last_result=>{method=>'result',default=>0 },last_run_time=>{method=>'run_time',default=>undef },last_todo=>{method=>'num_todo',default=>0 },mtime=>{method=>'mtime',default=>undef },seq=>{method=>'sequence',default=>1 },total_passes=>{method=>'total_passes',default=>0 },total_failures=>{method=>'total_failures',default=>0 },parser=>{method=>'parser' },);while (my ($key,$description)=each%methods){my$default=$description->{default};no strict 'refs';*{$description->{method}}=sub {my$self=shift;if (@_){$self->{$key}=shift;return$self}return$self->{$key}|| $default}}sub new {my ($class,$arg_for)=@_;$arg_for ||= {};bless$arg_for=>$class}sub raw {my$self=shift;my%raw=%$self;delete$raw{name};delete$raw{parser};return \%raw}1;
APP_PROVE_STATE_RESULT_TEST

$fatpacked{"App/stew.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW';
  package App::stew;use 5.008001;use strict;use warnings;our$VERSION="0.01";1;
APP_STEW

$fatpacked{"App/stew/builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_BUILDER';
  package App::stew::builder;use strict;use warnings;use Cwd qw(abs_path getcwd);use Carp qw(croak);use File::Path qw(rmtree);use File::Basename qw(basename dirname);use App::stew::util qw(cmd info debug error _chdir _mkpath _copy _rmtree _tree);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{root_dir}=$params{root_dir};$self->{build_dir}=$params{build_dir};$self->{repo}=$params{repo};$self->{snapshot}=$params{snapshot};return$self}sub build {my$self=shift;my ($stew_tree,$mode)=@_;my$stew=$stew_tree->{stew};croak '$ENV{PREFIX} not defined' unless$ENV{PREFIX};_mkpath($ENV{PREFIX});info sprintf "Building '%s'...",$stew->package;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);my$cwd=getcwd();my$tree=[];eval {_rmtree$work_dir;_mkpath($work_dir);_chdir($work_dir);info sprintf "Checking dependencies...",$stew->package;$self->_resolve_dependencies($stew,$stew_tree);my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);my$dist_archive=basename$dist_path;my ($dist_name)=$dist_archive =~ m/^(.*)\.tar\.gz$/;_chdir($work_dir);$tree=$self->_build_from_source($stew,$dist_name);if (!$stew->is('cross-platform')){_chdir($work_dir);cmd("tar czhf $dist_archive -C $dist_name/$ENV{PREFIX}/ .");info sprintf "Saving '%s' as '$dist_path'...",$stew->package;_mkpath(dirname$dist_path);_copy$dist_archive,$dist_path}_chdir($cwd)}or do {my$e=$@;_chdir($cwd);die$e};return$tree}sub _build_from_source {my$self=shift;my ($stew,$dist_name)=@_;_mkpath($ENV{PREFIX});_mkpath$dist_name;$ENV{DESTDIR}=abs_path($dist_name);my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_mkpath$work_dir;_chdir($work_dir);if ($stew->url){my$src_file=$self->{repo}->mirror_file($stew->url,File::Spec->catfile($self->{repo}->{mirror_path},'src'));_copy($src_file,$work_dir)}else {my$src_file=$self->{repo}->mirror_src($stew->file);_copy($src_file,$work_dir);if (my@files=$stew->files){for my$file (@files){my$src_file=$self->{repo}->mirror_src($file);_copy($src_file,$work_dir)}}}info sprintf "Preparing '%s'...",$stew->package;$self->_run_stew_phase($stew,'prepare');info sprintf "Building '%s'...",$stew->package;$self->_run_stew_phase($stew,'build');info sprintf "Installing '%s'...",$stew->package;$self->_run_stew_phase($stew,'install');info sprintf "Cleaning '%s'...",$stew->package;$self->_run_stew_phase($stew,'cleanup');_chdir "$ENV{DESTDIR}/$ENV{PREFIX}";return _tree('.','.')}sub _run_stew_phase {my$self=shift;my ($stew,$phase)=@_;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_chdir($work_dir);my@commands=$stew->run($phase);cmd(@commands)}sub _resolve_dependencies {my$self=shift;my ($stew,$tree)=@_;my$build_dir=$self->{build_dir};my$work_dir=File::Spec->catfile($build_dir,$stew->package);my@makedepends=@{$tree->{make_dependencies}|| []};if (@makedepends){info "Found make dependencies: " .join(', ',map {$_->{stew}->package}@makedepends)}for my$tree (@makedepends){my$stew=$tree->{stew};_chdir($self->{root_dir});info sprintf "Preparing make dependency '%s'",$stew->package;$self->_run_stew_phase($stew,'prepare');_chdir($self->{root_dir});my$to=sprintf '%s/%s',$work_dir,$stew->package;if (!-e $to){cmd(sprintf "ln -s $build_dir/%s/%s $to",$stew->package,$stew->package)}}my@depends=@{$tree->{dependencies}|| []};for my$tree (@depends){my$stew=$tree->{stew};die$stew->package ." is not installed\n" unless$self->{snapshot}->is_up_to_date($stew->name,$stew->version)}}1;
APP_STEW_BUILDER

$fatpacked{"App/stew/cmd/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_BUILD';
  package App::stew::cmd::build;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::repo;use App::stew::builder;use App::stew::index;use App::stew::tree;use App::stew::env;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_repo;my$opt_os;my$opt_arch;my$opt_build_dir='build';my$opt_verbose;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"repo=s"=>\$opt_repo,"os=s"=>\$opt_os,"arch=s"=>\$opt_arch,"build-dir=s"=>\$opt_build_dir,"verbose"=>\$opt_verbose,)or die "error";$opt_os //= App::stew::env->detect_os;$opt_arch //= App::stew::env->detect_arch;error("--base is required")unless$opt_base;error("--repo is required")unless$opt_repo;mkpath($opt_base);$opt_base=abs_path($opt_base);my$root_dir=abs_path(cwd());my$build_dir=abs_path($opt_build_dir);mkpath($build_dir);$ENV{STEW_LOG_LEVEL}=$opt_verbose ? 1 : 0;$ENV{STEW_LOG_FILE}="$build_dir/stew.log";unlink$ENV{STEW_LOG_FILE};my$repo=App::stew::repo->new(path=>$opt_repo,mirror_path=>"$build_dir/.cache",os=>$opt_os,arch=>$opt_arch);my$index=App::stew::index->new(repo=>$repo);my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;my@trees;for my$package (@argv){my$tree=App::stew::tree->new(repo=>$repo,index=>$index);my$dump=$tree->build($package);push@trees,$dump}$ENV{STEW_OS}=$opt_os;$ENV{STEW_ARCH}=$opt_arch;$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->setup;my$builder=App::stew::builder->new(root_dir=>$root_dir,build_dir=>$build_dir,repo=>$repo,snapshot=>$snapshot,);for my$tree (@trees){$builder->build($tree)}info "Done"}1;
APP_STEW_CMD_BUILD

$fatpacked{"App/stew/cmd/exec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_EXEC';
  package App::stew::cmd::exec;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::env;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,)or die "error";error("--base is required")unless$opt_base;$opt_base=abs_path($opt_base);$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->setup;system(@argv)}1;
APP_STEW_CMD_EXEC

$fatpacked{"App/stew/cmd/install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_INSTALL';
  package App::stew::cmd::install;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use Cwd qw(cwd abs_path);use File::Path qw(mkpath);use File::Spec;use App::stew::repo;use App::stew::installer;use App::stew::snapshot;use App::stew::index;use App::stew::tree;use App::stew::env;use App::stew::util qw(info debug error slurp_file);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_repo;my$opt_os;my$opt_arch;my$opt_build='build';my$opt_dry_run;my$opt_verbose;my$opt_from_source;my$opt_from_source_recursive;my$opt_reinstall;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"repo=s"=>\$opt_repo,"os=s"=>\$opt_os,"arch=s"=>\$opt_arch,"build=s"=>\$opt_build,"dry-run"=>\$opt_dry_run,"verbose"=>\$opt_verbose,"from-source"=>\$opt_from_source,"from-source-recursive"=>\$opt_from_source_recursive,"reinstall"=>\$opt_reinstall,)or die "error";$opt_os //= App::stew::env->detect_os;$opt_arch //= App::stew::env->detect_arch;error("--base is required")unless$opt_base;error("--repo is required")unless$opt_repo;mkpath($opt_base);$opt_base=abs_path($opt_base);my$root_dir=abs_path(cwd());my$build_dir=abs_path($opt_build);mkpath($build_dir);$ENV{STEW_LOG_LEVEL}=$opt_verbose ? 1 : 0;$ENV{STEW_LOG_FILE}="$build_dir/stew.log";unlink$ENV{STEW_LOG_FILE};my$repo=App::stew::repo->new(path=>$opt_repo,mirror_path=>"$build_dir/.cache",os=>$opt_os,arch=>$opt_arch);my$index=App::stew::index->new(repo=>$repo);my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;if (@argv==1 && $argv[0]eq '.'){die 'stewfile not found' unless -f 'stewfile';@argv=grep {$_ &&!/^#/}split /\n+/,slurp_file('stewfile')}my@trees;for my$package (@argv){my$tree=App::stew::tree->new(repo=>$repo,index=>$index);my$dump=$tree->build($package);push@trees,$dump}$ENV{STEW_OS}=$opt_os;$ENV{STEW_ARCH}=$opt_arch;$ENV{PREFIX}=File::Spec->catfile($opt_base,$opt_prefix);App::stew::env->setup;my$builder=App::stew::installer->new(root_dir=>$root_dir,build_dir=>$build_dir,repo=>$repo,snapshot=>$snapshot,from_source=>$opt_from_source,from_source_recursive=>$opt_from_source_recursive,reinstall=>$opt_reinstall,);for my$tree (@trees){$builder->build($tree)}info "Done"}1;
APP_STEW_CMD_INSTALL

$fatpacked{"App/stew/cmd/list_installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_LIST_INSTALLED';
  package App::stew::cmd::list_installed;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::util qw(info debug error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base)or die "error";error("--base is required")unless$opt_base;my$snapshot=App::stew::snapshot->new(base=>$opt_base)->load;for my$key (sort keys %$snapshot){print "$key $snapshot->{$key}->{version}\n"}}1;
APP_STEW_CMD_LIST_INSTALLED

$fatpacked{"App/stew/cmd/uninstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_UNINSTALL';
  package App::stew::cmd::uninstall;use strict;use warnings;use Getopt::Long qw(GetOptionsFromArray);use App::stew::snapshot;use App::stew::util qw(info debug error _unlink);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;return$self}sub run {my$self=shift;my (@argv)=@_;my$opt_base;my$opt_prefix='local';my$opt_verbose;GetOptionsFromArray(\@argv,"base=s"=>\$opt_base,"prefix=s"=>\$opt_prefix,"verbose"=>\$opt_verbose,)or die "error";error("--base is required")unless$opt_base;my (@packages)=@argv;my$snapshot=App::stew::snapshot->new(base=>$opt_base);$snapshot->load;for my$package (@packages){if (!$snapshot->is_installed($package)){warn "$package not installed. Skipping"}else {debug sprintf "Uninstalling '%s'...",$package;my$info=$snapshot->get_package($package);for my$file (@{$info->{files}}){_unlink "$opt_base/$opt_prefix/$file"}$snapshot->mark_uninstalled($package)}}}1;
APP_STEW_CMD_UNINSTALL

$fatpacked{"App/stew/env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_ENV';
  package App::stew::env;use strict;use warnings;use Config;use App::stew::util qw(debug slurp_file);sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub setup {my$self=shift;_unshift_env(PATH=>"$ENV{PREFIX}/bin");_unshift_env(LIBPATH=>"$ENV{PREFIX}/lib");_unshift_env(LIBRARY_PATH=>"$ENV{PREFIX}/lib");_unshift_env(LD_LIBRARY_PATH=>"$ENV{PREFIX}/lib");_unshift_env(CPATH=>"$ENV{PREFIX}/include");_unshift_env(C_INCLUDE_PATH=>"$ENV{PREFIX}/include");_unshift_env(CPLUS_INCLUDE_PATH=>"$ENV{PREFIX}/include")}sub detect_os {my$self=shift;my$os=$self->_osname;if ($os eq 'linux'){my$debian_version=$self->_root .'etc/debian_version';my$suse_version=$self->_root .'etc/SuSE-release';my$redhat_version=$self->_root .'etc/redhat-release';my$dist_name='generic';my$dist_ver='';if (-f $debian_version){$dist_name='debian';my$content=slurp_file$debian_version;my ($ver)=$content =~ m/(\d+)/;$dist_ver=$ver if$ver}elsif (-f $suse_version){$dist_name='suse';my$content=slurp_file$suse_version;my ($ver)=$content =~ m/VERSION\s*=\s*(\d+)/;$dist_ver=$ver if$ver}elsif (-f $redhat_version){my$content=slurp_file$redhat_version;if ($content =~ m/centos/i){$dist_name='centos'}elsif ($content =~ m/red\s*hat/i){$dist_name='redhat'}my ($ver)=$content =~ m/release\s*(\d+)/;$dist_ver=$ver if$ver}$os .= "-$dist_name";$os .= "-$dist_ver" if$dist_ver}return$os}sub detect_arch {my$self=shift;my$arch;chomp($arch //= `uname -m`);$arch=lc$arch;return$arch}sub _osname {$^O}sub _root {'/'}sub _unshift_env {my ($var,$value)=@_;if ($ENV{$var}){$ENV{$var}="$value:$ENV{$var}"}else {$ENV{$var}=$value}debug "Setting ENV{$var}=$ENV{$var}"}1;
APP_STEW_ENV

$fatpacked{"App/stew/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_FILE';
  package App::stew::file;use strict;use warnings;use App::stew::util qw(slurp_file error);sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub parse {my$class=shift;my ($stew_file,$type)=@_;my$content=slurp_file($stew_file);my$stew_class=$class->_sandbox($stew_file,$content,$type);return$stew_class->new}sub _sandbox {my$self=shift;my ($file,$content,$type)=@_;$type='' unless defined$type;my$class_name='stew::_build_' ._rand_str();my$package=<<"EOP";eval$package or error("Error compiling '$file': $@");return$class_name}sub _rand_str {my@alpha=('0' .. '9','a' .. 'z','A' .. 'Z');my$str='';$str .= $alpha[rand($#alpha)]for 1 .. 16;return$str}1;
      package $class_name;
      use strict;
      use warnings;
      my \$name;
      my \$version;
      my \$package;
      my \$file;
      my \@files;
      my \$url;
      my \@depends;
      my \@makedepends;
      my \@flags;
  
      sub new {
          my \$class = shift;
  
          my \$self = {};
          bless \$self, \$class;
  
          return \$self;
      }
  
      sub is_dependency     { '$type' eq 'depends' }
      sub is_makedependency { '$type' eq 'makedepends' }
  
      sub name        { \$name }
      sub version     { \$version }
      sub package     { \$package }
      sub file        { \$file }
      sub files       { \@files }
      sub url         { \$url }
      sub depends     { \@depends }
      sub makedepends { \@makedepends }
      sub flags       { \@flags }
  
      my \$phases = {};
      sub download(&) { \$phases->{download}    = shift }
      sub prepare(&)  { \$phases->{prepare}     = shift }
      sub build(&)    { \$phases->{build}       = shift }
      sub install(&)  { \$phases->{install}     = shift }
      sub cleanup(&)  { \$phases->{cleanup} = shift }
  
      sub phase { \$phases->{\$_[1]} }
  
      sub is {
          my \$self = shift;
          my (\$flag) = \@_;
  
          return !!grep { \$_ eq \$flag } \$self->flags;
      }
  
      sub run {
          my \$self = shift;
          my (\$phase) = \@_;
  
          if (\$phases->{\$phase}) {
              return \$phases->{\$phase}->()
          }
  
          return;
      }
      $content
      1;
  EOP
APP_STEW_FILE

$fatpacked{"App/stew/index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_INDEX';
  package App::stew::index;use strict;use warnings;use Carp qw(croak);use List::Util qw(first);use App::stew::util qw(error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{repo}=$params{repo}or croak 'repo required';return$self}sub resolve {my$self=shift;my ($need)=@_;my$name=$need;my$op;my$version;if ($need =~ m/^(.*?)(==|>=?|<=?)(.*)$/){$name=$1;$op=$2;$version=$3}$self->{index}||= $self->_read_index;my@packages;for my$package (@{$self->{index}}){push@packages,$package if$package->{name}eq $name}if (!$op){my$package=$packages[-1];return unless$package;return$package->{full}}elsif ($op eq '=='){my$package=first {$_->{version}eq $version}@packages;return unless$package;return$package->{full}}elsif ($op eq '>='){my$package=first {$_->{version}ge $version}@packages;return unless$package;return$package->{full}}elsif ($op eq '>'){my@packages=grep {$_->{version}gt $version}@packages;return unless@packages;return$packages[-1]->{full}}return}sub _read_index {my$self=shift;my$index_file=$self->{repo}->mirror_index;my@index;open my$fh,'<',$index_file or error "Can't read index file '$index_file': $!";for my$line (<$fh>){chomp$line;next unless$line =~ m/^stew\/(.*?)_(.*?)\.stew$/;push@index,{name=>$1,version=>$2,full=>"$1_$2" }}close$fh;return \@index}1;
APP_STEW_INDEX

$fatpacked{"App/stew/installer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_INSTALLER';
  package App::stew::installer;use strict;use warnings;use Cwd qw(abs_path getcwd);use Carp qw(croak);use File::Path qw(rmtree);use File::Basename qw(basename dirname);use App::stew::builder;use App::stew::util qw(cmd info debug error _chdir _mkpath _rmtree _copy _unlink _tree _tree_diff);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{root_dir}=$params{root_dir};$self->{build_dir}=$params{build_dir};$self->{repo}=$params{repo};$self->{snapshot}=$params{snapshot};$self->{from_source}=$params{from_source};$self->{from_source_recursive}=$params{from_source_recursive};$self->{reinstall}=$params{reinstall};return$self}sub build {my$self=shift;my ($stew_tree,$mode)=@_;my$stew=$stew_tree->{stew};my$reinstall=!$mode && $self->{reinstall};my$from_source=$self->{from_source_recursive}|| (!$mode && $self->{from_source});if (!$reinstall && $self->{snapshot}->is_up_to_date($stew->name,$stew->version)){info sprintf "'%s' is up to date",$stew->package;return}croak '$ENV{PREFIX} not defined' unless$ENV{PREFIX};_mkpath($ENV{PREFIX});info sprintf "Building & installing '%s'...",$stew->package;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_rmtree$work_dir;_mkpath($work_dir);my$cwd=getcwd();my$tree=[];eval {info sprintf "Resolving dependencies...",$stew->package;$self->_resolve_dependencies($stew,$stew_tree);if ($stew->is('cross-platform')){info sprintf 'Cross platform package';my$builder=$self->_build_builder;$tree=$builder->build($stew_tree);my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);my$dist_archive=basename$dist_path;my ($dist_name)=$dist_archive =~ m/^(.*)\.tar\.gz$/;_chdir$work_dir;_chdir "$dist_name/$ENV{PREFIX}";cmd("cp --remove-destination -ra * $ENV{PREFIX}/")}elsif ($stew->is('meta')){info sprintf 'Meta package'}else {my$dist_path=$self->{repo}->mirror_dist_dest($stew->name,$stew->version);eval {$self->{repo}->mirror_dist($stew->name,$stew->version)};my$dist_path_basename=basename$dist_path;error("Distribution '$dist_path_basename' not available. Maybe build from source?")if!$from_source &&!-f $dist_path;if ($from_source ||!-f $dist_path){my$builder=$self->_build_builder;$tree=$builder->build($stew_tree)}$self->_install_from_binary($stew,$dist_path)}_chdir($cwd)}or do {my$e=$@;_chdir($cwd);die$e};info sprintf "Done installing '%s'",$stew->package;$self->{snapshot}->mark_installed($stew->name,$stew->version,$tree);return$self}sub _install_from_binary {my$self=shift;my ($stew,$dist_path)=@_;info sprintf "Installing '%s' from binaries '%s'...",$stew->package,$dist_path;my$basename=basename$dist_path;my$work_dir=File::Spec->catfile($self->{build_dir},$stew->package);_chdir$work_dir;my ($dist_name)=$basename =~ m/^(.*)\.tar\.gz$/;_rmtree$dist_name;_mkpath$dist_name;_copy($dist_path,"$dist_name/$basename");_chdir$dist_name;cmd("tar xzf $basename");_unlink$basename;cmd("cp --remove-destination -ra * $ENV{PREFIX}/");return _tree(".",".")}sub _resolve_dependencies {my$self=shift;my ($stew,$tree)=@_;my@depends=@{$tree->{dependencies}|| []};if (@depends){info "Found dependencies: " .join(', ',map {$_->{stew}->package}@depends)}for my$tree (@depends){my$stew=$tree->{stew};_chdir($self->{root_dir});$self->build($tree,'dep');_chdir($self->{root_dir})}}sub _build_builder {my$self=shift;return App::stew::builder->new(root_dir=>$self->{root_dir},build_dir=>$self->{build_dir},repo=>$self->{repo},snapshot=>$self->{snapshot},)}1;
APP_STEW_INSTALLER

$fatpacked{"App/stew/repo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_REPO';
  package App::stew::repo;use strict;use warnings;use HTTP::Tiny;use File::Basename qw(dirname basename);use File::Path ();use Carp qw(croak);use App::stew::util qw(error debug _copy _mkpath);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{path}=$params{path}or croak 'path required';$self->{path}.= '/' unless$self->{path}=~ m{/$};$self->{mirror_path}=$params{mirror_path}or croak 'mirror_path required';$self->{mirror_path}.= '/' unless$self->{mirror_path}=~ m{/$};$self->{os}=$params{os}or croak 'os required';$self->{arch}=$params{arch}or croak 'arch required';$self->{ua}=$params{ua};return$self}sub mirror_stew {my$self=shift;my ($name)=@_;my$full_name=$self->{path}.File::Spec->catfile('stew',$name .'.stew');return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'stew'))}sub mirror_src {my$self=shift;my ($filename)=@_;my$full_name=$self->{path}.File::Spec->catfile('src',$filename);return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'src'))}sub mirror_dist_dest {my$self=shift;my ($name,$version)=@_;my$os=$self->{os};my$arch=$self->{arch};return File::Spec->catfile($self->{mirror_path},'dist',$os,$arch,"${name}_${version}_$os-$arch.tar.gz")}sub mirror_dist {my$self=shift;my ($name,$version)=@_;croak 'name required' unless$name;croak 'version required ' unless$version;my$os=$self->{os};my$arch=$self->{arch};my$full_name=$self->{path}.File::Spec->catfile('dist',$os,$arch,"${name}_${version}_$os-$arch.tar.gz");return$self->mirror_file($full_name,File::Spec->catfile($self->{mirror_path},'dist',$os,$arch))}sub mirror_index {my$self=shift;my@index;if ($self->{path}=~ m/^http/){my$ua=$self->{ua}|| HTTP::Tiny->new;for my$type (qw(stew src)){my$response=$ua->get("$self->{path}$type");if ($response->{success}){my$content=$response->{content};while ($content =~ m#<a href="(.*?\.(?:stew|tar\.gz))">.*?</a>#g){push@index,"$type/$1"}}}}else {for my$type (qw(stew src)){opendir my$dh,"$self->{path}/$type" or error "Can't open directory '$self->{path}/$type': $!";push@index,map {"$type/$_"}grep {!/^\./ && -f "$self->{path}/$type/$_"}readdir($dh);closedir$dh}}my$to=File::Spec->catfile($self->{mirror_path},'index');_mkpath dirname$to;open my$fh,'>',$to or die "Can't create file '$to': $!";print$fh "$_\n" for sort@index;close$fh;return$to}sub mirror_file {my$self=shift;my ($in,$to_dir)=@_;_mkpath($to_dir);debug("Mirroring '$in' to '$to_dir'");my$to=File::Spec->catfile($to_dir,basename$in);if (-e $to){debug("File '$to' exists. Skipping");return$to}if ($in =~ m/^http/){my$ua=$self->{ua}|| HTTP::Tiny->new;$ua->mirror($in,$to)}else {error "File '$in' does not exist" unless -f $in;_copy($in,$to)}return$to}1;
APP_STEW_REPO

$fatpacked{"App/stew/snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_SNAPSHOT';
  package App::stew::snapshot;use strict;use warnings;use File::Spec ();use Data::Dumper ();use Carp qw(croak);use App::stew::util qw(slurp_file write_file);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base}=$params{base};croak 'base is required' unless$self->{base};$self->{snapshot}={};$self->load;return$self}sub is_installed {my$self=shift;my ($package)=@_;if ($self->{snapshot}->{$package}){return 1}return 0}sub is_up_to_date {my$self=shift;my ($package,$version)=@_;return 0 unless$self->is_installed($package);return 0 unless$self->{snapshot}->{$package}->{version}eq $version;return 1}sub get_package {my$self=shift;my ($package)=@_;return$self->{snapshot}->{$package}}sub load {my$self=shift;my$install_file=$self->_install_file;my$installed={};if (-e $install_file){no strict;$installed=eval slurp_file($install_file)}$self->{snapshot}=$installed;return$self->{snapshot}}sub mark_installed {my$self=shift;my ($name,$version,$files)=@_;$self->{snapshot}->{$name}={version=>$version,files=>$files};$self->store;return$self}sub mark_uninstalled {my$self=shift;my ($name)=@_;delete$self->{snapshot}->{$name};$self->store;return$self}sub store {my$self=shift;write_file($self->_install_file,Data::Dumper::Dumper($self->{snapshot}));return$self}sub _install_file {my$self=shift;return File::Spec->catfile($self->{base},'stew.snapshot')}1;
APP_STEW_SNAPSHOT

$fatpacked{"App/stew/tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_TREE';
  package App::stew::tree;use strict;use warnings;use Carp qw(croak);use App::stew::file;use App::stew::util qw(error);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{repo}=$params{repo}or croak 'repo required';$self->{index}=$params{index}or croak 'index required';return$self}sub build {my$self=shift;my ($stew_expr,$type)=@_;my$stew_name=$self->{index}->resolve($stew_expr);error "Can't find package satisfying '$stew_expr'" unless$stew_name;my$stew_file=$self->_download_stew($stew_name,$type);my$stew=$self->_parse_stew($stew_file,$type);my$tree={stew=>$stew,make_dependencies=>[],dependencies=>[]};my@makedepends=$stew->makedepends;for my$makedepends (@makedepends){push @{$tree->{make_dependencies}},$self->build($makedepends,'makedepends')}my@depends=$stew->depends;for my$depends (@depends){push @{$tree->{dependencies}},$self->build($depends,'depends')}return$tree}sub flatten {my$self=shift;my ($tree)=@_;my@list;for my$make_dep (@{$tree->{make_dependencies}}){push@list,$self->flatten($make_dep)}for my$dep (@{$tree->{dependencies}}){push@list,$self->flatten($dep)}push@list,$tree->{stew};return@list}sub flatten_dependencies {my$self=shift;my ($tree)=@_;my@list;for my$make_dep (@{$tree->{make_dependencies}}){push@list,$self->flatten($make_dep)}for my$dep (@{$tree->{dependencies}}){push@list,$self->flatten($dep)}return@list}sub _download_stew {my$self=shift;my ($stew_name)=@_;return$self->{repo}->mirror_stew($stew_name)}sub _parse_stew {my$self=shift;my ($file,$type)=@_;return App::stew::file->parse($file,$type)}1;
APP_STEW_TREE

$fatpacked{"App/stew/util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_UTIL';
  package App::stew::util;use strict;use warnings;use base 'Exporter';our@EXPORT_OK=qw(info debug error slurp_file write_file cmd _chdir _mkpath _rmtree _copy _unlink _tree _tree_diff);use File::Find qw(find);use Carp qw(croak);use File::Copy qw(copy);use File::Basename qw(dirname);use File::Path qw(mkpath rmtree);sub slurp_file {my ($file)=@_;local $/;open my$fh,'<',$file or error("Can't read file '$file': $!");return <$fh>}sub write_file {my ($file,$content)=@_;open my$fh,'>',$file or error("Can't write file '$file': $!");print$fh $content;close$fh}sub debug {print STDERR @_,"\n" if$ENV{STEW_LOG_LEVEL};_log(@_)}sub info {_log(@_);warn join(' ',@_)."\n"}sub error {_log(@_);croak("ERROR: " .join(' ',@_))}sub _chdir {my ($dir)=@_;debug(qq{Entering '$dir'});die "Directory '$dir' does not exist" unless -d $dir;chdir($dir)}sub _mkpath {my ($dir)=@_;debug(qq{Creating '$dir'});mkpath($dir)}sub _rmtree {my ($dir)=@_;debug(qq{Removing '$dir'});rmtree($dir)}sub _copy {my ($from,$to)=@_;debug(qq{Copying '$from' -> '$to'});copy($from,$to)or croak "Cant copy '$from' -> '$to'"}sub _unlink {my ($file)=@_;debug(qq{Unlinking '$file'});unlink($file)}sub cmd {return unless @_;my$cmd=join ' && ',@_;$cmd="sh -c \"$cmd 2>&1\" 2>&1 >> $ENV{STEW_LOG_FILE}";debug($cmd);my$exit=system($cmd);error("Command failed: $cmd")if$exit}sub _log {open my$fh,'>>',$ENV{STEW_LOG_FILE}or die "Can't open logfile '$ENV{STEW_LOG_FILE}': $!";print$fh @_,"\n";close$fh}sub _tree {my ($dir,$prefix)=@_;my@tree;find(sub {return unless -f $_;my$name=$File::Find::name;if ($prefix){$name =~ s{^$prefix/?}{}}push@tree,$name},$dir);return [sort@tree]}sub _tree_diff {my ($tree1,$tree2)=@_;my@diff;my$diff_pos=0;for (my$pos=0;$pos < @$tree1;$pos++){while ($diff_pos < @$tree2 && $tree1->[$pos]ne $tree2->[$diff_pos]){push@diff,$tree2->[$diff_pos];$diff_pos++}if ($diff_pos < @$tree2 && $tree1->[$pos]eq $tree2->[$diff_pos]){$diff_pos++;next}last if$diff_pos >= @$tree2}while ($diff_pos < @$tree2){push@diff,$tree2->[$diff_pos];$diff_pos++}return \@diff}1;
APP_STEW_UTIL

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Module::Load;our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');load($package);$package->import()}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use Carp qw/croak/;use Config;use Text::ParseWords 3.24 qw/shellwords/;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return shellwords($string)}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use ExtUtils::Helpers::Unix qw/split_like_shell/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);my$newdirs;if ($arg =~ m#^~/#){$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs)}else {my@backup=File::Spec::Unix->splitdir(File::Spec::Unix->updir);$newdirs=File::Spec::Unix->catdir(@hdirs,@backup,@dirs)}$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use Config;use Carp qw/carp croak/;sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){_pl2bat(in=>$script,update=>1)}return}sub _pl2bat {my%opts=@_;$opts{ntargs}='-x -S %0 %*';$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9';$opts{stripsuffix}=qr/\.plx?/ unless exists$opts{stripsuffix};if (not exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//i;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}eq '-'}my$head=<<"EOT";$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail=<<'EOT';$tail =~ s/^\s+//gm;my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start='#!perl' unless$start =~ /^#!.*perl/;open my$in,'<',$opts{in}or croak "Can't open $opts{in}: $!";my@file=<$in>;close$in;for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= '#line '.(1+$headlines)."\n"}else {$line .= '#line '.($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=''}}open my$out,'>',$opts{out}or croak "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? ' -w' : ''),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close$out;return$opts{out}}sub split_like_shell {local ($_)=@_;my@argv;return@argv unless defined && length;my$arg='';my ($i,$quote_mode)=(0,0);while ($i < length){my$ch=substr $_,$i,1;my$next_ch=substr $_,$i+1,1;if ($ch eq '\\' && $next_ch eq '"'){$arg .= '"';$i++}elsif ($ch eq '\\' && $next_ch eq '\\'){$arg .= '\\';$i++}elsif ($ch eq '"' && $next_ch eq '"' && $quote_mode){$quote_mode=!$quote_mode;$arg .= '"';$i++}elsif ($ch eq '"' && $next_ch eq '"' &&!$quote_mode && ($i + 2==length()|| substr($_,$i + 2,1)eq ' ')){push@argv,$arg;$arg='';$i += 2}elsif ($ch eq '"'){$quote_mode=!$quote_mode}elsif ($ch =~ /\s/ &&!$quote_mode){push@argv,$arg if$arg;$arg='';++$i while substr($_,$i + 1,1)=~ /\s/}else {$arg .= $ch}$i++}push@argv,$arg if defined$arg && length$arg;return@argv}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
  	\@rem = '--*-Perl-*--
  	\@echo off
  	if "%OS%" == "Windows_NT" goto WinNT
  	perl $opts{otherargs}
  	\@set ErrorLevel=%ErrorLevel%
  	goto endofperl
  	:WinNT
  	perl $opts{ntargs}
  	\@set ErrorLevel=%ErrorLevel%
  	if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
  	if %errorlevel% == 9009 echo You do not have Perl in your PATH.
  	goto endofperl
  	\@rem ';
  EOT
  	__END__
  	:endofperl
  	@"%COMSPEC%" /c exit /b %ErrorLevel%
  EOT
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.011';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  package HTTP::Tiny;use strict;use warnings;our$VERSION='0.056';use Carp ();my@attributes;BEGIN {@attributes=qw(cookie_jar default_headers http_proxy https_proxy keep_alive local_address max_redirect max_size proxy no_proxy timeout SSL_options verify_SSL);my%persist_ok=map {;$_=>1}qw(cookie_jar default_headers max_redirect max_size);no strict 'refs';no warnings 'uninitialized';for my$accessor (@attributes){*{$accessor}=sub {@_ > 1 ? do {delete $_[0]->{handle}if!$persist_ok{$accessor}&& $_[1]ne $_[0]->{$accessor};$_[0]->{$accessor}=$_[1]}: $_[0]->{$accessor}}}}sub agent {my($self,$agent)=@_;if(@_ > 1){$self->{agent}=(defined$agent && $agent =~ / $/)? $agent .$self->_agent : $agent}return$self->{agent}}sub new {my($class,%args)=@_;my$self={max_redirect=>5,timeout=>60,keep_alive=>1,verify_SSL=>$args{verify_SSL}|| $args{verify_ssl}|| 0,no_proxy=>$ENV{no_proxy},};bless$self,$class;$class->_validate_cookie_jar($args{cookie_jar})if$args{cookie_jar};for my$key (@attributes){$self->{$key}=$args{$key}if exists$args{$key}}$self->agent(exists$args{agent}? $args{agent}: $class->_agent);$self->_set_proxies;return$self}sub _set_proxies {my ($self)=@_;if (!exists$self->{proxy}){$self->{proxy}=$ENV{all_proxy}|| $ENV{ALL_PROXY}}if (defined$self->{proxy}){$self->_split_proxy('generic proxy'=>$self->{proxy})}else {delete$self->{proxy}}if (!exists$self->{http_proxy}){local$ENV{HTTP_PROXY}if$ENV{REQUEST_METHOD};$self->{http_proxy}=$ENV{http_proxy}|| $ENV{HTTP_PROXY}|| $self->{proxy}}if (defined$self->{http_proxy}){$self->_split_proxy(http_proxy=>$self->{http_proxy});$self->{_has_proxy}{http}=1}else {delete$self->{http_proxy}}if (!exists$self->{https_proxy}){$self->{https_proxy}=$ENV{https_proxy}|| $ENV{HTTPS_PROXY}|| $self->{proxy}}if ($self->{https_proxy}){$self->_split_proxy(https_proxy=>$self->{https_proxy});$self->{_has_proxy}{https}=1}else {delete$self->{https_proxy}}unless (ref$self->{no_proxy}eq 'ARRAY'){$self->{no_proxy}=(defined$self->{no_proxy})? [split /\s*,\s*/,$self->{no_proxy}]: []}return}for my$sub_name (qw/get head put post delete/){my$req_method=uc$sub_name;no strict 'refs';eval <<"HERE"}sub post_form {my ($self,$url,$data,$args)=@_;(@_==3 || @_==4 && ref$args eq 'HASH')or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ ."\n");my$headers={};while (my ($key,$value)=each %{$args->{headers}|| {}}){$headers->{lc$key}=$value}delete$args->{headers};return$self->request('POST',$url,{%$args,content=>$self->www_form_urlencode($data),headers=>{%$headers,'content-type'=>'application/x-www-form-urlencoded' },})}sub mirror {my ($self,$url,$file,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ ."\n");if (-e $file and my$mtime=(stat($file))[9]){$args->{headers}{'if-modified-since'}||= $self->_http_date($mtime)}my$tempfile=$file .int(rand(2**31));require Fcntl;sysopen my$fh,$tempfile,Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);binmode$fh;$args->{data_callback}=sub {print {$fh}$_[0]};my$response=$self->request('GET',$url,$args);close$fh or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);if ($response->{success}){rename$tempfile,$file or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);my$lm=$response->{headers}{'last-modified'};if ($lm and my$mtime=$self->_parse_http_date($lm)){utime$mtime,$mtime,$file}}$response->{success}||= $response->{status}eq '304';unlink$tempfile;return$response}my%idempotent=map {$_=>1}qw/GET HEAD PUT DELETE OPTIONS TRACE/;sub request {my ($self,$method,$url,$args)=@_;@_==3 || (@_==4 && ref$args eq 'HASH')or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ ."\n");$args ||= {};my$response;for (0 .. 1){$response=eval {$self->_request($method,$url,$args)};last unless $@ && $idempotent{$method}&& $@ =~ m{^(?:Socket closed|Unexpected end)}}if (my$e=$@){if (ref$e eq 'HASH' && exists$e->{status}){return$e}$e="$e";$response={url=>$url,success=>q{},status=>599,reason=>'Internal Exception',content=>$e,headers=>{'content-type'=>'text/plain','content-length'=>length$e,}}}return$response}sub www_form_urlencode {my ($self,$data)=@_;(@_==2 && ref$data)or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ ."\n");(ref$data eq 'HASH' || ref$data eq 'ARRAY')or Carp::croak("form data must be a hash or array reference\n");my@params=ref$data eq 'HASH' ? %$data : @$data;@params % 2==0 or Carp::croak("form data reference must have an even number of terms\n");my@terms;while(@params){my ($key,$value)=splice(@params,0,2);if (ref$value eq 'ARRAY'){unshift@params,map {$key=>$_}@$value}else {push@terms,join("=",map {$self->_uri_escape($_)}$key,$value)}}return join("&",(ref$data eq 'ARRAY')? (@terms): (sort@terms))}sub can_ssl {my ($self)=@_;my($ok,$reason)=(1,'');unless (eval {require IO::Socket::SSL;IO::Socket::SSL->VERSION(1.42)}){$ok=0;$reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/}unless (eval {require Net::SSLeay;Net::SSLeay->VERSION(1.49)}){$ok=0;$reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/}if (ref($self)&& ($self->{verify_SSL}|| $self->{SSL_options}{SSL_verify_mode})){my$handle=HTTP::Tiny::Handle->new(SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},);unless (eval {$handle->_find_CA_file;1}){$ok=0;$reason .= "$@"}}wantarray ? ($ok,$reason): $ok}my%DefaultPort=(http=>80,https=>443,);sub _agent {my$class=ref($_[0])|| $_[0];(my$default_agent=$class)=~ s{::}{-}g;return$default_agent ."/" .$class->VERSION}sub _request {my ($self,$method,$url,$args)=@_;my ($scheme,$host,$port,$path_query,$auth)=$self->_split_url($url);my$request={method=>$method,scheme=>$scheme,host=>$host,port=>$port,host_port=>($port==$DefaultPort{$scheme}? $host : "$host:$port"),uri=>$path_query,headers=>{},};my$handle=delete$self->{handle};if ($handle){unless ($handle->can_reuse($scheme,$host,$port)){$handle->close;undef$handle}}$handle ||= $self->_open_handle($request,$scheme,$host,$port);$self->_prepare_headers_and_cb($request,$args,$url,$auth);$handle->write_request($request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');$self->_update_cookie_jar($url,$response)if$self->{cookie_jar};if (my@redir_args=$self->_maybe_redirect($request,$response,$args)){$handle->close;return$self->_request(@redir_args,$args)}my$known_message_length;if ($method eq 'HEAD' || $response->{status}=~ /^[23]04/){$known_message_length=1}else {my$data_cb=$self->_prepare_data_cb($response,$args);$known_message_length=$handle->read_body($data_cb,$response)}if ($self->{keep_alive}&& $known_message_length && $response->{protocol}eq 'HTTP/1.1' && ($response->{headers}{connection}|| '')ne 'close'){$self->{handle}=$handle}else {$handle->close}$response->{success}=substr($response->{status},0,1)eq '2';$response->{url}=$url;return$response}sub _open_handle {my ($self,$request,$scheme,$host,$port)=@_;my$handle=HTTP::Tiny::Handle->new(timeout=>$self->{timeout},SSL_options=>$self->{SSL_options},verify_SSL=>$self->{verify_SSL},local_address=>$self->{local_address},keep_alive=>$self->{keep_alive});if ($self->{_has_proxy}{$scheme}&&!grep {$host =~ /\Q$_\E$/}@{$self->{no_proxy}}){return$self->_proxy_connect($request,$handle)}else {return$handle->connect($scheme,$host,$port)}}sub _proxy_connect {my ($self,$request,$handle)=@_;my@proxy_vars;if ($request->{scheme}eq 'https'){Carp::croak(qq{No https_proxy defined})unless$self->{https_proxy};@proxy_vars=$self->_split_proxy(https_proxy=>$self->{https_proxy});if ($proxy_vars[0]eq 'https'){Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}})}}else {Carp::croak(qq{No http_proxy defined})unless$self->{http_proxy};@proxy_vars=$self->_split_proxy(http_proxy=>$self->{http_proxy})}my ($p_scheme,$p_host,$p_port,$p_auth)=@proxy_vars;if (length$p_auth &&!defined$request->{headers}{'proxy-authorization'}){$self->_add_basic_auth_header($request,'proxy-authorization'=>$p_auth)}$handle->connect($p_scheme,$p_host,$p_port);if ($request->{scheme}eq 'https'){$self->_create_proxy_tunnel($request,$handle)}else {$request->{uri}="$request->{scheme}://$request->{host_port}$request->{uri}"}return$handle}sub _split_proxy {my ($self,$type,$proxy)=@_;my ($scheme,$host,$port,$path_query,$auth)=eval {$self->_split_url($proxy)};unless(defined($scheme)&& length($scheme)&& length($host)&& length($port)&& $path_query eq '/'){Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n})}return ($scheme,$host,$port,$auth)}sub _create_proxy_tunnel {my ($self,$request,$handle)=@_;$handle->_assert_ssl;my$agent=exists($request->{headers}{'user-agent'})? $request->{headers}{'user-agent'}: $self->{agent};my$connect_request={method=>'CONNECT',uri=>"$request->{host}:$request->{port}",headers=>{host=>"$request->{host}:$request->{port}",'user-agent'=>$agent,}};if ($request->{headers}{'proxy-authorization'}){$connect_request->{headers}{'proxy-authorization'}=delete$request->{headers}{'proxy-authorization'}}$handle->write_request($connect_request);my$response;do {$response=$handle->read_response_header}until (substr($response->{status},0,1)ne '1');unless (substr($response->{status},0,1)eq '2'){die$response}$handle->start_ssl($request->{host});return}sub _prepare_headers_and_cb {my ($self,$request,$args,$url,$auth)=@_;for ($self->{default_headers},$args->{headers}){next unless defined;while (my ($k,$v)=each %$_){$request->{headers}{lc$k}=$v}}if (exists$request->{headers}{'host'}){die(qq/The 'Host' header must not be provided as header option\n/)}$request->{headers}{'host'}=$request->{host_port};$request->{headers}{'user-agent'}||= $self->{agent};$request->{headers}{'connection'}="close" unless$self->{keep_alive};if (defined$args->{content}){if (ref$args->{content}eq 'CODE'){$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'transfer-encoding'}='chunked' unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=$args->{content}}elsif (length$args->{content}){my$content=$args->{content};if ($] ge '5.008'){utf8::downgrade($content,1)or die(qq/Wide character in request message body\n/)}$request->{headers}{'content-type'}||= "application/octet-stream";$request->{headers}{'content-length'}=length$content unless$request->{headers}{'content-length'}|| $request->{headers}{'transfer-encoding'};$request->{cb}=sub {substr$content,0,length$content,''}}$request->{trailer_cb}=$args->{trailer_callback}if ref$args->{trailer_callback}eq 'CODE'}if ($self->{cookie_jar}){my$cookies=$self->cookie_jar->cookie_header($url);$request->{headers}{cookie}=$cookies if length$cookies}if (length$auth &&!defined$request->{headers}{authorization}){$self->_add_basic_auth_header($request,'authorization'=>$auth)}return}sub _add_basic_auth_header {my ($self,$request,$header,$auth)=@_;require MIME::Base64;$request->{headers}{$header}="Basic " .MIME::Base64::encode_base64($auth,"");return}sub _prepare_data_cb {my ($self,$response,$args)=@_;my$data_cb=$args->{data_callback};$response->{content}='';if (!$data_cb || $response->{status}!~ /^2/){if (defined$self->{max_size}){$data_cb=sub {$_[1]->{content}.= $_[0];die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)if length $_[1]->{content}> $self->{max_size}}}else {$data_cb=sub {$_[1]->{content}.= $_[0]}}}return$data_cb}sub _update_cookie_jar {my ($self,$url,$response)=@_;my$cookies=$response->{headers}->{'set-cookie'};return unless defined$cookies;my@cookies=ref$cookies ? @$cookies : $cookies;$self->cookie_jar->add($url,$_)for@cookies;return}sub _validate_cookie_jar {my ($class,$jar)=@_;for my$method (qw/add cookie_header/){Carp::croak(qq/Cookie jar must provide the '$method' method\n/)unless ref($jar)&& ref($jar)->can($method)}return}sub _maybe_redirect {my ($self,$request,$response,$args)=@_;my$headers=$response->{headers};my ($status,$method)=($response->{status},$request->{method});if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))and $headers->{location}and ++$args->{redirects}<= $self->{max_redirect}){my$location=($headers->{location}=~ /^\//)? "$request->{scheme}://$request->{host_port}$headers->{location}" : $headers->{location};return (($status eq '303' ? 'GET' : $method),$location)}return}sub _split_url {my$url=pop;my ($scheme,$host,$path_query)=$url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)> or die(qq/Cannot parse URL: '$url'\n/);$scheme=lc$scheme;$path_query="/$path_query" unless$path_query =~ m<\A/>;my$auth='';if ((my$i=index$host,'@')!=-1){$auth=substr$host,0,$i,'';substr$host,0,1,'';$auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}my$port=$host =~ s/:(\d*)\z// && length $1 ? $1 : $scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef;return ($scheme,(length$host ? lc$host : "localhost"),$port,$path_query,$auth)}my$DoW="Sun|Mon|Tue|Wed|Thu|Fri|Sat";my$MoY="Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";sub _http_date {my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($_[1]);return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",substr($DoW,$wday*4,3),$mday,substr($MoY,$mon*4,3),$year+1900,$hour,$min,$sec)}sub _parse_http_date {my ($self,$str)=@_;require Time::Local;my@tl_parts;if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/){@tl_parts=($6,$5,$4,$1,(index($MoY,$2)/4),$3)}elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/){@tl_parts=($5,$4,$3,$2,(index($MoY,$1)/4),$6)}return eval {my$t=@tl_parts ? Time::Local::timegm(@tl_parts): -1;$t < 0 ? undef : $t}}my%escapes=map {chr($_)=>sprintf("%%%02X",$_)}0..255;$escapes{' '}="+";my$unsafe_char=qr/[^A-Za-z0-9\-\._~]/;sub _uri_escape {my ($self,$str)=@_;if ($] ge '5.008'){utf8::encode($str)}else {$str=pack("U*",unpack("C*",$str))if (length$str==do {use bytes;length$str});$str=pack("C*",unpack("C*",$str))}$str =~ s/($unsafe_char)/$escapes{$1}/ge;return$str}package HTTP::Tiny::Handle;use strict;use warnings;use Errno qw[EINTR EPIPE];use IO::Socket qw[SOCK_STREAM];my$SOCKET_CLASS=$ENV{PERL_HTTP_TINY_IPV4_ONLY}? 'IO::Socket::INET' : eval {require IO::Socket::IP;IO::Socket::IP->VERSION(0.25)}? 'IO::Socket::IP' : 'IO::Socket::INET';sub BUFSIZE () {32768}my$Printable=sub {local $_=shift;s/\r/\\r/g;s/\n/\\n/g;s/\t/\\t/g;s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;$_};my$Token=qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;sub new {my ($class,%args)=@_;return bless {rbuf=>'',timeout=>60,max_line_size=>16384,max_header_lines=>64,verify_SSL=>0,SSL_options=>{},%args },$class}sub connect {@_==4 || die(q/Usage: $handle->connect(scheme, host, port)/ ."\n");my ($self,$scheme,$host,$port)=@_;if ($scheme eq 'https'){$self->_assert_ssl}elsif ($scheme ne 'http'){die(qq/Unsupported URL scheme '$scheme'\n/)}$self->{fh}=$SOCKET_CLASS->new(PeerHost=>$host,PeerPort=>$port,$self->{local_address}? (LocalAddr=>$self->{local_address}): (),Proto=>'tcp',Type=>SOCK_STREAM,Timeout=>$self->{timeout},KeepAlive=>!!$self->{keep_alive})or die(qq/Could not connect to '$host:$port': $@\n/);binmode($self->{fh})or die(qq/Could not binmode() socket: '$!'\n/);$self->start_ssl($host)if$scheme eq 'https';$self->{scheme}=$scheme;$self->{host}=$host;$self->{port}=$port;$self->{pid}=$$;$self->{tid}=_get_tid();return$self}sub start_ssl {my ($self,$host)=@_;if (ref($self->{fh})eq 'IO::Socket::SSL'){unless ($self->{fh}->stop_SSL){my$ssl_err=IO::Socket::SSL->errstr;die(qq/Error halting prior SSL connection: $ssl_err/)}}my$ssl_args=$self->_ssl_args($host);IO::Socket::SSL->start_SSL($self->{fh},%$ssl_args,SSL_create_ctx_callback=>sub {my$ctx=shift;Net::SSLeay::CTX_set_mode($ctx,Net::SSLeay::MODE_AUTO_RETRY())},);unless (ref($self->{fh})eq 'IO::Socket::SSL'){my$ssl_err=IO::Socket::SSL->errstr;die(qq/SSL connection failed for $host: $ssl_err\n/)}}sub close {@_==1 || die(q/Usage: $handle->close()/ ."\n");my ($self)=@_;CORE::close($self->{fh})or die(qq/Could not close socket: '$!'\n/)}sub write {@_==2 || die(q/Usage: $handle->write(buf)/ ."\n");my ($self,$buf)=@_;if ($] ge '5.008'){utf8::downgrade($buf,1)or die(qq/Wide character in write()\n/)}my$len=length$buf;my$off=0;local$SIG{PIPE}='IGNORE';while (){$self->can_write or die(qq/Timed out while waiting for socket to become ready for writing\n/);my$r=syswrite($self->{fh},$buf,$len,$off);if (defined$r){$len -= $r;$off += $r;last unless$len > 0}elsif ($!==EPIPE){die(qq/Socket closed by remote server: $!\n/)}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not write to SSL socket: '$err'\n /)}else {die(qq/Could not write to socket: '$!'\n/)}}}return$off}sub read {@_==2 || @_==3 || die(q/Usage: $handle->read(len [, allow_partial])/ ."\n");my ($self,$len,$allow_partial)=@_;my$buf='';my$got=length$self->{rbuf};if ($got){my$take=($got < $len)? $got : $len;$buf=substr($self->{rbuf},0,$take,'');$len -= $take}while ($len > 0){$self->can_read or die(q/Timed out while waiting for socket to become ready for reading/ ."\n");my$r=sysread($self->{fh},$buf,$len,length$buf);if (defined$r){last unless$r;$len -= $r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}if ($len &&!$allow_partial){die(qq/Unexpected end of stream\n/)}return$buf}sub readline {@_==1 || die(q/Usage: $handle->readline()/ ."\n");my ($self)=@_;while (){if ($self->{rbuf}=~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x){return $1}if (length$self->{rbuf}>= $self->{max_line_size}){die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/)}$self->can_read or die(qq/Timed out while waiting for socket to become ready for reading\n/);my$r=sysread($self->{fh},$self->{rbuf},BUFSIZE,length$self->{rbuf});if (defined$r){last unless$r}elsif ($!!=EINTR){if ($self->{fh}->can('errstr')){my$err=$self->{fh}->errstr();die (qq/Could not read from SSL socket: '$err'\n /)}else {die(qq/Could not read from socket: '$!'\n/)}}}die(qq/Unexpected end of stream while looking for line\n/)}sub read_header_lines {@_==1 || @_==2 || die(q/Usage: $handle->read_header_lines([headers])/ ."\n");my ($self,$headers)=@_;$headers ||= {};my$lines=0;my$val;while (){my$line=$self->readline;if (++$lines >= $self->{max_header_lines}){die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/)}elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x){my ($field_name)=lc $1;if (exists$headers->{$field_name}){for ($headers->{$field_name}){$_=[$_]unless ref $_ eq "ARRAY";push @$_,$2;$val=\$_->[-1]}}else {$val=\($headers->{$field_name}=$2)}}elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x){$val or die(qq/Unexpected header continuation line\n/);next unless length $1;$$val .= ' ' if length $$val;$$val .= $1}elsif ($line =~ /\A \x0D?\x0A \z/x){last}else {die(q/Malformed header line: / .$Printable->($line)."\n")}}return$headers}sub write_request {@_==2 || die(q/Usage: $handle->write_request(request)/ ."\n");my($self,$request)=@_;$self->write_request_header(@{$request}{qw/method uri headers/});$self->write_body($request)if$request->{cb};return}my%HeaderCase=('content-md5'=>'Content-MD5','etag'=>'ETag','te'=>'TE','www-authenticate'=>'WWW-Authenticate','x-xss-protection'=>'X-XSS-Protection',);sub write_header_lines {(@_==2 || @_==3 && ref $_[1]eq 'HASH')|| die(q/Usage: $handle->write_header_lines(headers[,prefix])/ ."\n");my($self,$headers,$prefix_data)=@_;my$buf=(defined$prefix_data ? $prefix_data : '');while (my ($k,$v)=each %$headers){my$field_name=lc$k;if (exists$HeaderCase{$field_name}){$field_name=$HeaderCase{$field_name}}else {$field_name =~ /\A $Token+ \z/xo or die(q/Invalid HTTP header field name: / .$Printable->($field_name)."\n");$field_name =~ s/\b(\w)/\u$1/g;$HeaderCase{lc$field_name}=$field_name}for (ref$v eq 'ARRAY' ? @$v : $v){$_='' unless defined $_;$buf .= "$field_name: $_\x0D\x0A"}}$buf .= "\x0D\x0A";return$self->write($buf)}sub read_body {@_==3 || die(q/Usage: $handle->read_body(callback, response)/ ."\n");my ($self,$cb,$response)=@_;my$te=$response->{headers}{'transfer-encoding'}|| '';my$chunked=grep {/chunked/i}(ref$te eq 'ARRAY' ? @$te : $te);return$chunked ? $self->read_chunked_body($cb,$response): $self->read_content_body($cb,$response)}sub write_body {@_==2 || die(q/Usage: $handle->write_body(request)/ ."\n");my ($self,$request)=@_;if ($request->{headers}{'content-length'}){return$self->write_content_body($request)}else {return$self->write_chunked_body($request)}}sub read_content_body {@_==3 || @_==4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ ."\n");my ($self,$cb,$response,$content_length)=@_;$content_length ||= $response->{headers}{'content-length'};if (defined$content_length){my$len=$content_length;while ($len > 0){my$read=($len > BUFSIZE)? BUFSIZE : $len;$cb->($self->read($read,0),$response);$len -= $read}return length($self->{rbuf})==0}my$chunk;$cb->($chunk,$response)while length($chunk=$self->read(BUFSIZE,1));return}sub write_content_body {@_==2 || die(q/Usage: $handle->write_content_body(request)/ ."\n");my ($self,$request)=@_;my ($len,$content_length)=(0,$request->{headers}{'content-length'});while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_content()\n/)}$len += $self->write($data)}$len==$content_length or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);return$len}sub read_chunked_body {@_==3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ ."\n");my ($self,$cb,$response)=@_;while (){my$head=$self->readline;$head =~ /\A ([A-Fa-f0-9]+)/x or die(q/Malformed chunk head: / .$Printable->($head)."\n");my$len=hex($1)or last;$self->read_content_body($cb,$response,$len);$self->read(2)eq "\x0D\x0A" or die(qq/Malformed chunk: missing CRLF after chunk data\n/)}$self->read_header_lines($response->{headers});return 1}sub write_chunked_body {@_==2 || die(q/Usage: $handle->write_chunked_body(request)/ ."\n");my ($self,$request)=@_;my$len=0;while (){my$data=$request->{cb}->();defined$data && length$data or last;if ($] ge '5.008'){utf8::downgrade($data,1)or die(qq/Wide character in write_chunked_body()\n/)}$len += length$data;my$chunk=sprintf '%X',length$data;$chunk .= "\x0D\x0A";$chunk .= $data;$chunk .= "\x0D\x0A";$self->write($chunk)}$self->write("0\x0D\x0A");$self->write_header_lines($request->{trailer_cb}->())if ref$request->{trailer_cb}eq 'CODE';return$len}sub read_response_header {@_==1 || die(q/Usage: $handle->read_response_header()/ ."\n");my ($self)=@_;my$line=$self->readline;$line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x or die(q/Malformed Status-Line: / .$Printable->($line)."\n");my ($protocol,$version,$status,$reason)=($1,$2,$3,$4);die (qq/Unsupported HTTP protocol: $protocol\n/)unless$version =~ /0*1\.0*[01]/;return {status=>$status,reason=>$reason,headers=>$self->read_header_lines,protocol=>$protocol,}}sub write_request_header {@_==4 || die(q/Usage: $handle->write_request_header(method, request_uri, headers)/ ."\n");my ($self,$method,$request_uri,$headers)=@_;return$self->write_header_lines($headers,"$method $request_uri HTTP/1.1\x0D\x0A")}sub _do_timeout {my ($self,$type,$timeout)=@_;$timeout=$self->{timeout}unless defined$timeout && $timeout >= 0;my$fd=fileno$self->{fh};defined$fd && $fd >= 0 or die(qq/select(2): 'Bad file descriptor'\n/);my$initial=time;my$pending=$timeout;my$nfound;vec(my$fdset='',$fd,1)=1;while (){$nfound=($type eq 'read')? select($fdset,undef,undef,$pending): select(undef,$fdset,undef,$pending);if ($nfound==-1){$!==EINTR or die(qq/select(2): '$!'\n/);redo if!$timeout || ($pending=$timeout - (time - $initial))> 0;$nfound=0}last}$!=0;return$nfound}sub can_read {@_==1 || @_==2 || die(q/Usage: $handle->can_read([timeout])/ ."\n");my$self=shift;if (ref($self->{fh})eq 'IO::Socket::SSL'){return 1 if$self->{fh}->pending}return$self->_do_timeout('read',@_)}sub can_write {@_==1 || @_==2 || die(q/Usage: $handle->can_write([timeout])/ ."\n");my$self=shift;return$self->_do_timeout('write',@_)}sub _assert_ssl {my($ok,$reason)=HTTP::Tiny->can_ssl();die$reason unless$ok}sub can_reuse {my ($self,$scheme,$host,$port)=@_;return 0 if $self->{pid}!=$$ || $self->{tid}!=_get_tid()|| length($self->{rbuf})|| $scheme ne $self->{scheme}|| $host ne $self->{host}|| $port ne $self->{port}|| eval {$self->can_read(0)}|| $@ ;return 1}sub _find_CA_file {my$self=shift();if ($self->{SSL_options}->{SSL_ca_file}){unless (-r $self->{SSL_options}->{SSL_ca_file}){die qq/SSL_ca_file '$self->{SSL_options}->{SSL_ca_file}' not found or not readable\n/}return$self->{SSL_options}->{SSL_ca_file}}return Mozilla::CA::SSL_ca_file()if eval {require Mozilla::CA;1};for my$ca_bundle ("/etc/ssl/certs/ca-certificates.crt","/etc/pki/tls/certs/ca-bundle.crt","/etc/ssl/ca-bundle.pem","/etc/openssl/certs/ca-certificates.crt","/etc/ssl/cert.pem","/usr/local/share/certs/ca-root-nss.crt","/etc/pki/tls/cacert.pem","/etc/certs/ca-certificates.crt",){return$ca_bundle if -e $ca_bundle}die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/ .qq/Try installing Mozilla::CA from CPAN\n/}sub _get_tid {no warnings 'reserved';return threads->can("tid")? threads->tid : 0}sub _ssl_args {my ($self,$host)=@_;my%ssl_args;if (Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x01000000){$ssl_args{SSL_hostname}=$host,}if ($self->{verify_SSL}){$ssl_args{SSL_verifycn_scheme}='http';$ssl_args{SSL_verifycn_name}=$host;$ssl_args{SSL_verify_mode}=0x01;$ssl_args{SSL_ca_file}=$self->_find_CA_file}else {$ssl_args{SSL_verifycn_scheme}='none';$ssl_args{SSL_verify_mode}=0x00}for my$k (keys %{$self->{SSL_options}}){$ssl_args{$k}=$self->{SSL_options}{$k}if$k =~ m/^SSL_/}return \%ssl_args}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
HTTP_TINY

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.039';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"TAP/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_BASE';
  package TAP::Base;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.35';use constant GOT_TIME_HIRES=>do {eval 'use Time::HiRes qw(time);';$@ ? 0 : 1};sub _initialize {my ($self,$arg_for,$ok_callback)=@_;my%ok_map=map {$_=>1}@$ok_callback;$self->{ok_callbacks}=\%ok_map;if (my$cb=delete$arg_for->{callbacks}){while (my ($event,$callback)=each %$cb){$self->callback($event,$callback)}}return$self}sub callback {my ($self,$event,$callback)=@_;my%ok_map=%{$self->{ok_callbacks}};$self->_croak('No callbacks may be installed')unless%ok_map;$self->_croak("Callback $event is not supported. Valid callbacks are " .join(', ',sort keys%ok_map))unless exists$ok_map{$event};push @{$self->{code_for}{$event}},$callback;return}sub _has_callbacks {my$self=shift;return keys %{$self->{code_for}}!=0}sub _callback_for {my ($self,$event)=@_;return$self->{code_for}{$event}}sub _make_callback {my$self=shift;my$event=shift;my$cb=$self->_callback_for($event);return unless defined$cb;return map {$_->(@_)}@$cb}sub get_time {return time()}sub time_is_hires {return GOT_TIME_HIRES}sub get_times {return [times()]}1;
TAP_BASE

$fatpacked{"TAP/Formatter/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_BASE';
  package TAP::Formatter::Base;use strict;use warnings;use base 'TAP::Base';use POSIX qw(strftime);my$MAX_ERRORS=5;my%VALIDATION_FOR;BEGIN {%VALIDATION_FOR=(directives=>sub {shift;shift},verbosity=>sub {shift;shift},normalize=>sub {shift;shift},timer=>sub {shift;shift},failures=>sub {shift;shift},comments=>sub {shift;shift},errors=>sub {shift;shift},color=>sub {shift;shift},jobs=>sub {shift;shift},show_count=>sub {shift;shift},stdout=>sub {my ($self,$ref)=@_;$self->_croak("option 'stdout' needs a filehandle")unless$self->_is_filehandle($ref);return$ref},);sub _is_filehandle {my ($self,$ref)=@_;return 0 if!defined$ref;return 1 if ref$ref eq 'GLOB';return 1 if!ref$ref && ref \$ref eq 'GLOB';return 1 if eval {$ref->can('print')};return 0}my@getter_setters=qw(_longest _printed_summary_header _colorizer);__PACKAGE__->mk_methods(@getter_setters,keys%VALIDATION_FOR)}our$VERSION='3.35';sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for);my%arg_for=%$arg_for;$self->verbosity(0);for my$name (keys%VALIDATION_FOR){my$property=delete$arg_for{$name};if (defined$property){my$validate=$VALIDATION_FOR{$name};$self->$name($self->$validate($property))}}if (my@props=keys%arg_for){$self->_croak("Unknown arguments to " .__PACKAGE__ ."::new (@props)")}$self->stdout(\*STDOUT)unless$self->stdout;if ($self->color){require TAP::Formatter::Color;$self->_colorizer(TAP::Formatter::Color->new)}return$self}sub verbose {shift->verbosity >= 1}sub quiet {shift->verbosity <= -1}sub really_quiet {shift->verbosity <= -2}sub silent {shift->verbosity <= -3}sub prepare {my ($self,@tests)=@_;my$longest=0;for my$test (@tests){$longest=length$test if length$test > $longest}$self->_longest($longest)}sub _format_now {strftime "[%H:%M:%S]",localtime}sub _format_name {my ($self,$test)=@_;my$name=$test;my$periods='.' x ($self->_longest + 2 - length$test);$periods=" $periods ";if ($self->timer){my$stamp=$self->_format_now();return "$stamp $name$periods"}else {return "$name$periods"}}sub open_test {die "Unimplemented."}sub _output_success {my ($self,$msg)=@_;$self->_output($msg)}sub summary {my ($self,$aggregate,$interrupted)=@_;return if$self->silent;my@t=$aggregate->descriptions;my$tests=\@t;my$runtime=$aggregate->elapsed_timestr;my$total=$aggregate->total;my$passed=$aggregate->passed;if ($self->timer){$self->_output($self->_format_now(),"\n")}$self->_failure_output("Test run interrupted!\n")if$interrupted;if ($aggregate->all_passed){$self->_output_success("All tests successful.\n")}if ($total!=$passed or $aggregate->has_problems){$self->_output("\nTest Summary Report");$self->_output("\n-------------------\n");for my$test (@$tests){$self->_printed_summary_header(0);my ($parser)=$aggregate->parsers($test);$self->_output_summary_failure('failed',['  Failed test:  ','  Failed tests:  ' ],$test,$parser);$self->_output_summary_failure('todo_passed',"  TODO passed:   ",$test,$parser);if (my$exit=$parser->exit){$self->_summary_test_header($test,$parser);$self->_failure_output("  Non-zero exit status: $exit\n")}elsif (my$wait=$parser->wait){$self->_summary_test_header($test,$parser);$self->_failure_output("  Non-zero wait status: $wait\n")}if (my@errors=$parser->parse_errors){my$explain;if (@errors > $MAX_ERRORS &&!$self->errors){$explain ="Displayed the first $MAX_ERRORS of " .scalar(@errors)." TAP syntax errors.\n" ."Re-run prove with the -p option to see them all.\n";splice@errors,$MAX_ERRORS}$self->_summary_test_header($test,$parser);$self->_failure_output(sprintf "  Parse errors: %s\n",shift@errors);for my$error (@errors){my$spaces=' ' x 16;$self->_failure_output("$spaces$error\n")}$self->_failure_output($explain)if$explain}}}my$files=@$tests;$self->_output("Files=$files, Tests=$total, $runtime\n");my$status=$aggregate->get_status;$self->_output("Result: $status\n")}sub _output_summary_failure {my ($self,$method,$name,$test,$parser)=@_;my$output=$method eq 'failed' ? '_failure_output' : '_output';if (my@r=$parser->$method()){$self->_summary_test_header($test,$parser);my ($singular,$plural)='ARRAY' eq ref$name ? @$name : ($name,$name);$self->$output(@r==1 ? $singular : $plural);my@results=$self->_balanced_range(40,@r);$self->$output(sprintf "%s\n"=>shift@results);my$spaces=' ' x 16;while (@results){$self->$output(sprintf "$spaces%s\n"=>shift@results)}}}sub _summary_test_header {my ($self,$test,$parser)=@_;return if$self->_printed_summary_header;my$spaces=' ' x ($self->_longest - length$test);$spaces=' ' unless$spaces;my$output=$self->_get_output_method($parser);my$wait=$parser->wait;defined$wait or $wait='(none)';$self->$output(sprintf "$test$spaces(Wstat: %s Tests: %d Failed: %d)\n",$wait,$parser->tests_run,scalar$parser->failed);$self->_printed_summary_header(1)}sub _output {my$self=shift;print {$self->stdout}@_}sub _failure_output {my$self=shift;$self->_output(@_)}sub _balanced_range {my ($self,$limit,@range)=@_;@range=$self->_range(@range);my$line="";my@lines;my$curr=0;while (@range){if ($curr < $limit){my$range=(shift@range).", ";$line .= $range;$curr += length$range}elsif (@range){$line =~ s/, $//;push@lines=>$line;$line='';$curr=0}}if ($line){$line =~ s/, $//;push@lines=>$line}return@lines}sub _range {my ($self,@numbers)=@_;@numbers=sort {$a <=> $b}@numbers;my ($min,@range);for my$i (0 .. $#numbers){my$num=$numbers[$i];my$next=$numbers[$i + 1 ];if (defined$next && $next==$num + 1){if (!defined$min){$min=$num}}elsif (defined$min){push@range=>"$min-$num";undef$min}else {push@range=>$num}}return@range}sub _get_output_method {my ($self,$parser)=@_;return$parser->has_problems ? '_failure_output' : '_output'}1;
TAP_FORMATTER_BASE

$fatpacked{"TAP/Formatter/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_COLOR';
  package TAP::Formatter::Color;use strict;use warnings;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use base 'TAP::Object';my$NO_COLOR;BEGIN {$NO_COLOR=0;if (IS_WIN32){eval 'use Win32::Console';if ($@){$NO_COLOR=$@}else {my$console=Win32::Console->new(STD_OUTPUT_HANDLE());my$fg=eval '$FG_LIGHTGRAY';my$bg=eval '$BG_BLACK';*set_color=sub {my ($self,$output,$color)=@_;my$var;if ($color eq 'reset'){$fg=eval '$FG_LIGHTGRAY';$bg=eval '$BG_BLACK'}elsif ($color =~ /^on_(.+)$/){$bg=eval '$BG_' .uc($1)}else {$fg=eval '$FG_' .uc($color)}$self->set_color('reset')unless defined$bg && defined$fg;$console->Attr($bg | $fg)}}}else {eval 'use Term::ANSIColor';if ($@){$NO_COLOR=$@}else {*set_color=sub {my ($self,$output,$color)=@_;$output->(color($color))}}}if ($NO_COLOR){*set_color=sub {}}}our$VERSION='3.35';sub _initialize {my$self=shift;if ($NO_COLOR){(my$error=$NO_COLOR)=~ s/ in \@INC .*//s;warn "Note: Cannot run tests in color: $error\n";return}return$self}sub can_color {return!$NO_COLOR}1;
TAP_FORMATTER_COLOR

$fatpacked{"TAP/Formatter/Console.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE';
  package TAP::Formatter::Console;use strict;use warnings;use base 'TAP::Formatter::Base';use POSIX qw(strftime);our$VERSION='3.35';sub open_test {my ($self,$test,$parser)=@_;my$class =$self->jobs > 1 ? 'TAP::Formatter::Console::ParallelSession' : 'TAP::Formatter::Console::Session';eval "require $class";$self->_croak($@)if $@;my$session=$class->new({name=>$test,formatter=>$self,parser=>$parser,show_count=>$self->show_count,});$session->header;return$session}sub _set_colors {my ($self,@colors)=@_;if (my$colorizer=$self->_colorizer){my$output_func=$self->{_output_func}||= sub {$self->_output(@_)};$colorizer->set_color($output_func,$_)for@colors}}sub _failure_color {my ($self)=@_;return$ENV{'HARNESS_SUMMARY_COLOR_FAIL'}|| 'red'}sub _success_color {my ($self)=@_;return$ENV{'HARNESS_SUMMARY_COLOR_SUCCESS'}|| 'green'}sub _output_success {my ($self,$msg)=@_;$self->_set_colors($self->_success_color());$self->_output($msg);$self->_set_colors('reset')}sub _failure_output {my$self=shift;$self->_set_colors($self->_failure_color());my$out=join '',@_;my$has_newline=chomp$out;$self->_output($out);$self->_set_colors('reset');$self->_output($/)if$has_newline}1;
TAP_FORMATTER_CONSOLE

$fatpacked{"TAP/Formatter/Console/ParallelSession.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_PARALLELSESSION';
  package TAP::Formatter::Console::ParallelSession;use strict;use warnings;use File::Spec;use File::Path;use Carp;use base 'TAP::Formatter::Console::Session';use constant WIDTH=>72;my%shared;sub _initialize {my ($self,$arg_for)=@_;$self->SUPER::_initialize($arg_for);my$formatter=$self->formatter;my$context=$shared{$formatter}||= $self->_create_shared_context;push @{$context->{active}},$self;return$self}sub _create_shared_context {my$self=shift;return {active=>[],tests=>0,fails=>0,}}our$VERSION='3.35';sub header {}sub _clear_ruler {my$self=shift;$self->formatter->_output("\r" .(' ' x WIDTH)."\r")}my$now=0;my$start;my$trailer='... )===';my$chop_length=WIDTH - length$trailer;sub _output_ruler {my ($self,$refresh)=@_;my$new_now=time;return if$new_now==$now and!$refresh;$now=$new_now;$start ||= $now;my$formatter=$self->formatter;return if$formatter->really_quiet;my$context=$shared{$formatter};my$ruler=sprintf '===( %7d;%d  ',$context->{tests},$now - $start;for my$active (@{$context->{active}}){my$parser=$active->parser;my$tests=$parser->tests_run;my$planned=$parser->tests_planned || '?';$ruler .= sprintf '%' .length($planned)."d/$planned  ",$tests}chop$ruler;$ruler .= ')===';if (length$ruler > WIDTH){$ruler =~ s/(.{$chop_length}).*/$1$trailer/o}else {$ruler .= '=' x (WIDTH - length($ruler))}$formatter->_output("\r$ruler")}sub result {my ($self,$result)=@_;my$formatter=$self->formatter;if ($result->is_test){my$context=$shared{$formatter};$context->{tests}++;my$active=$context->{active};if (@$active==1){return$self->SUPER::result($result)}$self->_output_ruler($self->parser->tests_run==1)}elsif ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n")}}sub clear_for_close {my$self=shift;my$formatter=$self->formatter;return if$formatter->really_quiet;my$context=$shared{$formatter};if (@{$context->{active}}==1){$self->SUPER::clear_for_close}else {$self->_clear_ruler}}sub close_test {my$self=shift;my$name=$self->name;my$parser=$self->parser;my$formatter=$self->formatter;my$context=$shared{$formatter};$self->SUPER::close_test;my$active=$context->{active};my@pos=grep {$active->[$_]->name eq $name}0 .. $#$active;die "Can't find myself" unless@pos;splice @$active,$pos[0],1;if (@$active > 1){$self->_output_ruler(1)}elsif (@$active==1){$active->[0]->SUPER::header}else {delete$shared{$formatter}}}1;
TAP_FORMATTER_CONSOLE_PARALLELSESSION

$fatpacked{"TAP/Formatter/Console/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_CONSOLE_SESSION';
  package TAP::Formatter::Console::Session;use strict;use warnings;use base 'TAP::Formatter::Session';my@ACCESSOR;BEGIN {my@CLOSURE_BINDING=qw(header result clear_for_close close_test);for my$method (@CLOSURE_BINDING){no strict 'refs';*$method=sub {my$self=shift;return ($self->{_closures}||= $self->_closures)->{$method}->(@_)}}}our$VERSION='3.35';sub _get_output_result {my$self=shift;my@color_map=({test=>sub {$_->is_test &&!$_->is_ok},colors=>['red'],},{test=>sub {$_->is_test && $_->has_skip},colors=>['white','on_blue' ],},{test=>sub {$_->is_test && $_->has_todo},colors=>['yellow'],},);my$formatter=$self->formatter;my$parser=$self->parser;return$formatter->_colorizer ? sub {my$result=shift;for my$col (@color_map){local $_=$result;if ($col->{test}->()){$formatter->_set_colors(@{$col->{colors}});last}}$formatter->_output($self->_format_for_output($result));$formatter->_set_colors('reset')}: sub {$formatter->_output($self->_format_for_output(shift))}}sub _closures {my$self=shift;my$parser=$self->parser;my$formatter=$self->formatter;my$pretty=$formatter->_format_name($self->name);my$show_count=$self->show_count;my$really_quiet=$formatter->really_quiet;my$quiet=$formatter->quiet;my$verbose=$formatter->verbose;my$directives=$formatter->directives;my$failures=$formatter->failures;my$comments=$formatter->comments;my$output_result=$self->_get_output_result;my$output='_output';my$plan='';my$newline_printed=0;my$last_status_printed=0;return {header=>sub {$formatter->_output($pretty)unless$really_quiet},result=>sub {my$result=shift;if ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n")}return if$really_quiet;my$is_test=$result->is_test;if (!$plan){my$planned=$parser->tests_planned || '?';$plan="/$planned "}$output=$formatter->_get_output_method($parser);if ($show_count and $is_test){my$number=$result->number;my$now=CORE::time;if ($last_status_printed!=$now){$formatter->$output("\r$pretty$number$plan");$last_status_printed=$now}}if (!$quiet && ($verbose || ($is_test && $failures &&!$result->is_ok)|| ($comments && $result->is_comment)|| ($directives && $result->has_directive))){unless ($newline_printed){$formatter->_output("\n");$newline_printed=1}$output_result->($result);$formatter->_output("\n")}},clear_for_close=>sub {my$spaces =' ' x length('.' .$pretty .$plan .$parser->tests_run);$formatter->$output("\r$spaces")},close_test=>sub {if ($show_count &&!$really_quiet){$self->clear_for_close;$formatter->$output("\r$pretty")}$self->parser(undef);$self->{_closures}={};return if$really_quiet;if (my$skip_all=$parser->skip_all){$formatter->_output("skipped: $skip_all\n")}elsif ($parser->has_problems){$self->_output_test_failure($parser)}else {my$time_report=$self->time_report($formatter,$parser);$formatter->_output($self->_make_ok_line($time_report))}},}}1;
TAP_FORMATTER_CONSOLE_SESSION

$fatpacked{"TAP/Formatter/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE';
  package TAP::Formatter::File;use strict;use warnings;use TAP::Formatter::File::Session;use POSIX qw(strftime);use base 'TAP::Formatter::Base';our$VERSION='3.35';sub open_test {my ($self,$test,$parser)=@_;my$session=TAP::Formatter::File::Session->new({name=>$test,formatter=>$self,parser=>$parser,});$session->header;return$session}sub _should_show_count {return 0}1;
TAP_FORMATTER_FILE

$fatpacked{"TAP/Formatter/File/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_FILE_SESSION';
  package TAP::Formatter::File::Session;use strict;use warnings;use base 'TAP::Formatter::Session';our$VERSION='3.35';sub result {my$self=shift;my$result=shift;my$parser=$self->parser;my$formatter=$self->formatter;if ($result->is_bailout){$formatter->_failure_output("Bailout called.  Further testing stopped:  " .$result->explanation ."\n");return}if (!$formatter->quiet && ($formatter->verbose || ($result->is_test && $formatter->failures &&!$result->is_ok)|| ($formatter->comments && $result->is_comment)|| ($result->has_directive && $formatter->directives))){$self->{results}.= $self->_format_for_output($result)."\n"}}sub close_test {my$self=shift;$self->parser(undef);my$parser=$self->parser;my$formatter=$self->formatter;my$pretty=$formatter->_format_name($self->name);return if$formatter->really_quiet;if (my$skip_all=$parser->skip_all){$formatter->_output($pretty ."skipped: $skip_all\n")}elsif ($parser->has_problems){$formatter->_output($pretty .($self->{results}? "\n" .$self->{results}: "\n"));$self->_output_test_failure($parser)}else {my$time_report=$self->time_report($formatter,$parser);$formatter->_output($pretty .($self->{results}? "\n" .$self->{results}: "").$self->_make_ok_line($time_report))}}1;
TAP_FORMATTER_FILE_SESSION

$fatpacked{"TAP/Formatter/Session.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_FORMATTER_SESSION';
  package TAP::Formatter::Session;use strict;use warnings;use base 'TAP::Base';my@ACCESSOR;BEGIN {@ACCESSOR=qw(name formatter parser show_count);for my$method (@ACCESSOR){no strict 'refs';*$method=sub {shift->{$method}}}}our$VERSION='3.35';sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for);my%arg_for=%$arg_for;for my$name (@ACCESSOR){$self->{$name}=delete$arg_for{$name}}if (!defined$self->show_count){$self->{show_count}=1}if ($self->show_count){$self->{show_count}=$self->_should_show_count}if (my@props=sort keys%arg_for){$self->_croak("Unknown arguments to " .__PACKAGE__ ."::new (@props)")}return$self}sub header {}sub result {}sub close_test {}sub clear_for_close {}sub _should_show_count {my$self=shift;return !$self->formatter->verbose && -t $self->formatter->stdout &&!$ENV{HARNESS_NOTTY}}sub _format_for_output {my ($self,$result)=@_;return$self->formatter->normalize ? $result->as_string : $result->raw}sub _output_test_failure {my ($self,$parser)=@_;my$formatter=$self->formatter;return if$formatter->really_quiet;my$tests_run=$parser->tests_run;my$tests_planned=$parser->tests_planned;my$total =defined$tests_planned ? $tests_planned : $tests_run;my$passed=$parser->passed;my$failed=$parser->failed + $total - $tests_run;my$exit=$parser->exit;if (my$exit=$parser->exit){my$wstat=$parser->wait;my$status=sprintf("%d (wstat %d, 0x%x)",$exit,$wstat,$wstat);$formatter->_failure_output("Dubious, test returned $status\n")}if ($failed==0){$formatter->_failure_output($total ? "All $total subtests passed " : 'No subtests run ')}else {$formatter->_failure_output("Failed $failed/$total subtests ");if (!$total){$formatter->_failure_output("\nNo tests run!")}}if (my$skipped=$parser->skipped){$passed -= $skipped;my$test='subtest' .($skipped!=1 ? 's' : '');$formatter->_output("\n\t(less $skipped skipped $test: $passed okay)")}if (my$failed=$parser->todo_passed){my$test=$failed > 1 ? 'tests' : 'test';$formatter->_output("\n\t($failed TODO $test unexpectedly succeeded)")}$formatter->_output("\n")}sub _make_ok_line {my ($self,$suffix)=@_;return "ok$suffix\n"}sub time_report {my ($self,$formatter,$parser)=@_;my@time_report;if ($formatter->timer){my$start_time=$parser->start_time;my$end_time=$parser->end_time;if (defined$start_time and defined$end_time){my$elapsed=$end_time - $start_time;push@time_report,$self->time_is_hires ? sprintf(' %8d ms',$elapsed * 1000): sprintf(' %8s s',$elapsed || '<1')}my$start_times=$parser->start_times();my$end_times=$parser->end_times();my$usr=$end_times->[0]- $start_times->[0];my$sys=$end_times->[1]- $start_times->[1];my$cusr=$end_times->[2]- $start_times->[2];my$csys=$end_times->[3]- $start_times->[3];push@time_report,sprintf('(%5.2f usr %5.2f sys + %5.2f cusr %5.2f csys = %5.2f CPU)',$usr,$sys,$cusr,$csys,$usr + $sys + $cusr + $csys)}return "@time_report"}1;
TAP_FORMATTER_SESSION

$fatpacked{"TAP/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS';
  package TAP::Harness;use strict;use warnings;use Carp;use File::Spec;use File::Path;use IO::Handle;use base 'TAP::Base';our$VERSION='3.35';$ENV{HARNESS_ACTIVE}=1;$ENV{HARNESS_VERSION}=$VERSION;END {delete$ENV{HARNESS_ACTIVE};delete$ENV{HARNESS_VERSION}}my%VALIDATION_FOR;my@FORMATTER_ARGS;sub _error {my$self=shift;return$self->{error}unless @_;$self->{error}=shift}BEGIN {@FORMATTER_ARGS=qw(directives verbosity timer failures comments errors stdout color show_count normalize);%VALIDATION_FOR=(lib=>sub {my ($self,$libs)=@_;$libs=[$libs]unless 'ARRAY' eq ref$libs;return [map {"-I$_"}@$libs ]},switches=>sub {shift;shift},exec=>sub {shift;shift},merge=>sub {shift;shift},aggregator_class=>sub {shift;shift},formatter_class=>sub {shift;shift},multiplexer_class=>sub {shift;shift},parser_class=>sub {shift;shift},scheduler_class=>sub {shift;shift},formatter=>sub {shift;shift},jobs=>sub {shift;shift},test_args=>sub {shift;shift},ignore_exit=>sub {shift;shift},rules=>sub {shift;shift},rulesfile=>sub {shift;shift},sources=>sub {shift;shift},version=>sub {shift;shift},trap=>sub {shift;shift},);for my$method (sort keys%VALIDATION_FOR){no strict 'refs';if ($method eq 'lib' || $method eq 'switches'){*{$method}=sub {my$self=shift;unless (@_){$self->{$method}||= [];return wantarray ? @{$self->{$method}}: $self->{$method}}$self->_croak("Too many arguments to method '$method'")if @_ > 1;my$args=shift;$args=[$args]unless ref$args;$self->{$method}=$args;return$self}}else {*{$method}=sub {my$self=shift;return$self->{$method}unless @_;$self->{$method}=shift}}}for my$method (@FORMATTER_ARGS){no strict 'refs';*{$method}=sub {my$self=shift;return$self->formatter->$method(@_)}}}{my@legal_callback=qw(parser_args made_parser before_runtests after_runtests after_test);my%default_class=(aggregator_class=>'TAP::Parser::Aggregator',formatter_class=>'TAP::Formatter::Console',multiplexer_class=>'TAP::Parser::Multiplexer',parser_class=>'TAP::Parser',scheduler_class=>'TAP::Parser::Scheduler',);sub _initialize {my ($self,$arg_for)=@_;$arg_for ||= {};$self->SUPER::_initialize($arg_for,\@legal_callback);my%arg_for=%$arg_for;for my$name (sort keys%VALIDATION_FOR){my$property=delete$arg_for{$name};if (defined$property){my$validate=$VALIDATION_FOR{$name};my$value=$self->$validate($property);if ($self->_error){$self->_croak}$self->$name($value)}}$self->jobs(1)unless defined$self->jobs;if (!defined$self->rules){$self->_maybe_load_rulesfile}local$default_class{formatter_class}='TAP::Formatter::File' unless -t ($arg_for{stdout}|| \*STDOUT)&&!$ENV{HARNESS_NOTTY};while (my ($attr,$class)=each%default_class){$self->$attr($self->$attr()|| $class)}unless ($self->formatter){my%formatter_args=(jobs=>$self->jobs);for my$name (@FORMATTER_ARGS){if (defined(my$property=delete$arg_for{$name})){$formatter_args{$name}=$property}}$self->formatter($self->_construct($self->formatter_class,\%formatter_args))}if (my@props=sort keys%arg_for){$self->_croak("Unknown arguments to TAP::Harness::new (@props)")}return$self}sub _maybe_load_rulesfile {my ($self)=@_;my ($rulesfile)=defined$self->rulesfile ? $self->rulesfile : defined($ENV{HARNESS_RULESFILE})? $ENV{HARNESS_RULESFILE}: grep {-r}qw(./testrules.yml t/testrules.yml);if (defined$rulesfile && -r $rulesfile){if (!eval {require CPAN::Meta::YAML;1}){warn "CPAN::Meta::YAML required to process $rulesfile" ;return}my$layer=$] lt "5.008" ? "" : ":encoding(UTF-8)";open my$fh,"<$layer",$rulesfile or die "Couldn't open $rulesfile: $!";my$yaml_text=do {local $/;<$fh>};my$yaml=CPAN::Meta::YAML->read_string($yaml_text)or die CPAN::Meta::YAML->errstr;$self->rules($yaml->[0])}return}}sub runtests {my ($self,@tests)=@_;my$aggregate=$self->_construct($self->aggregator_class);$self->_make_callback('before_runtests',$aggregate);$aggregate->start;my$finish=sub {my$interrupted=shift;$aggregate->stop;$self->summary($aggregate,$interrupted);$self->_make_callback('after_runtests',$aggregate)};my$run=sub {$self->aggregate_tests($aggregate,@tests);$finish->()};if ($self->trap){local$SIG{INT}=sub {print "\n";$finish->(1);exit};$run->()}else {$run->()}return$aggregate}sub summary {my ($self,@args)=@_;$self->formatter->summary(@args)}sub _after_test {my ($self,$aggregate,$job,$parser)=@_;$self->_make_callback('after_test',$job->as_array_ref,$parser);$aggregate->add($job->description,$parser)}sub _bailout {my ($self,$result)=@_;my$explanation=$result->explanation;die "FAILED--Further testing stopped" .($explanation ? ": $explanation\n" : ".\n")}sub _aggregate_parallel {my ($self,$aggregate,$scheduler)=@_;my$jobs=$self->jobs;my$mux=$self->_construct($self->multiplexer_class);RESULT: {FILL: while ($mux->parsers < $jobs){my$job=$scheduler->get_job;last FILL if!defined$job || $job->is_spinner;my ($parser,$session)=$self->make_parser($job);$mux->add($parser,[$session,$job ])}if (my ($parser,$stash,$result)=$mux->next){my ($session,$job)=@$stash;if (defined$result){$session->result($result);$self->_bailout($result)if$result->is_bailout}else {$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish}redo RESULT}}return}sub _aggregate_single {my ($self,$aggregate,$scheduler)=@_;JOB: while (my$job=$scheduler->get_job){next JOB if$job->is_spinner;my ($parser,$session)=$self->make_parser($job);while (defined(my$result=$parser->next)){$session->result($result);if ($result->is_bailout){1 while$parser->next;$self->_bailout($result)}}$self->finish_parser($parser,$session);$self->_after_test($aggregate,$job,$parser);$job->finish}return}sub aggregate_tests {my ($self,$aggregate,@tests)=@_;my$jobs=$self->jobs;my$scheduler=$self->make_scheduler(@tests);local$ENV{HARNESS_IS_VERBOSE}=1 if$self->formatter->verbosity > 0;$self->formatter->prepare(map {$_->description}$scheduler->get_all);if ($self->jobs > 1){$self->_aggregate_parallel($aggregate,$scheduler)}else {$self->_aggregate_single($aggregate,$scheduler)}return}sub _add_descriptions {my$self=shift;return map {@$_==1 ? [$_->[0],$_->[0]]: $_}map {'ARRAY' eq ref $_ ? $_ : [$_]}@_}sub make_scheduler {my ($self,@tests)=@_;return$self->_construct($self->scheduler_class,tests=>[$self->_add_descriptions(@tests)],rules=>$self->rules)}sub _get_parser_args {my ($self,$job)=@_;my$test_prog=$job->filename;my%args=();$args{sources}=$self->sources if$self->sources;my@switches;@switches=$self->lib if$self->lib;push@switches=>$self->switches if$self->switches;$args{switches}=\@switches;$args{spool}=$self->_open_spool($test_prog);$args{merge}=$self->merge;$args{ignore_exit}=$self->ignore_exit;$args{version}=$self->version if$self->version;if (my$exec=$self->exec){$args{exec}=ref$exec eq 'CODE' ? $exec->($self,$test_prog): [@$exec,$test_prog ];if (not defined$args{exec}){$args{source}=$test_prog}elsif ((ref($args{exec})|| "")ne "ARRAY"){$args{source}=delete$args{exec}}}else {$args{source}=$test_prog}if (defined(my$test_args=$self->test_args)){if (ref($test_args)eq 'HASH'){if (exists($test_args->{$job->description })){$test_args=$test_args->{$job->description }}else {$self->_croak("TAP::Harness Can't find test_args for " .$job->description)}}$args{test_args}=$test_args}return \%args}sub make_parser {my ($self,$job)=@_;my$args=$self->_get_parser_args($job);$self->_make_callback('parser_args',$args,$job->as_array_ref);my$parser=$self->_construct($self->parser_class,$args);$self->_make_callback('made_parser',$parser,$job->as_array_ref);my$session=$self->formatter->open_test($job->description,$parser);return ($parser,$session)}sub finish_parser {my ($self,$parser,$session)=@_;$session->close_test;$self->_close_spool($parser);return$parser}sub _open_spool {my$self=shift;my$test=shift;if (my$spool_dir=$ENV{PERL_TEST_HARNESS_DUMP_TAP}){my$spool=File::Spec->catfile($spool_dir,$test);my ($vol,$dir,undef)=File::Spec->splitpath($spool);my$path=File::Spec->catpath($vol,$dir,'');eval {mkpath($path)};$self->_croak($@)if $@;my$spool_handle=IO::Handle->new;open($spool_handle,">$spool")or $self->_croak(" Can't write $spool ( $! ) ");return$spool_handle}return}sub _close_spool {my$self=shift;my ($parser)=@_;if (my$spool_handle=$parser->delete_spool){close($spool_handle)or $self->_croak(" Error closing TAP spool file( $! ) \n ")}return}sub _croak {my ($self,$message)=@_;unless ($message){$message=$self->_error}$self->SUPER::_croak($message);return}1;
TAP_HARNESS

$fatpacked{"TAP/Harness/Env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_HARNESS_ENV';
  package TAP::Harness::Env;use strict;use warnings;use constant IS_VMS=>($^O eq 'VMS');use TAP::Object;use Text::ParseWords qw/shellwords/;our$VERSION='3.35';sub _filtered_inc_vms {my@inc=grep {!ref}@INC;@inc=grep {!/perl_root/i}@inc;my@default_inc=_default_inc();my@new_inc;my%seen;for my$dir (@inc){next if$seen{$dir}++;if ($dir eq ($default_inc[0]|| '')){shift@default_inc}else {push@new_inc,$dir}shift@default_inc while@default_inc and $seen{$default_inc[0]}}return@new_inc}my@inc;sub _default_inc {return@inc if@inc;local$ENV{PERL5LIB};local$ENV{PERLLIB};my$perl=$ENV{HARNESS_PERL}|| $^X;chomp(@inc=`"$perl" -e "print join qq[\\n], \@INC, q[]"`);return@inc}sub create {my$package=shift;my%input=%{shift || {}};my@libs=@{delete$input{libs}|| []};my@raw_switches=@{delete$input{switches}|| []};my@opt =(@raw_switches,shellwords($ENV{HARNESS_PERL_SWITCHES}|| ''));my@switches;while (my$opt=shift@opt){if ($opt =~ /^ -I (.*) $ /x){push@libs,length($1)? $1 : shift@opt}else {push@switches,$opt}}push@libs,_filtered_inc_vms()if IS_VMS;my$verbose =$ENV{HARNESS_VERBOSE}? $ENV{HARNESS_VERBOSE}!~ /\d/ ? 1 : $ENV{HARNESS_VERBOSE}: 0;my%args=(lib=>\@libs,timer=>$ENV{HARNESS_TIMER}|| 0,switches=>\@switches,color=>$ENV{HARNESS_COLOR}|| 0,verbosity=>$verbose,ignore_exit=>$ENV{HARNESS_IGNORE_EXIT}|| 0,);my$class=delete$input{harness_class}|| $ENV{HARNESS_SUBCLASS}|| 'TAP::Harness';if (defined(my$env_opt=$ENV{HARNESS_OPTIONS})){for my$opt (split /:/,$env_opt){if ($opt =~ /^j(\d*)$/){$args{jobs}=$1 || 9}elsif ($opt eq 'c'){$args{color}=1}elsif ($opt =~ m/^f(.*)$/){my$fmt=$1;$fmt =~ s/-/::/g;$args{formatter_class}=$fmt}elsif ($opt =~ m/^a(.*)$/){my$archive=$1;$class='TAP::Harness::Archive';$args{archive}=$archive}else {die "Unknown HARNESS_OPTIONS item: $opt\n"}}}return TAP::Object->_construct($class,{%args,%input })}1;
TAP_HARNESS_ENV

$fatpacked{"TAP/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_OBJECT';
  package TAP::Object;use strict;use warnings;our$VERSION='3.35';sub new {my$class=shift;my$self=bless {},$class;return$self->_initialize(@_)}sub _initialize {return $_[0]}sub _croak {my$proto=shift;require Carp;Carp::croak(@_);return}sub _confess {my$proto=shift;require Carp;Carp::confess(@_);return}sub _construct {my ($self,$class,@args)=@_;$self->_croak("Bad module name $class")unless$class =~ /^ \w+ (?: :: \w+ ) *$/x;unless ($class->can('new')){local $@;eval "require $class";$self->_croak("Can't load $class: $@")if $@}return$class->new(@args)}sub mk_methods {my ($class,@methods)=@_;for my$method_name (@methods){my$method="${class}::$method_name";no strict 'refs';*$method=sub {my$self=shift;$self->{$method_name}=shift if @_;return$self->{$method_name}}}}1;
TAP_OBJECT

$fatpacked{"TAP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER';
  package TAP::Parser;use strict;use warnings;use TAP::Parser::Grammar ();use TAP::Parser::Result ();use TAP::Parser::ResultFactory ();use TAP::Parser::Source ();use TAP::Parser::Iterator ();use TAP::Parser::IteratorFactory ();use TAP::Parser::SourceHandler::Executable ();use TAP::Parser::SourceHandler::Perl ();use TAP::Parser::SourceHandler::File ();use TAP::Parser::SourceHandler::RawTAP ();use TAP::Parser::SourceHandler::Handle ();use Carp qw(confess);use base 'TAP::Base';our$VERSION='3.35';my$DEFAULT_TAP_VERSION=12;my$MAX_TAP_VERSION=13;$ENV{TAP_VERSION}=$MAX_TAP_VERSION;END {delete$ENV{TAP_VERSION}}BEGIN {__PACKAGE__->mk_methods(qw(_iterator _spool exec exit is_good_plan plan tests_planned tests_run wait version in_todo start_time end_time start_times end_times skip_all grammar_class result_factory_class iterator_factory_class));sub _stream {my$self=shift;$self->_iterator(@_)}}sub _default_grammar_class {'TAP::Parser::Grammar'}sub _default_result_factory_class {'TAP::Parser::ResultFactory'}sub _default_iterator_factory_class {'TAP::Parser::IteratorFactory'}sub next {my$self=shift;return ($self->{_iter}||= $self->_iter)->()}sub run {my$self=shift;while (defined(my$result=$self->next)){}}sub make_iterator_factory {shift->iterator_factory_class->new(@_)}sub make_grammar {shift->grammar_class->new(@_)}sub make_result {shift->result_factory_class->make_result(@_)}{my%initialize=(version=>$DEFAULT_TAP_VERSION,plan=>'',tests_run=>0,skipped=>[],todo=>[],passed=>[],failed=>[],actual_failed=>[],actual_passed=>[],todo_passed=>[],parse_errors=>[],);my@legal_callback=qw(test version plan comment bailout unknown yaml ALL ELSE EOF);my@class_overrides=qw(grammar_class result_factory_class iterator_factory_class);sub _initialize {my ($self,$arg_for)=@_;my%args=%{$arg_for || {}};$self->SUPER::_initialize(\%args,\@legal_callback);for my$key (@class_overrides){my$default_method="_default_$key";my$val=delete$args{$key}|| $self->$default_method();$self->$key($val)}my$iterator=delete$args{iterator};$iterator ||= delete$args{stream};my$tap=delete$args{tap};my$version=delete$args{version};my$raw_source=delete$args{source};my$sources=delete$args{sources};my$exec=delete$args{exec};my$merge=delete$args{merge};my$spool=delete$args{spool};my$switches=delete$args{switches};my$ignore_exit=delete$args{ignore_exit};my$test_args=delete$args{test_args}|| [];if (1 < grep {defined}$iterator,$tap,$raw_source,$exec){$self->_croak("You may only choose one of 'exec', 'tap', 'source' or 'iterator'")}if (my@excess=sort keys%args){$self->_croak("Unknown options: @excess")}my$type='';my$source=TAP::Parser::Source->new;if ($tap){$type='raw TAP';$source->raw(\$tap)}elsif ($exec){$type='exec ' .$exec->[0];$source->raw({exec=>$exec })}elsif ($raw_source){$type='source ' .ref($raw_source)|| $raw_source;$source->raw(ref($raw_source)? $raw_source : \$raw_source)}elsif ($iterator){$type='iterator ' .ref($iterator)}if ($source->raw){my$src_factory=$self->make_iterator_factory($sources);$source->merge($merge)->switches($switches)->test_args($test_args);$iterator=$src_factory->make_iterator($source)}unless ($iterator){$self->_croak("PANIC: could not determine iterator for input $type")}while (my ($k,$v)=each%initialize){$self->{$k}='ARRAY' eq ref$v ? []: $v}$self->version($version)if$version;$self->_iterator($iterator);$self->_spool($spool);$self->ignore_exit($ignore_exit);return$self}}sub passed {return @{$_[0]->{passed}}if ref $_[0]->{passed};return wantarray ? 1 .. $_[0]->{passed}: $_[0]->{passed}}sub failed {@{shift->{failed}}}sub actual_passed {return @{$_[0]->{actual_passed}}if ref $_[0]->{actual_passed};return wantarray ? 1 .. $_[0]->{actual_passed}: $_[0]->{actual_passed}}*actual_ok=\&actual_passed;sub actual_failed {@{shift->{actual_failed}}}sub todo {@{shift->{todo}}}sub todo_passed {@{shift->{todo_passed}}}sub todo_failed {warn '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';goto&todo_passed}sub skipped {@{shift->{skipped}}}sub pragma {my ($self,$pragma)=splice @_,0,2;return$self->{pragma}->{$pragma}unless @_;if (my$state=shift){$self->{pragma}->{$pragma}=1}else {delete$self->{pragma}->{$pragma}}return}sub pragmas {sort keys %{shift->{pragma}|| {}}}sub good_plan {warn 'good_plan() is deprecated.  Please use "is_good_plan()"';goto&is_good_plan}sub has_problems {my$self=shift;return $self->failed || $self->parse_errors || (!$self->ignore_exit && ($self->wait || $self->exit))}sub ignore_exit {shift->pragma('ignore_exit',@_)}sub parse_errors {@{shift->{parse_errors}}}sub _add_error {my ($self,$error)=@_;push @{$self->{parse_errors}}=>$error;return$self}sub _make_state_table {my$self=shift;my%states;my%planned_todo=();my%state_globals=(comment=>{},bailout=>{},yaml=>{},version=>{act=>sub {$self->_add_error('If TAP version is present it must be the first line of output')},},unknown=>{act=>sub {my$unk=shift;if ($self->pragma('strict')){$self->_add_error('Unknown TAP token: "' .$unk->raw .'"')}},},pragma=>{act=>sub {my ($pragma)=@_;for my$pr ($pragma->pragmas){if ($pr =~ /^ ([-+])(\w+) $/x){$self->pragma($2,$1 eq '+')}}},},);my%state_defaults=(plan=>{act=>sub {my ($plan)=@_;$self->tests_planned($plan->tests_planned);$self->plan($plan->plan);if ($plan->has_skip){$self->skip_all($plan->explanation || '(no reason given)')}$planned_todo{$_}++ for @{$plan->todo_list}},},test=>{act=>sub {my ($test)=@_;my ($number,$tests_run)=($test->number,++$self->{tests_run});if (defined$number && delete$planned_todo{$number}){$test->set_directive('TODO')}my$has_todo=$test->has_todo;$self->in_todo($has_todo);if (defined(my$tests_planned=$self->tests_planned)){if ($tests_run > $tests_planned){$test->is_unplanned(1)}}if (defined$number){if ($number!=$tests_run){my$count=$tests_run;$self->_add_error("Tests out of sequence.  Found " ."($number) but expected ($count)")}}else {$test->_number($number=$tests_run)}push @{$self->{todo}}=>$number if$has_todo;push @{$self->{todo_passed}}=>$number if$test->todo_passed;push @{$self->{skipped}}=>$number if$test->has_skip;push @{$self->{$test->is_ok ? 'passed' : 'failed' }}=>$number;push @{$self->{$test->is_actual_ok ? 'actual_passed' : 'actual_failed' }}=>$number},},yaml=>{act=>sub {},},);%states=(INIT=>{version=>{act=>sub {my ($version)=@_;my$ver_num=$version->version;if ($ver_num <= $DEFAULT_TAP_VERSION){my$ver_min=$DEFAULT_TAP_VERSION + 1;$self->_add_error("Explicit TAP version must be at least " ."$ver_min. Got version $ver_num");$ver_num=$DEFAULT_TAP_VERSION}if ($ver_num > $MAX_TAP_VERSION){$self->_add_error("TAP specified version $ver_num but " ."we don't know about versions later " ."than $MAX_TAP_VERSION");$ver_num=$MAX_TAP_VERSION}$self->version($ver_num);$self->_grammar->set_version($ver_num)},goto=>'PLAN' },plan=>{goto=>'PLANNED' },test=>{goto=>'UNPLANNED' },},PLAN=>{plan=>{goto=>'PLANNED' },test=>{goto=>'UNPLANNED' },},PLANNED=>{test=>{goto=>'PLANNED_AFTER_TEST' },plan=>{act=>sub {my ($version)=@_;$self->_add_error('More than one plan found in TAP output')},},},PLANNED_AFTER_TEST=>{test=>{goto=>'PLANNED_AFTER_TEST' },plan=>{act=>sub {},continue=>'PLANNED' },yaml=>{goto=>'PLANNED' },},GOT_PLAN=>{test=>{act=>sub {my ($plan)=@_;my$line=$self->plan;$self->_add_error("Plan ($line) must be at the beginning " ."or end of the TAP output");$self->is_good_plan(0)},continue=>'PLANNED' },plan=>{continue=>'PLANNED' },},UNPLANNED=>{test=>{goto=>'UNPLANNED_AFTER_TEST' },plan=>{goto=>'GOT_PLAN' },},UNPLANNED_AFTER_TEST=>{test=>{act=>sub {},continue=>'UNPLANNED' },plan=>{act=>sub {},continue=>'UNPLANNED' },yaml=>{goto=>'UNPLANNED' },},);for my$name (keys%states){my$st={%state_globals,%{$states{$name}}};for my$next (sort keys %{$st}){if (my$default=$state_defaults{$next}){for my$def (sort keys %{$default}){$st->{$next}->{$def}||= $default->{$def}}}}$states{$name}=$st}return \%states}sub get_select_handles {shift->_iterator->get_select_handles}sub _grammar {my$self=shift;return$self->{_grammar}=shift if @_;return$self->{_grammar}||= $self->make_grammar({iterator=>$self->_iterator,parser=>$self,version=>$self->version })}sub _iter {my$self=shift;my$iterator=$self->_iterator;my$grammar=$self->_grammar;my$spool=$self->_spool;my$state='INIT';my$state_table=$self->_make_state_table;$self->start_time($self->get_time);$self->start_times($self->get_times);my$next_state=sub {my$token=shift;my$type=$token->type;TRANS: {my$state_spec=$state_table->{$state}or die "Illegal state: $state";if (my$next=$state_spec->{$type}){if (my$act=$next->{act}){$act->($token)}if (my$cont=$next->{continue}){$state=$cont;redo TRANS}elsif (my$goto=$next->{goto}){$state=$goto}}else {confess("Unhandled token type: $type\n")}}return$token};my$end_handler=sub {$self->exit($iterator->exit);$self->wait($iterator->wait);$self->_finish;return};if ($self->_has_callbacks){return sub {my$result=eval {$grammar->tokenize};$self->_add_error($@)if $@;if (defined$result){$result=$next_state->($result);if (my$code=$self->_callback_for($result->type)){$_->($result)for @{$code}}else {$self->_make_callback('ELSE',$result)}$self->_make_callback('ALL',$result);print {$spool}$result->raw,"\n" if$spool}else {$result=$end_handler->();$self->_make_callback('EOF',$self)unless defined$result}return$result}}else {return sub {my$result=eval {$grammar->tokenize};$self->_add_error($@)if $@;if (defined$result){$result=$next_state->($result);print {$spool}$result->raw,"\n" if$spool}else {$result=$end_handler->()}return$result}}}sub _finish {my$self=shift;$self->end_time($self->get_time);$self->end_times($self->get_times);$self->_iterator(undef);$self->_grammar(undef);$self->{_iter}=sub {return}if $] >= 5.006;if (!$self->plan){$self->_add_error('No plan found in TAP output')}else {$self->is_good_plan(1)unless defined$self->is_good_plan}if ($self->tests_run!=($self->tests_planned || 0)){$self->is_good_plan(0);if (defined(my$planned=$self->tests_planned)){my$ran=$self->tests_run;$self->_add_error("Bad plan.  You planned $planned tests but ran $ran.")}}if ($self->tests_run!=($self->passed + $self->failed)){my$actual=$self->tests_run;my$passed=$self->passed;my$failed=$self->failed;$self->_croak("Panic: planned test count ($actual) did not equal " ."sum of passed ($passed) and failed ($failed) tests!")}$self->is_good_plan(0)unless defined$self->is_good_plan;unless ($self->parse_errors){if ($self->tests_run==@{$self->{passed}}){$self->{passed}=$self->tests_run}if ($self->tests_run==@{$self->{actual_passed}}){$self->{actual_passed}=$self->tests_run}}return$self}sub delete_spool {my$self=shift;return delete$self->{_spool}}1;
TAP_PARSER

$fatpacked{"TAP/Parser/Aggregator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_AGGREGATOR';
  package TAP::Parser::Aggregator;use strict;use warnings;use Benchmark;use base 'TAP::Object';our$VERSION='3.35';my%SUMMARY_METHOD_FOR;BEGIN {%SUMMARY_METHOD_FOR=map {$_=>$_}qw(failed parse_errors passed skipped todo todo_passed total wait exit);$SUMMARY_METHOD_FOR{total}='tests_run';$SUMMARY_METHOD_FOR{planned}='tests_planned';for my$method (keys%SUMMARY_METHOD_FOR){next if 'total' eq $method;no strict 'refs';*$method=sub {my$self=shift;return wantarray ? @{$self->{"descriptions_for_$method"}}: $self->{$method}}}}sub _initialize {my ($self)=@_;$self->{parser_for}={};$self->{parse_order}=[];for my$summary (keys%SUMMARY_METHOD_FOR){$self->{$summary}=0;next if 'total' eq $summary;$self->{"descriptions_for_$summary"}=[]}return$self}sub add {my ($self,$description,$parser)=@_;if (exists$self->{parser_for}{$description}){$self->_croak("You already have a parser for ($description)." ." Perhaps you have run the same test twice.")}push @{$self->{parse_order}}=>$description;$self->{parser_for}{$description}=$parser;while (my ($summary,$method)=each%SUMMARY_METHOD_FOR){next if ($method eq 'exit' || $method eq 'wait')&& $parser->ignore_exit;if (my$count=$parser->$method()){$self->{$summary}+= $count;push @{$self->{"descriptions_for_$summary"}}=>$description}}return$self}sub parsers {my$self=shift;return$self->_get_parsers(@_)if @_;my$descriptions=$self->{parse_order};my@parsers=@{$self->{parser_for}}{@$descriptions};return@parsers}sub _get_parsers {my ($self,@descriptions)=@_;my@parsers;for my$description (@descriptions){$self->_croak("A parser for ($description) could not be found")unless exists$self->{parser_for}{$description};push@parsers=>$self->{parser_for}{$description}}return wantarray ? @parsers : \@parsers}sub descriptions {@{shift->{parse_order}|| []}}sub start {my$self=shift;$self->{start_time}=Benchmark->new}sub stop {my$self=shift;$self->{end_time}=Benchmark->new}sub elapsed {my$self=shift;require Carp;Carp::croak q{Can't call elapsed without first calling start and then stop} unless defined$self->{start_time}&& defined$self->{end_time};return timediff($self->{end_time},$self->{start_time})}sub elapsed_timestr {my$self=shift;my$elapsed=$self->elapsed;return timestr($elapsed)}sub all_passed {my$self=shift;return $self->total && $self->total==$self->passed &&!$self->has_errors}sub get_status {my$self=shift;my$total=$self->total;my$passed=$self->passed;return ($self->has_errors || $total!=$passed)? 'FAIL' : $total ? 'PASS' : 'NOTESTS'}sub total {shift->{total}}sub has_problems {my$self=shift;return$self->todo_passed || $self->has_errors}sub has_errors {my$self=shift;return $self->failed || $self->parse_errors || $self->exit || $self->wait}sub todo_failed {warn '"todo_failed" is deprecated.  Please use "todo_passed".  See the docs.';goto&todo_passed}1;
TAP_PARSER_AGGREGATOR

$fatpacked{"TAP/Parser/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_GRAMMAR';
  package TAP::Parser::Grammar;use strict;use warnings;use TAP::Parser::ResultFactory ();use TAP::Parser::YAMLish::Reader ();use base 'TAP::Object';our$VERSION='3.35';sub _initialize {my ($self,$args)=@_;$self->{iterator}=$args->{iterator};$self->{iterator}||= $args->{stream};$self->{parser}=$args->{parser};$self->set_version($args->{version}|| 12);return$self}my%language_for;{my$ok=qr/(?:not )?ok\b/;my$num=qr/\d+/;my%v12=(version=>{syntax=>qr/^TAP\s+version\s+(\d+)\s*\z/i,handler=>sub {my ($self,$line)=@_;my$version=$1;return$self->_make_version_token($line,$version,)},},plan=>{syntax=>qr/^1\.\.(\d+)\s*(.*)\z/,handler=>sub {my ($self,$line)=@_;my ($tests_planned,$tail)=($1,$2);my$explanation=undef;my$skip='';if ($tail =~ /^todo((?:\s+\d+)+)/){my@todo=split /\s+/,_trim($1);return$self->_make_plan_token($line,$tests_planned,'TODO','',\@todo)}elsif (0==$tests_planned){$skip='SKIP';($explanation)=$tail =~ /^#\s*SKIP\S*\s+(.*)/i}elsif ($tail !~ /^\s*$/){return$self->_make_unknown_token($line)}$explanation='' unless defined$explanation;return$self->_make_plan_token($line,$tests_planned,$skip,$explanation,[])},},simple_test=>{syntax=>qr/^($ok) \ ($num) (?:\ ([^#]+))? \z/x,handler=>sub {my ($self,$line)=@_;my ($ok,$num,$desc)=($1,$2,$3);return$self->_make_test_token($line,$ok,$num,$desc)},},test=>{syntax=>qr/^($ok) \s* ($num)? \s* (.*) \z/x,handler=>sub {my ($self,$line)=@_;my ($ok,$num,$desc)=($1,$2,$3);my ($dir,$explanation)=('','');if ($desc =~ m/^ ( [^\\\#]* (?: \\. [^\\\#]* )* )
                         \# \s* (SKIP|TODO) \b \s* (.*) $/ix){($desc,$dir,$explanation)=($1,$2,$3)}return$self->_make_test_token($line,$ok,$num,$desc,$dir,$explanation)},},comment=>{syntax=>qr/^#(.*)/,handler=>sub {my ($self,$line)=@_;my$comment=$1;return$self->_make_comment_token($line,$comment)},},bailout=>{syntax=>qr/^\s*Bail out!\s*(.*)/,handler=>sub {my ($self,$line)=@_;my$explanation=$1;return$self->_make_bailout_token($line,$explanation)},},);my%v13=(%v12,plan=>{syntax=>qr/^1\.\.(\d+)(?:\s*#\s*SKIP\b(.*))?\z/i,handler=>sub {my ($self,$line)=@_;my ($tests_planned,$explanation)=($1,$2);my$skip =(0==$tests_planned || defined$explanation)? 'SKIP' : '';$explanation='' unless defined$explanation;return$self->_make_plan_token($line,$tests_planned,$skip,$explanation,[])},},yaml=>{syntax=>qr/^ (\s+) (---.*) $/x,handler=>sub {my ($self,$line)=@_;my ($pad,$marker)=($1,$2);return$self->_make_yaml_token($pad,$marker)},},pragma=>{syntax=>qr/^ pragma \s+ ( [-+] \w+ \s* (?: , \s* [-+] \w+ \s* )* ) $/x,handler=>sub {my ($self,$line)=@_;my$pragmas=$1;return$self->_make_pragma_token($line,$pragmas)},},);%language_for=('12'=>{tokens=>\%v12,},'13'=>{tokens=>\%v13,setup=>sub {shift->{iterator}->handle_unicode},},)}sub set_version {my$self=shift;my$version=shift;if (my$language=$language_for{$version}){$self->{version}=$version;$self->{tokens}=$language->{tokens};if (my$setup=$language->{setup}){$self->$setup()}$self->_order_tokens}else {require Carp;Carp::croak("Unsupported syntax version: $version")}}sub _order_tokens {my$self=shift;my%copy=%{$self->{tokens}};my@ordered_tokens=grep {defined}map {delete$copy{$_}}qw(simple_test test comment plan);push@ordered_tokens,values%copy;$self->{ordered_tokens}=\@ordered_tokens}sub tokenize {my$self=shift;my$line=$self->{iterator}->next;unless (defined$line){delete$self->{parser};return}my$token;for my$token_data (@{$self->{ordered_tokens}}){if ($line =~ $token_data->{syntax}){my$handler=$token_data->{handler};$token=$self->$handler($line);last}}$token=$self->_make_unknown_token($line)unless$token;return$self->{parser}->make_result($token)}sub token_types {my$self=shift;return keys %{$self->{tokens}}}sub syntax_for {my ($self,$type)=@_;return$self->{tokens}->{$type}->{syntax}}sub handler_for {my ($self,$type)=@_;return$self->{tokens}->{$type}->{handler}}sub _make_version_token {my ($self,$line,$version)=@_;return {type=>'version',raw=>$line,version=>$version,}}sub _make_plan_token {my ($self,$line,$tests_planned,$directive,$explanation,$todo)=@_;if ($directive eq 'SKIP' && 0!=$tests_planned && $self->{version}< 13){warn "Specified SKIP directive in plan but more than 0 tests ($line)\n"}return {type=>'plan',raw=>$line,tests_planned=>$tests_planned,directive=>$directive,explanation=>_trim($explanation),todo_list=>$todo,}}sub _make_test_token {my ($self,$line,$ok,$num,$desc,$dir,$explanation)=@_;return {ok=>$ok,test_num=>(defined$num ? 0 + $num : undef),description=>_trim($desc),directive=>(defined$dir ? uc$dir : ''),explanation=>_trim($explanation),raw=>$line,type=>'test',}}sub _make_unknown_token {my ($self,$line)=@_;return {raw=>$line,type=>'unknown',}}sub _make_comment_token {my ($self,$line,$comment)=@_;return {type=>'comment',raw=>$line,comment=>_trim($comment)}}sub _make_bailout_token {my ($self,$line,$explanation)=@_;return {type=>'bailout',raw=>$line,bailout=>_trim($explanation)}}sub _make_yaml_token {my ($self,$pad,$marker)=@_;my$yaml=TAP::Parser::YAMLish::Reader->new;my$iterator=$self->{iterator};my$leader=length($pad);my$strip=qr{ ^ (\s{$leader}) (.*) $ }x;my@extra=($marker);my$reader=sub {return shift@extra if@extra;my$line=$iterator->next;return $2 if$line =~ $strip;return};my$data=$yaml->read($reader);chomp(my$raw=$yaml->get_raw);$raw =~ s/^/$pad/mg;return {type=>'yaml',raw=>$raw,data=>$data }}sub _make_pragma_token {my ($self,$line,$pragmas)=@_;return {type=>'pragma',raw=>$line,pragmas=>[split /\s*,\s*/,_trim($pragmas)],}}sub _trim {my$data=shift;return '' unless defined$data;$data =~ s/^\s+//;$data =~ s/\s+$//;return$data}1;
TAP_PARSER_GRAMMAR

$fatpacked{"TAP/Parser/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR';
  package TAP::Parser::Iterator;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.35';sub next {my$self=shift;my$line=$self->next_raw;if (defined($line)and $line =~ /^\s*not\s*$/){$line .= ($self->next_raw || '')}return$line}sub next_raw {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}sub handle_unicode {}sub get_select_handles {return}sub wait {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}sub exit {require Carp;my$msg=Carp::longmess('abstract method called directly!');$_[0]->_croak($msg)}1;
TAP_PARSER_ITERATOR

$fatpacked{"TAP/Parser/Iterator/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_ARRAY';
  package TAP::Parser::Iterator::Array;use strict;use warnings;use base 'TAP::Parser::Iterator';our$VERSION='3.35';sub _initialize {my ($self,$thing)=@_;chomp @$thing;$self->{idx}=0;$self->{array}=$thing;$self->{exit}=undef;return$self}sub wait {shift->exit}sub exit {my$self=shift;return 0 if$self->{idx}>= @{$self->{array}};return}sub next_raw {my$self=shift;return$self->{array}->[$self->{idx}++ ]}1;
TAP_PARSER_ITERATOR_ARRAY

$fatpacked{"TAP/Parser/Iterator/Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_PROCESS';
  package TAP::Parser::Iterator::Process;use strict;use warnings;use Config;use IO::Handle;use base 'TAP::Parser::Iterator';my$IS_WIN32=($^O =~ /^(MS)?Win32$/);our$VERSION='3.35';{no warnings 'uninitialized';local$SIG{__DIE__}=undef;eval {require POSIX;&POSIX::WEXITSTATUS(0)};if ($@){*_wait2exit=sub {$_[1]>> 8}}else {*_wait2exit=sub {POSIX::WEXITSTATUS($_[1])}}}sub _use_open3 {my$self=shift;return unless$Config{d_fork}|| $IS_WIN32;for my$module (qw(IPC::Open3 IO::Select)){eval "use $module";return if $@}return 1}{my$got_unicode;sub _get_unicode {return$got_unicode if defined$got_unicode;eval 'use Encode qw(decode_utf8);';$got_unicode=$@ ? 0 : 1}}sub _initialize {my ($self,$args)=@_;my@command=@{delete$args->{command}|| []}or die "Must supply a command to execute";$self->{command}=[@command];my$chunk_size=delete$args->{_chunk_size}|| 65536;my$merge=delete$args->{merge};my ($pid,$err,$sel);if (my$setup=delete$args->{setup}){$setup->(@command)}my$out=IO::Handle->new;if ($self->_use_open3){my$xclose=\&IPC::Open3::xclose;no warnings;local*IPC::Open3::xclose=sub {my$fh=shift;no strict 'refs';return if (fileno($fh)==fileno(STDIN));$xclose->($fh)};if ($IS_WIN32){$err=$merge ? '' : '>&STDERR';eval {$pid=open3('<&STDIN',$out,$merge ? '' : $err,@command)};die "Could not execute (@command): $@" if $@;if ($] >= 5.006){binmode($out,":crlf")}}else {$err=$merge ? '' : IO::Handle->new;eval {$pid=open3('<&STDIN',$out,$err,@command)};die "Could not execute (@command): $@" if $@;$sel=$merge ? undef : IO::Select->new($out,$err)}}else {$err='';my$command =join(' ',map {$_ =~ /\s/ ? qq{"$_"} : $_}@command);open($out,"$command|")or die "Could not execute ($command): $!"}$self->{out}=$out;$self->{err}=$err;$self->{sel}=$sel;$self->{pid}=$pid;$self->{exit}=undef;$self->{chunk_size}=$chunk_size;if (my$teardown=delete$args->{teardown}){$self->{teardown}=sub {$teardown->(@command)}}return$self}sub handle_unicode {my$self=shift;if ($self->{sel}){if (_get_unicode()){my$next=$self->{_next}||= $self->_next;$self->{_next}=sub {my$line=$next->();return decode_utf8($line)if defined$line;return}}}else {if ($] >= 5.008){eval 'binmode($self->{out}, ":utf8")'}}}sub wait {shift->{wait}}sub exit {shift->{exit}}sub _next {my$self=shift;if (my$out=$self->{out}){if (my$sel=$self->{sel}){my$err=$self->{err};my@buf=();my$partial='';my$chunk_size=$self->{chunk_size};return sub {return shift@buf if@buf;READ: while (my@ready=$sel->can_read){for my$fh (@ready){my$got=sysread$fh,my ($chunk),$chunk_size;if ($got==0){$sel->remove($fh)}elsif ($fh==$err){print STDERR$chunk}else {$chunk=$partial .$chunk;$partial='';unless (substr($chunk,-1,1)eq "\n"){my$nl=rindex$chunk,"\n";if ($nl==-1){$partial=$chunk;redo READ}else {$partial=substr($chunk,$nl + 1);$chunk=substr($chunk,0,$nl)}}push@buf,split /\n/,$chunk;return shift@buf if@buf}}}if (length$partial){my$last=$partial;$partial='';return$last}$self->_finish;return}}else {return sub {if (defined(my$line=<$out>)){chomp$line;return$line}$self->_finish;return}}}else {return sub {$self->_finish;return}}}sub next_raw {my$self=shift;return ($self->{_next}||= $self->_next)->()}sub _finish {my$self=shift;my$status=$?;$self->{_next}=sub {return}if $] >= 5.006;if (defined$self->{pid}){if ($self->{pid}==waitpid($self->{pid},0)){$status=$?}}(delete$self->{out})->close if$self->{out};if ($self->{sel}){(delete$self->{err})->close;delete$self->{sel}}else {$status=$?}$status=0 if$IS_WIN32 && $status==-1;$self->{wait}=$status;$self->{exit}=$self->_wait2exit($status);if (my$teardown=$self->{teardown}){$teardown->()}return$self}sub get_select_handles {my$self=shift;return grep $_,($self->{out},$self->{err})}1;
TAP_PARSER_ITERATOR_PROCESS

$fatpacked{"TAP/Parser/Iterator/Stream.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATOR_STREAM';
  package TAP::Parser::Iterator::Stream;use strict;use warnings;use base 'TAP::Parser::Iterator';our$VERSION='3.35';sub _initialize {my ($self,$thing)=@_;$self->{fh}=$thing;return$self}sub wait {shift->exit}sub exit {shift->{fh}? (): 0}sub next_raw {my$self=shift;my$fh=$self->{fh};if (defined(my$line=<$fh>)){chomp$line;return$line}else {$self->_finish;return}}sub _finish {my$self=shift;close delete$self->{fh}}1;
TAP_PARSER_ITERATOR_STREAM

$fatpacked{"TAP/Parser/IteratorFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_ITERATORFACTORY';
  package TAP::Parser::IteratorFactory;use strict;use warnings;use Carp qw(confess);use File::Basename qw(fileparse);use base 'TAP::Object';use constant handlers=>[];our$VERSION='3.35';sub _initialize {my ($self,$config)=@_;$self->config($config || {})->load_handlers;return$self}sub register_handler {my ($class,$dclass)=@_;confess("$dclass must implement can_handle & make_iterator methods!")unless UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');my$handlers=$class->handlers;push @{$handlers},$dclass unless grep {$_ eq $dclass}@{$handlers};return$class}sub config {my$self=shift;return$self->{config}unless @_;unless ('HASH' eq ref $_[0]){$self->_croak('Argument to &config must be a hash reference')}$self->{config}=shift;return$self}sub _last_handler {my$self=shift;return$self->{last_handler}unless @_;$self->{last_handler}=shift;return$self}sub _testing {my$self=shift;return$self->{testing}unless @_;$self->{testing}=shift;return$self}sub load_handlers {my ($self)=@_;for my$handler (keys %{$self->config}){my$sclass=$self->_load_handler($handler)}return$self}sub _load_handler {my ($self,$handler)=@_;my@errors;for my$dclass ("TAP::Parser::SourceHandler::$handler",$handler){return$dclass if UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');eval "use $dclass";if (my$e=$@){push@errors,$e;next}return$dclass if UNIVERSAL::can($dclass,'can_handle')&& UNIVERSAL::can($dclass,'make_iterator');push@errors,"handler '$dclass' does not implement can_handle & make_iterator"}$self->_croak("Cannot load handler '$handler': " .join("\n",@errors))}sub make_iterator {my ($self,$source)=@_;$self->_croak('no raw source defined!')unless defined$source->raw;$source->config($self->config)->assemble_meta;return$source->raw if ($source->meta->{is_object}&& UNIVERSAL::isa($source->raw,'TAP::Parser::SourceHandler'));my$sd_class=$self->detect_source($source);$self->_last_handler($sd_class);return if$self->_testing;my$iterator=$sd_class->make_iterator($source);return$iterator}sub detect_source {my ($self,$source)=@_;confess('no raw source ref defined!')unless defined$source->raw;my%handlers;for my$dclass (@{$self->handlers}){my$confidence=$dclass->can_handle($source);$handlers{$dclass}=$confidence if$confidence}if (!%handlers){my$raw_source_short=substr(${$source->raw},0,50);confess("Cannot detect source of '$raw_source_short'!");return}my@handlers=(map {$_}sort {$handlers{$a}cmp $handlers{$b}}keys%handlers);if ($ENV{TAP_HARNESS_SOURCE_FACTORY_VOTES}){warn("votes: ",join(', ',map {"$_: $handlers{$_}"}@handlers),"\n")}return pop@handlers}1;
TAP_PARSER_ITERATORFACTORY

$fatpacked{"TAP/Parser/Multiplexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_MULTIPLEXER';
  package TAP::Parser::Multiplexer;use strict;use warnings;use IO::Select;use base 'TAP::Object';use constant IS_WIN32=>$^O =~ /^(MS)?Win32$/;use constant IS_VMS=>$^O eq 'VMS';use constant SELECT_OK=>!(IS_VMS || IS_WIN32);our$VERSION='3.35';sub _initialize {my$self=shift;$self->{select}=IO::Select->new;$self->{avid}=[];$self->{count}=0;return$self}sub add {my ($self,$parser,$stash)=@_;if (SELECT_OK && (my@handles=$parser->get_select_handles)){my$sel=$self->{select};my@filenos=map {fileno $_}@handles;for my$h (@handles){$sel->add([$h,$parser,$stash,@filenos ])}$self->{count}++}else {push @{$self->{avid}},[$parser,$stash ]}}sub parsers {my$self=shift;return$self->{count}+ scalar @{$self->{avid}}}sub _iter {my$self=shift;my$sel=$self->{select};my$avid=$self->{avid};my@ready=();return sub {if (@$avid){my ($parser,$stash)=@{$avid->[0]};my$result=$parser->next;shift @$avid unless defined$result;return ($parser,$stash,$result)}unless (@ready){return unless$sel->count;@ready=$sel->can_read}my ($h,$parser,$stash,@handles)=@{shift@ready};my$result=$parser->next;unless (defined$result){$sel->remove(@handles);$self->{count}--;@ready=()}return ($parser,$stash,$result)}}sub next {my$self=shift;return ($self->{_iter}||= $self->_iter)->()}1;
TAP_PARSER_MULTIPLEXER

$fatpacked{"TAP/Parser/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT';
  package TAP::Parser::Result;use strict;use warnings;use base 'TAP::Object';BEGIN {my@attrs=qw(plan pragma test comment bailout version unknown yaml);no strict 'refs';for my$token (@attrs){my$method="is_$token";*$method=sub {return$token eq shift->type}}}our$VERSION='3.35';sub _initialize {my ($self,$token)=@_;if ($token){@{$self}{keys %$token }=values %$token}return$self}sub raw {shift->{raw}}sub type {shift->{type}}sub as_string {shift->{raw}}sub is_ok {1}sub passed {warn 'passed() is deprecated.  Please use "is_ok()"';shift->is_ok}sub has_directive {my$self=shift;return ($self->has_todo || $self->has_skip)}sub has_todo {'TODO' eq (shift->{directive}|| '')}sub has_skip {'SKIP' eq (shift->{directive}|| '')}sub set_directive {my ($self,$dir)=@_;$self->{directive}=$dir}1;
TAP_PARSER_RESULT

$fatpacked{"TAP/Parser/Result/Bailout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_BAILOUT';
  package TAP::Parser::Result::Bailout;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.35';sub explanation {shift->{bailout}}sub as_string {shift->{bailout}}1;
TAP_PARSER_RESULT_BAILOUT

$fatpacked{"TAP/Parser/Result/Comment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_COMMENT';
  package TAP::Parser::Result::Comment;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.35';sub comment {shift->{comment}}sub as_string {shift->{raw}}1;
TAP_PARSER_RESULT_COMMENT

$fatpacked{"TAP/Parser/Result/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PLAN';
  package TAP::Parser::Result::Plan;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.35';sub plan {'1..' .shift->{tests_planned}}sub tests_planned {shift->{tests_planned}}sub directive {shift->{directive}}sub explanation {shift->{explanation}}sub todo_list {shift->{todo_list}}1;
TAP_PARSER_RESULT_PLAN

$fatpacked{"TAP/Parser/Result/Pragma.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_PRAGMA';
  package TAP::Parser::Result::Pragma;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.35';sub pragmas {my@pragmas=@{shift->{pragmas}};return wantarray ? @pragmas : \@pragmas}1;
TAP_PARSER_RESULT_PRAGMA

$fatpacked{"TAP/Parser/Result/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_TEST';
  package TAP::Parser::Result::Test;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.35';sub ok {shift->{ok}}sub number {shift->{test_num}}sub _number {my ($self,$number)=@_;$self->{test_num}=$number}sub description {shift->{description}}sub directive {shift->{directive}}sub explanation {shift->{explanation}}sub is_ok {my$self=shift;return if$self->is_unplanned;return$self->has_todo ? 1 : $self->ok !~ /not/}sub is_actual_ok {my$self=shift;return$self->{ok}!~ /not/}sub actual_passed {warn 'actual_passed() is deprecated.  Please use "is_actual_ok()"';goto&is_actual_ok}sub todo_passed {my$self=shift;return$self->has_todo && $self->is_actual_ok}sub todo_failed {warn 'todo_failed() is deprecated.  Please use "todo_passed()"';goto&todo_passed}sub as_string {my$self=shift;my$string=$self->ok ." " .$self->number;if (my$description=$self->description){$string .= " $description"}if (my$directive=$self->directive){my$explanation=$self->explanation;$string .= " # $directive $explanation"}return$string}sub is_unplanned {my$self=shift;return ($self->{unplanned}|| '')unless @_;$self->{unplanned}=!!shift;return$self}1;
TAP_PARSER_RESULT_TEST

$fatpacked{"TAP/Parser/Result/Unknown.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_UNKNOWN';
  package TAP::Parser::Result::Unknown;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.35';1;
TAP_PARSER_RESULT_UNKNOWN

$fatpacked{"TAP/Parser/Result/Version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_VERSION';
  package TAP::Parser::Result::Version;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.35';sub version {shift->{version}}1;
TAP_PARSER_RESULT_VERSION

$fatpacked{"TAP/Parser/Result/YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULT_YAML';
  package TAP::Parser::Result::YAML;use strict;use warnings;use base 'TAP::Parser::Result';our$VERSION='3.35';sub data {shift->{data}}1;
TAP_PARSER_RESULT_YAML

$fatpacked{"TAP/Parser/ResultFactory.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_RESULTFACTORY';
  package TAP::Parser::ResultFactory;use strict;use warnings;use TAP::Parser::Result::Bailout ();use TAP::Parser::Result::Comment ();use TAP::Parser::Result::Plan ();use TAP::Parser::Result::Pragma ();use TAP::Parser::Result::Test ();use TAP::Parser::Result::Unknown ();use TAP::Parser::Result::Version ();use TAP::Parser::Result::YAML ();use base 'TAP::Object';our$VERSION='3.35';sub make_result {my ($proto,$token)=@_;my$type=$token->{type};return$proto->class_for($type)->new($token)}our%CLASS_FOR=(plan=>'TAP::Parser::Result::Plan',pragma=>'TAP::Parser::Result::Pragma',test=>'TAP::Parser::Result::Test',comment=>'TAP::Parser::Result::Comment',bailout=>'TAP::Parser::Result::Bailout',version=>'TAP::Parser::Result::Version',unknown=>'TAP::Parser::Result::Unknown',yaml=>'TAP::Parser::Result::YAML',);sub class_for {my ($class,$type)=@_;return$CLASS_FOR{$type}if exists$CLASS_FOR{$type};require Carp;Carp::croak("Could not determine class for result type '$type'")}sub register_type {my ($class,$type,$rclass)=@_;$CLASS_FOR{$type}=$rclass;return$class}1;
TAP_PARSER_RESULTFACTORY

$fatpacked{"TAP/Parser/Scheduler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER';
  package TAP::Parser::Scheduler;use strict;use warnings;use Carp;use TAP::Parser::Scheduler::Job;use TAP::Parser::Scheduler::Spinner;our$VERSION='3.35';sub new {my$class=shift;croak "Need a number of key, value pairs" if @_ % 2;my%args=@_;my$tests=delete$args{tests}|| croak "Need a 'tests' argument";my$rules=delete$args{rules}|| {par=>'**' };croak "Unknown arg(s): ",join ', ',sort keys%args if keys%args;my$self=bless {},$class;$self->_set_rules($rules,$tests);return$self}sub _set_rules {my ($self,$rules,$tests)=@_;my@tests=map {TAP::Parser::Scheduler::Job->new(@$_)}map {'ARRAY' eq ref $_ ? $_ : [$_,$_ ]}@$tests;my$schedule=$self->_rule_clause($rules,\@tests);$schedule=[[$schedule,@tests ]]if@tests;$self->{schedule}=$schedule}sub _rule_clause {my ($self,$rule,$tests)=@_;croak 'Rule clause must be a hash' unless 'HASH' eq ref$rule;my@type=keys %$rule;croak 'Rule clause must have exactly one key' unless@type==1;my%handlers=(par=>sub {[map {[$_]}@_ ]},seq=>sub {[[@_]]},);my$handler=$handlers{$type[0]}|| croak 'Unknown scheduler type: ',$type[0];my$val=$rule->{$type[0]};return$handler->(map {'HASH' eq ref $_ ? $self->_rule_clause($_,$tests): $self->_expand($_,$tests)}'ARRAY' eq ref$val ? @$val : $val)}sub _glob_to_regexp {my ($self,$glob)=@_;my$nesting;my$pattern;while (1){if ($glob =~ /\G\*\*/gc){$pattern .= '.*?'}elsif ($glob =~ /\G\*/gc){$pattern .= '[^/]*'}elsif ($glob =~ /\G\?/gc){$pattern .= '[^/]'}elsif ($glob =~ /\G\{/gc){$pattern .= '(?:';++$nesting}elsif ($nesting and $glob =~ /\G,/gc){$pattern .= '|'}elsif ($nesting and $glob =~ /\G\}/gc){$pattern .= ')';--$nesting}elsif ($glob =~ /\G(\\.)/gc){$pattern .= $1}elsif ($glob =~ /\G([\},])/gc){$pattern .= '\\' .$1}else {$glob =~ /\G([^{?*\\\},]*)/gc;$pattern .= quotemeta $1}return$pattern if pos$glob==length$glob}}sub _expand {my ($self,$name,$tests)=@_;my$pattern=$self->_glob_to_regexp($name);$pattern=qr/^ $pattern $/x;my@match=();for (my$ti=0;$ti < @$tests;$ti++ ){if ($tests->[$ti]->filename =~ $pattern){push@match,splice @$tests,$ti,1;$ti--}}return@match}sub get_all {my$self=shift;my@all=$self->_gather($self->{schedule});$self->{count}=@all;@all}sub _gather {my ($self,$rule)=@_;return unless defined$rule;return$rule unless 'ARRAY' eq ref$rule;return map {defined()? $self->_gather($_): ()}map {@$_}@$rule}sub get_job {my$self=shift;$self->{count}||= $self->get_all;my@jobs=$self->_find_next_job($self->{schedule});if (@jobs){--$self->{count};return$jobs[0]}return TAP::Parser::Scheduler::Spinner->new if$self->{count};return}sub _not_empty {my$ar=shift;return 1 unless 'ARRAY' eq ref$ar;for (@$ar){return 1 if _not_empty($_)}return}sub _is_empty {!_not_empty(@_)}sub _find_next_job {my ($self,$rule)=@_;my@queue=();my$index=0;while ($index < @$rule){my$seq=$rule->[$index];shift @$seq while @$seq && _is_empty($seq->[0]);if (@$seq){if (defined$seq->[0]){if ('ARRAY' eq ref$seq->[0]){push@queue,$seq}else {my$job=splice @$seq,0,1,undef;$job->on_finish(sub {shift @$seq});return$job}}++$index}else {splice @$rule,$index,1}}for my$seq (@queue){if (my@jobs=$self->_find_next_job($seq->[0])){return@jobs}}return}sub as_string {my$self=shift;return$self->_as_string($self->{schedule})}sub _as_string {my ($self,$rule,$depth)=(shift,shift,shift || 0);my$pad=' ' x 2;my$indent=$pad x $depth;if (!defined$rule){return "$indent(undef)\n"}elsif ('ARRAY' eq ref$rule){return unless @$rule;my$type=('par','seq')[$depth % 2 ];return join('',"$indent$type:\n",map {$self->_as_string($_,$depth + 1)}@$rule)}else {return "$indent'" .$rule->filename ."'\n"}}1;
TAP_PARSER_SCHEDULER

$fatpacked{"TAP/Parser/Scheduler/Job.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_JOB';
  package TAP::Parser::Scheduler::Job;use strict;use warnings;use Carp;our$VERSION='3.35';sub new {my ($class,$name,$desc,@ctx)=@_;return bless {filename=>$name,description=>$desc,@ctx ? (context=>\@ctx): (),},$class}sub on_finish {my ($self,$cb)=@_;$self->{on_finish}=$cb}sub finish {my$self=shift;if (my$cb=$self->{on_finish}){$cb->($self)}}sub filename {shift->{filename}}sub description {shift->{description}}sub context {@{shift->{context}|| []}}sub as_array_ref {my$self=shift;return [$self->filename,$self->description,$self->{context}||= []]}sub is_spinner {0}1;
TAP_PARSER_SCHEDULER_JOB

$fatpacked{"TAP/Parser/Scheduler/Spinner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SCHEDULER_SPINNER';
  package TAP::Parser::Scheduler::Spinner;use strict;use warnings;use Carp;our$VERSION='3.35';sub new {bless {},shift}sub is_spinner {1}1;
TAP_PARSER_SCHEDULER_SPINNER

$fatpacked{"TAP/Parser/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCE';
  package TAP::Parser::Source;use strict;use warnings;use File::Basename qw(fileparse);use base 'TAP::Object';use constant BLK_SIZE=>512;our$VERSION='3.35';sub _initialize {my ($self)=@_;$self->meta({});$self->config({});return$self}sub raw {my$self=shift;return$self->{raw}unless @_;$self->{raw}=shift;return$self}sub meta {my$self=shift;return$self->{meta}unless @_;$self->{meta}=shift;return$self}sub has_meta {return scalar %{shift->meta}? 1 : 0}sub config {my$self=shift;return$self->{config}unless @_;$self->{config}=shift;return$self}sub merge {my$self=shift;return$self->{merge}unless @_;$self->{merge}=shift;return$self}sub switches {my$self=shift;return$self->{switches}unless @_;$self->{switches}=shift;return$self}sub test_args {my$self=shift;return$self->{test_args}unless @_;$self->{test_args}=shift;return$self}sub assemble_meta {my ($self)=@_;return$self->meta if$self->has_meta;my$meta=$self->meta;my$raw=$self->raw;$meta->{is_object}=UNIVERSAL::isa($raw,'UNIVERSAL')? 1 : 0;if ($meta->{is_object}){$meta->{class}=ref($raw)}else {my$ref=lc(ref($raw));$meta->{"is_$ref"}=1}if ($meta->{is_scalar}){my$source=$$raw;$meta->{length}=length($$raw);$meta->{has_newlines}=$$raw =~ /\n/ ? 1 : 0;if (!$meta->{has_newlines}and $meta->{length}< 1024){my$file={};$file->{exists}=-e $source ? 1 : 0;if ($file->{exists}){$meta->{file}=$file;$file->{stat}=[stat(_)];$file->{empty}=-z _ ? 1 : 0;$file->{size}=-s _;$file->{text}=-T _ ? 1 : 0;$file->{binary}=-B _ ? 1 : 0;$file->{read}=-r _ ? 1 : 0;$file->{write}=-w _ ? 1 : 0;$file->{execute}=-x _ ? 1 : 0;$file->{setuid}=-u _ ? 1 : 0;$file->{setgid}=-g _ ? 1 : 0;$file->{sticky}=-k _ ? 1 : 0;$meta->{is_file}=$file->{is_file}=-f _ ? 1 : 0;$meta->{is_dir}=$file->{is_dir}=-d _ ? 1 : 0;$meta->{is_symlink}=$file->{is_symlink}=-l $source ? 1 : 0;if ($file->{is_symlink}){$file->{lstat}=[lstat(_)]}($file->{basename},$file->{dir},$file->{ext})=map {defined $_ ? $_ : ''}fileparse($source,qr/\.[^.]*/);$file->{lc_ext}=lc($file->{ext});$file->{basename}.= $file->{ext}if$file->{ext};if (!$file->{is_dir}&& $file->{read}){eval {$file->{shebang}=$self->shebang($$raw)};if (my$e=$@){warn$e}}}}}elsif ($meta->{is_array}){$meta->{size}=$#$raw + 1}elsif ($meta->{is_hash}){}return$meta}{my%shebang_for;sub _read_shebang {my ($class,$file)=@_;open my$fh,'<',$file or die "Can't read $file: $!\n";my$got=read$fh,my ($buf),BLK_SIZE;defined$got or die "I/O error: $!\n";return $1 if$buf =~ /(.*)/;return}sub shebang {my ($class,$file)=@_;$shebang_for{$file}=$class->_read_shebang($file)unless exists$shebang_for{$file};return$shebang_for{$file}}}sub config_for {my ($self,$class)=@_;my ($abbrv_class)=($class =~ /(?:\:\:)?(\w+)$/);my$config=$self->config->{$abbrv_class}|| $self->config->{$class};return$config}1;
TAP_PARSER_SOURCE

$fatpacked{"TAP/Parser/SourceHandler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER';
  package TAP::Parser::SourceHandler;use strict;use warnings;use TAP::Parser::Iterator ();use base 'TAP::Object';our$VERSION='3.35';sub can_handle {my ($class,$args)=@_;$class->_croak("Abstract method 'can_handle' not implemented for $class!");return}sub make_iterator {my ($class,$args)=@_;$class->_croak("Abstract method 'make_iterator' not implemented for $class!");return}1;
TAP_PARSER_SOURCEHANDLER

$fatpacked{"TAP/Parser/SourceHandler/Executable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_EXECUTABLE';
  package TAP::Parser::SourceHandler::Executable;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Process ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.35';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;if ($meta->{is_file}){my$file=$meta->{file};return 0.85 if$file->{execute}&& $file->{binary};return 0.8 if$file->{lc_ext}eq '.bat';return 0.25 if$file->{execute}}elsif ($meta->{is_hash}){return 0.9 if$src->raw->{exec}}return 0}sub make_iterator {my ($class,$source)=@_;my$meta=$source->meta;my@command;if ($meta->{is_hash}){@command=@{$source->raw->{exec}|| []}}elsif ($meta->{is_scalar}){@command=${$source->raw}}elsif ($meta->{is_array}){@command=@{$source->raw}}$class->_croak('No command found in $source->raw!')unless@command;$class->_autoflush(\*STDOUT);$class->_autoflush(\*STDERR);push@command,@{$source->test_args || []};return$class->iterator_class->new({command=>\@command,merge=>$source->merge })}use constant iterator_class=>'TAP::Parser::Iterator::Process';sub _autoflush {my ($class,$flushed)=@_;my$old_fh=select$flushed;$|=1;select$old_fh}1;
TAP_PARSER_SOURCEHANDLER_EXECUTABLE

$fatpacked{"TAP/Parser/SourceHandler/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_FILE';
  package TAP::Parser::SourceHandler::File;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Stream ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.35';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;my$config=$src->config_for($class);return 0 unless$meta->{is_file};my$file=$meta->{file};return 0.9 if$file->{lc_ext}eq '.tap';if (my$exts=$config->{extensions}){return 0.9 if grep {lc($_)eq $file->{lc_ext}}@$exts}return 0}sub make_iterator {my ($class,$source)=@_;$class->_croak('$source->raw must be a scalar ref')unless$source->meta->{is_scalar};my$file=${$source->raw};my$fh;open($fh,'<',$file)or $class->_croak("error opening TAP source file '$file': $!");return$class->iterator_class->new($fh)}use constant iterator_class=>'TAP::Parser::Iterator::Stream';1;
TAP_PARSER_SOURCEHANDLER_FILE

$fatpacked{"TAP/Parser/SourceHandler/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_HANDLE';
  package TAP::Parser::SourceHandler::Handle;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Stream ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.35';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;return 0.9 if$meta->{is_object}&& UNIVERSAL::isa($src->raw,'IO::Handle');return 0.8 if$meta->{is_glob};return 0}sub make_iterator {my ($class,$source)=@_;$class->_croak('$source->raw must be a glob ref or an IO::Handle')unless$source->meta->{is_glob}|| UNIVERSAL::isa($source->raw,'IO::Handle');return$class->iterator_class->new($source->raw)}use constant iterator_class=>'TAP::Parser::Iterator::Stream';1;
TAP_PARSER_SOURCEHANDLER_HANDLE

$fatpacked{"TAP/Parser/SourceHandler/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_PERL';
  package TAP::Parser::SourceHandler::Perl;use strict;use warnings;use Config;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>($^O eq 'VMS');use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Process ();use Text::ParseWords qw(shellwords);use base 'TAP::Parser::SourceHandler::Executable';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.35';sub can_handle {my ($class,$source)=@_;my$meta=$source->meta;return 0 unless$meta->{is_file};my$file=$meta->{file};if (my$shebang=$file->{shebang}){return 0.9 if$shebang =~ /^#!.*\bperl/;return 0.3}return 0.8 if$file->{lc_ext}eq '.t';return 0.9 if$file->{lc_ext}eq '.pl';return 0.75 if$file->{dir}=~ /^t\b/;return 0.25}sub _autoflush_stdhandles {my ($class)=@_;$class->_autoflush(\*STDOUT);$class->_autoflush(\*STDERR)}sub make_iterator {my ($class,$source)=@_;my$meta=$source->meta;my$perl_script=${$source->raw};$class->_croak("Cannot find ($perl_script)")unless$meta->{is_file};$class->_autoflush_stdhandles;my ($libs,$switches)=$class->_mangle_switches($class->_filter_libs($class->_switches($source)));$class->_run($source,$libs,$switches)}sub _has_taint_switch {my($class,$switches)=@_;my$has_taint=grep {$_ eq "-T" || $_ eq "-t"}@{$switches};return$has_taint ? 1 : 0}sub _mangle_switches {my ($class,$libs,$switches)=@_;if ($class->_has_taint_switch($switches)){my@perl5lib=defined$ENV{PERL5LIB}? split /$Config{path_sep}/,$ENV{PERL5LIB}: ();return ($libs,[@{$switches},$class->_libs2switches([@$libs,@perl5lib]),defined$ENV{PERL5OPT}? shellwords($ENV{PERL5OPT}): ()],)}return ($libs,$switches)}sub _filter_libs {my ($class,@switches)=@_;my$path_sep=$Config{path_sep};my$path_re=qr{$path_sep};my@libs;my@filtered_switches;for (@switches){if (!/$path_re/ && m/ ^ ['"]? -I ['"]? (.*?) ['"]? $ /x){push@libs,$1}else {push@filtered_switches,$_}}return \@libs,\@filtered_switches}sub _iterator_hooks {my ($class,$source,$libs,$switches)=@_;my$setup=sub {if (@{$libs}and!$class->_has_taint_switch($switches)){$ENV{PERL5LIB}=join($Config{path_sep},grep {defined}@{$libs},$ENV{PERL5LIB})}};my$previous=$ENV{PERL5LIB};my$teardown=sub {if (defined$previous){$ENV{PERL5LIB}=$previous}else {delete$ENV{PERL5LIB}}};return ($setup,$teardown)}sub _run {my ($class,$source,$libs,$switches)=@_;my@command=$class->_get_command_for_switches($source,$switches)or $class->_croak("No command found!");my ($setup,$teardown)=$class->_iterator_hooks($source,$libs,$switches);return$class->_create_iterator($source,\@command,$setup,$teardown)}sub _create_iterator {my ($class,$source,$command,$setup,$teardown)=@_;return TAP::Parser::Iterator::Process->new({command=>$command,merge=>$source->merge,setup=>$setup,teardown=>$teardown,})}sub _get_command_for_switches {my ($class,$source,$switches)=@_;my$file=${$source->raw};my@args=@{$source->test_args || []};my$command=$class->get_perl;my@command=($command,@{$switches},$file,@args);return@command}sub _libs2switches {my$class=shift;return map {"-I$_"}grep {$_}@{$_[0]}}sub get_taint {my ($class,$shebang)=@_;return unless defined$shebang && $shebang =~ /^#!.*\bperl.*\s-\w*([Tt]+)/;return $1}sub _switches {my ($class,$source)=@_;my$file=${$source->raw};my@switches=@{$source->switches || []};my$shebang=$source->meta->{file}->{shebang};return unless defined$shebang;my$taint=$class->get_taint($shebang);push@switches,"-$taint" if defined$taint;if (IS_VMS){for (@switches){$_=qq["$_"]}}return@switches}sub get_perl {my$class=shift;return$ENV{HARNESS_PERL}if defined$ENV{HARNESS_PERL};return qq["$^X"] if IS_WIN32 && ($^X =~ /[^\w\.\/\\]/);return $^X}1;
TAP_PARSER_SOURCEHANDLER_PERL

$fatpacked{"TAP/Parser/SourceHandler/RawTAP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_SOURCEHANDLER_RAWTAP';
  package TAP::Parser::SourceHandler::RawTAP;use strict;use warnings;use TAP::Parser::IteratorFactory ();use TAP::Parser::Iterator::Array ();use base 'TAP::Parser::SourceHandler';TAP::Parser::IteratorFactory->register_handler(__PACKAGE__);our$VERSION='3.35';sub can_handle {my ($class,$src)=@_;my$meta=$src->meta;return 0 if$meta->{file};if ($meta->{is_scalar}){return 0 unless$meta->{has_newlines};return 0.9 if ${$src->raw}=~ /\d\.\.\d/;return 0.7 if ${$src->raw}=~ /ok/;return 0.3}elsif ($meta->{is_array}){return 0.5}return 0}sub make_iterator {my ($class,$src)=@_;my$meta=$src->meta;my$tap_array;if ($meta->{is_scalar}){$tap_array=[split "\n"=>${$src->raw}]}elsif ($meta->{is_array}){$tap_array=$src->raw}$class->_croak('No raw TAP found in $source->raw')unless scalar$tap_array;return TAP::Parser::Iterator::Array->new($tap_array)}1;
TAP_PARSER_SOURCEHANDLER_RAWTAP

$fatpacked{"TAP/Parser/YAMLish/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_READER';
  package TAP::Parser::YAMLish::Reader;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.35';my%UNESCAPES=(z=>"\x00",a=>"\x07",t=>"\x09",n=>"\x0a",v=>"\x0b",f=>"\x0c",r=>"\x0d",e=>"\x1b",'\\'=>'\\',);my$QQ_STRING=qr{ " (?:\\. | [^"])* " }x;my$HASH_LINE=qr{ ^ ($QQ_STRING|\S+) \s* : \s* (?: (.+?) \s* )? $ }x;my$IS_HASH_KEY=qr{ ^ [\w\'\"] }x;my$IS_END_YAML=qr{ ^ \.\.\. \s* $ }x;my$IS_QQ_STRING=qr{ ^ $QQ_STRING $ }x;sub read {my$self=shift;my$obj=shift;die "Must have a code reference to read input from" unless ref$obj eq 'CODE';$self->{reader}=$obj;$self->{capture}=[];$self->_next;return unless$self->{next};my$doc=$self->_read;my$dots=$self->_peek;die "Missing '...' at end of YAMLish" unless defined$dots and $dots =~ $IS_END_YAML;delete$self->{reader};delete$self->{next};return$doc}sub get_raw {join("\n",grep defined,@{shift->{capture}|| []})."\n"}sub _peek {my$self=shift;return$self->{next}unless wantarray;my$line=$self->{next};$line =~ /^ (\s*) (.*) $ /x;return ($2,length $1)}sub _next {my$self=shift;die "_next called with no reader" unless$self->{reader};my$line=$self->{reader}->();$self->{next}=$line;push @{$self->{capture}},$line}sub _read {my$self=shift;my$line=$self->_peek;if ($line =~ /^ --- (?: \s* (.+?) \s* )? $/x){$self->_next;return$self->_read_scalar($1)if defined $1;my ($next,$indent)=$self->_peek;if ($next =~ /^ - /x){return$self->_read_array($indent)}elsif ($next =~ $IS_HASH_KEY){return$self->_read_hash($next,$indent)}elsif ($next =~ $IS_END_YAML){die "Premature end of YAMLish"}else {die "Unsupported YAMLish syntax: '$next'"}}else {die "YAMLish document header not found"}}sub _read_qq {my$self=shift;my$str=shift;unless ($str =~ s/^ " (.*?) " $/$1/x){die "Internal: not a quoted string"}$str =~ s/\\"/"/gx;$str =~ s/ \\ ( [tartan\\favez] | x([0-9a-fA-F]{2}) ) 
                   / (length($1) > 1) ? pack("H2", $2) : $UNESCAPES{$1} /gex;return$str}sub _read_scalar {my$self=shift;my$string=shift;return undef if$string eq '~';return {}if$string eq '{}';return []if$string eq '[]';if ($string eq '>' || $string eq '|'){my ($line,$indent)=$self->_peek;die "Multi-line scalar content missing" unless defined$line;my@multiline=($line);while (1){$self->_next;my ($next,$ind)=$self->_peek;last if$ind < $indent;my$pad=$string eq '|' ? (' ' x ($ind - $indent)): '';push@multiline,$pad .$next}return join(($string eq '>' ? ' ' : "\n"),@multiline)."\n"}if ($string =~ /^ ' (.*) ' $/x){(my$rv=$1)=~ s/''/'/g;return$rv}if ($string =~ $IS_QQ_STRING){return$self->_read_qq($string)}if ($string =~ /^['"]/){die __PACKAGE__ ." does not support multi-line quoted scalars"}return$string}sub _read_nested {my$self=shift;my ($line,$indent)=$self->_peek;if ($line =~ /^ -/x){return$self->_read_array($indent)}elsif ($line =~ $IS_HASH_KEY){return$self->_read_hash($line,$indent)}else {die "Unsupported YAMLish syntax: '$line'"}}sub _read_array {my ($self,$limit)=@_;my$ar=[];while (1){my ($line,$indent)=$self->_peek;last if$indent < $limit ||!defined$line || $line =~ $IS_END_YAML;if ($indent > $limit){die "Array line over-indented"}if ($line =~ /^ (- \s+) \S+ \s* : (?: \s+ | $ ) /x){$indent += length $1;$line =~ s/-\s+//;push @$ar,$self->_read_hash($line,$indent)}elsif ($line =~ /^ - \s* (.+?) \s* $/x){die "Unexpected start of YAMLish" if$line =~ /^---/;$self->_next;push @$ar,$self->_read_scalar($1)}elsif ($line =~ /^ - \s* $/x){$self->_next;push @$ar,$self->_read_nested}elsif ($line =~ $IS_HASH_KEY){$self->_next;push @$ar,$self->_read_hash($line,$indent,)}else {die "Unsupported YAMLish syntax: '$line'"}}return$ar}sub _read_hash {my ($self,$line,$limit)=@_;my$indent;my$hash={};while (1){die "Badly formed hash line: '$line'" unless$line =~ $HASH_LINE;my ($key,$value)=($self->_read_scalar($1),$2);$self->_next;if (defined$value){$hash->{$key}=$self->_read_scalar($value)}else {$hash->{$key}=$self->_read_nested}($line,$indent)=$self->_peek;last if$indent < $limit ||!defined$line || $line =~ $IS_END_YAML}return$hash}1;
TAP_PARSER_YAMLISH_READER

$fatpacked{"TAP/Parser/YAMLish/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TAP_PARSER_YAMLISH_WRITER';
  package TAP::Parser::YAMLish::Writer;use strict;use warnings;use base 'TAP::Object';our$VERSION='3.35';my$ESCAPE_CHAR=qr{ [ \x00-\x1f \" ] }x;my$ESCAPE_KEY=qr{ (?: ^\W ) | $ESCAPE_CHAR }x;my@UNPRINTABLE=qw(z x01 x02 x03 x04 x05 x06 a x08 t n v f r x0e x0f x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x1a e x1c x1d x1e x1f);sub write {my$self=shift;die "Need something to write" unless @_;my$obj=shift;my$out=shift || \*STDOUT;die "Need a reference to something I can write to" unless ref$out;$self->{writer}=$self->_make_writer($out);$self->_write_obj('---',$obj);$self->_put('...');delete$self->{writer}}sub _make_writer {my$self=shift;my$out=shift;my$ref=ref$out;if ('CODE' eq $ref){return$out}elsif ('ARRAY' eq $ref){return sub {push @$out,shift}}elsif ('SCALAR' eq $ref){return sub {$$out .= shift()."\n"}}elsif ('GLOB' eq $ref || 'IO::Handle' eq $ref){return sub {print$out shift(),"\n"}}die "Can't write to $out"}sub _put {my$self=shift;$self->{writer}->(join '',@_)}sub _enc_scalar {my$self=shift;my$val=shift;my$rule=shift;return '~' unless defined$val;if ($val =~ /$rule/){$val =~ s/\\/\\\\/g;$val =~ s/"/\\"/g;$val =~ s/ ( [\x00-\x1f] ) / '\\' . $UNPRINTABLE[ ord($1) ] /gex;return qq{"$val"}}if (length($val)==0 or $val =~ /\s/){$val =~ s/'/''/;return "'$val'"}return$val}sub _write_obj {my$self=shift;my$prefix=shift;my$obj=shift;my$indent=shift || 0;if (my$ref=ref$obj){my$pad='  ' x $indent;if ('HASH' eq $ref){if (keys %$obj){$self->_put($prefix);for my$key (sort keys %$obj){my$value=$obj->{$key};$self->_write_obj($pad .$self->_enc_scalar($key,$ESCAPE_KEY).':',$value,$indent + 1)}}else {$self->_put($prefix,' {}')}}elsif ('ARRAY' eq $ref){if (@$obj){$self->_put($prefix);for my$value (@$obj){$self->_write_obj($pad .'-',$value,$indent + 1)}}else {$self->_put($prefix,' []')}}else {die "Don't know how to encode $ref"}}else {$self->_put($prefix,' ',$self->_enc_scalar($obj,$ESCAPE_CHAR))}}1;
TAP_PARSER_YAMLISH_WRITER

$fatpacked{"Test/Harness.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_HARNESS';
  package Test::Harness;use 5.006;use strict;use warnings;use constant IS_WIN32=>($^O =~ /^(MS)?Win32$/);use constant IS_VMS=>($^O eq 'VMS');use TAP::Harness ();use TAP::Parser::Aggregator ();use TAP::Parser::Source ();use TAP::Parser::SourceHandler::Perl ();use Text::ParseWords qw(shellwords);use Config;use base 'Exporter';BEGIN {eval q{use Time::HiRes 'time'};our$has_time_hires=!$@}our$VERSION='3.35';*verbose=*Verbose;*switches=*Switches;*debug=*Debug;$ENV{HARNESS_ACTIVE}=1;$ENV{HARNESS_VERSION}=$VERSION;END {delete$ENV{HARNESS_ACTIVE};delete$ENV{HARNESS_VERSION}}our@EXPORT=qw(&runtests);our@EXPORT_OK=qw(&execute_tests $verbose $switches);our$Verbose=$ENV{HARNESS_VERBOSE}|| 0;our$Debug=$ENV{HARNESS_DEBUG}|| 0;our$Switches='-w';our$Columns=$ENV{HARNESS_COLUMNS}|| $ENV{COLUMNS}|| 80;$Columns--;our$Timer=$ENV{HARNESS_TIMER}|| 0;our$Color=$ENV{HARNESS_COLOR}|| 0;our$IgnoreExit=$ENV{HARNESS_IGNORE_EXIT}|| 0;sub _has_taint {my$test=shift;return TAP::Parser::SourceHandler::Perl->get_taint(TAP::Parser::Source->shebang($test))}sub _aggregate {my ($harness,$aggregate,@tests)=@_;local$ENV{HARNESS_OPTIONS};_apply_extra_INC($harness);_aggregate_tests($harness,$aggregate,@tests)}sub _apply_extra_INC {my$harness=shift;$harness->callback(parser_args=>sub {my ($args,$test)=@_;push @{$args->{switches}},map {"-I$_"}_filtered_inc()})}sub _aggregate_tests {my ($harness,$aggregate,@tests)=@_;$aggregate->start();$harness->aggregate_tests($aggregate,@tests);$aggregate->stop()}sub runtests {my@tests=@_;local ($\,$,);my$harness=_new_harness();my$aggregate=TAP::Parser::Aggregator->new();_aggregate($harness,$aggregate,@tests);$harness->formatter->summary($aggregate);my$total=$aggregate->total;my$passed=$aggregate->passed;my$failed=$aggregate->failed;my@parsers=$aggregate->parsers;my$num_bad=0;for my$parser (@parsers){$num_bad++ if$parser->has_problems}die(sprintf("Failed %d/%d test programs. %d/%d subtests failed.\n",$num_bad,scalar@parsers,$failed,$total))if$num_bad;return$total && $total==$passed}sub _canon {my@list=sort {$a <=> $b}@_;my@ranges=();my$count=scalar@list;my$pos=0;while ($pos < $count){my$end=$pos + 1;$end++ while$end < $count && $list[$end]<= $list[$end - 1 ]+ 1;push@ranges,($end==$pos + 1)? $list[$pos]: join('-',$list[$pos],$list[$end - 1 ]);$pos=$end}return join(' ',@ranges)}sub _new_harness {my$sub_args=shift || {};my (@lib,@switches);my@opt=map {shellwords($_)}grep {defined}$Switches,$ENV{HARNESS_PERL_SWITCHES};while (my$opt=shift@opt){if ($opt =~ /^ -I (.*) $ /x){push@lib,length($1)? $1 : shift@opt}else {push@switches,$opt}}push@lib,_filtered_inc()if IS_VMS;my$verbosity=($Verbose ? ($Verbose !~ /\d/)? 1 : $Verbose : 0);my$args={timer=>$Timer,directives=>our$Directives,lib=>\@lib,switches=>\@switches,color=>$Color,verbosity=>$verbosity,ignore_exit=>$IgnoreExit,};$args->{stdout}=$sub_args->{out}if exists$sub_args->{out};my$class=$ENV{HARNESS_SUBCLASS}|| 'TAP::Harness';if (defined(my$env_opt=$ENV{HARNESS_OPTIONS})){for my$opt (split /:/,$env_opt){if ($opt =~ /^j(\d*)$/){$args->{jobs}=$1 || 9}elsif ($opt eq 'c'){$args->{color}=1}elsif ($opt =~ m/^f(.*)$/){my$fmt=$1;$fmt =~ s/-/::/g;$args->{formatter_class}=$fmt}elsif ($opt =~ m/^a(.*)$/){my$archive=$1;$class="TAP::Harness::Archive";$args->{archive}=$archive}else {die "Unknown HARNESS_OPTIONS item: $opt\n"}}}return TAP::Harness->_construct($class,$args)}sub _filtered_inc {my@inc=grep {!ref}@INC;if (IS_VMS){@inc=grep!/perl_root/i,@inc}elsif (IS_WIN32){s/[\\\/]+$// for@inc}my@default_inc=_default_inc();my@new_inc;my%seen;for my$dir (@inc){next if$seen{$dir}++;if ($dir eq ($default_inc[0]|| '')){shift@default_inc}else {push@new_inc,$dir}shift@default_inc while@default_inc and $seen{$default_inc[0]}}return@new_inc}{my@inc;sub _default_inc {return@inc if@inc;local$ENV{PERL5LIB};local$ENV{PERLLIB};my$perl=$ENV{HARNESS_PERL}|| $^X;chomp(@inc=`"$perl" -e "print join qq[\\n], \@INC, q[]"`);return@inc}}sub _check_sequence {my@list=@_;my$prev;while (my$next=shift@list){return if defined$prev && $next <= $prev;$prev=$next}return 1}sub execute_tests {my%args=@_;my$harness=_new_harness(\%args);my$aggregate=TAP::Parser::Aggregator->new();my%tot=(bonus=>0,max=>0,ok=>0,bad=>0,good=>0,files=>0,tests=>0,sub_skipped=>0,todo=>0,skipped=>0,bench=>undef,);$harness->callback(made_parser=>sub {my$parser=shift;$parser->callback(plan=>sub {my$plan=shift;if ($plan->directive eq 'SKIP'){$tot{skipped}++}})});_aggregate($harness,$aggregate,@{$args{tests}});$tot{bench}=$aggregate->elapsed;my@tests=$aggregate->descriptions;$tot{files}=$tot{tests}=scalar@tests;my%failedtests=();my%todo_passed=();for my$test (@tests){my ($parser)=$aggregate->parsers($test);my@failed=$parser->failed;my$wstat=$parser->wait;my$estat=$parser->exit;my$planned=$parser->tests_planned;my@errors=$parser->parse_errors;my$passed=$parser->passed;my$actual_passed=$parser->actual_passed;my$ok_seq=_check_sequence($parser->actual_passed);$estat ||= '' unless$wstat;$wstat ||= '';$tot{max}+= ($planned || 0);$tot{bonus}+= $parser->todo_passed;$tot{ok}+= $passed > $actual_passed ? $passed : $actual_passed;$tot{sub_skipped}+= $parser->skipped;$tot{todo}+= $parser->todo;if (@failed || $estat || @errors){$tot{bad}++;my$huh_planned=$planned ? undef : '??';my$huh_errors=$ok_seq ? undef : '??';$failedtests{$test}={'canon'=>$huh_planned || $huh_errors || _canon(@failed)|| '??','estat'=>$estat,'failed'=>$huh_planned || $huh_errors || scalar@failed,'max'=>$huh_planned || $planned,'name'=>$test,'wstat'=>$wstat }}else {$tot{good}++}my@todo=$parser->todo_passed;if (@todo){$todo_passed{$test}={'canon'=>_canon(@todo),'estat'=>$estat,'failed'=>scalar@todo,'max'=>scalar$parser->todo,'name'=>$test,'wstat'=>$wstat }}}return (\%tot,\%failedtests,\%todo_passed)}1;
TEST_HARNESS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use App::stew::util qw(error);
use App::stew::cmd::install;
use App::stew::cmd::build;
use App::stew::cmd::list_installed;
use App::stew::cmd::uninstall;
use App::stew::cmd::exec;

my $command = shift @ARGV;

if (!$command) {
}
elsif ($command eq 'install') {
    App::stew::cmd::install->new()->run(@ARGV);
}
elsif ($command eq 'build') {
    App::stew::cmd::build->new()->run(@ARGV);
}
elsif ($command eq 'list-installed') {
    App::stew::cmd::list_installed->new()->run(@ARGV);
}
elsif ($command eq 'uninstall') {
    App::stew::cmd::uninstall->new()->run(@ARGV);
}
elsif ($command eq 'exec') {
    App::stew::cmd::exec->new()->run(@ARGV);
}
else {
    error qq{Unknown command '$command'};
}
