#!/usr/bin/env perl

use strict;
use warnings;

use Cwd qw(abs_path);
use File::Path qw(mkpath rmtree);
use Getopt::Long;
use HTTP::Tiny;

my $opt_prefix;
my $opt_repo;
my $opt_os;
my $opt_arch;
my $opt_build;
my $opt_dry_run;
my $opt_keep_downloads;
my $opt_verbose;
GetOptions(
    "prefix=s"       => \$opt_prefix,
    "repo=s"         => \$opt_repo,
    "os=s"           => \$opt_os,
    "arch=s"         => \$opt_arch,
    "build=s"        => \$opt_build,
    "dry-run"        => \$opt_dry_run,
    "keep-downloads" => \$opt_keep_downloads,
    "verbose"        => \$opt_verbose,
) or die("Error in command line arguments\n");

die "--prefix is required\n" unless $opt_prefix;
die "--repo is required\n"   unless $opt_repo;
die "--build is required\n"  unless $opt_build;
die "--os is required\n"     unless $opt_os;
die "--arch is required\n"   unless $opt_arch;

my ($file) = @ARGV ? @ARGV : 'stewfile';
die "Usage: [options] <stewfile>\n" unless $file && -f $file;

my $build_dir      = abs_path($opt_build);
my $cache_dir      = "$build_dir/.cache";
my $stew_cache_dir = "$cache_dir/stew";
my $dist_cache_dir = "$cache_dir/dist";
rmtree($cache_dir) unless $opt_keep_downloads;
mkpath($cache_dir);
mkpath($stew_cache_dir);
mkpath($dist_cache_dir);
mkpath($opt_prefix);

my $log_file = "$build_dir/stew.log";

_log("Parsing '$file'");

my @stew_files = map { "$_.stew" } grep { !/^#/ && length } split /\r?\n/,
  _slurp($file);

_log(sprintf 'Found %d packages', scalar @stew_files);

my @stew_pkgs;
foreach my $stew_file (@stew_files) {
    push @stew_pkgs, _get_stew($stew_file);
}

foreach my $stew_pkg (@stew_pkgs) {
    _build_stew($stew_pkg);
}

_log("Done");

sub _get_stew {
    my ($stew_file) = @_;

    if (!-e "$stew_cache_dir/$stew_file") {
        _log("Getting stew '$stew_file' from repository...");

        _get_file_from_repo("$opt_repo/stew/$stew_file",
            "$stew_cache_dir/$stew_file");
        die "Cannot get stew '$stew_file' from repository\n"
          unless -e "$stew_cache_dir/$stew_file";
    }

    my $stew = _parse_stew($stew_file);

    my @stews;
    push @stews, $stew;

    my @depends = $stew->depends;
    foreach my $depends (@depends) {
        unshift @stews, _get_stew("$depends.stew");
    }

    return @stews;
}

sub _parse_stew {
    my ($stew_file) = @_;

    my $content = _slurp("$stew_cache_dir/$stew_file");

    my $stew_class = _sandbox($file, $content);
    return $stew_class->new;
}

sub _build_stew {
    my ($stew) = @_;

    my $stew_dist  = join '-', $stew->name, $stew->version;
    my $stew_name  = $stew->name;
    my $stew_file  = $stew->file;
    my $stew_build = $stew_dist . '-dist.tar.gz';

    _log("Building and installing '$stew_dist'...");

    _log("Checking if repo has cached file...");
    if (!-e "$dist_cache_dir/$stew_build") {
        _get_file_from_repo("$opt_repo/cache/$opt_os/$opt_arch/$stew_build",
            "$dist_cache_dir/$stew_build");
    }

    if (-e "$dist_cache_dir/$stew_build") {
        _log("Using cached file");

        _system("tar xzf '$dist_cache_dir/$stew_build' -C $opt_prefix");
    }
    else {
        my $work_dir = "$build_dir/" . $stew->name;
        mkpath($work_dir);

        _symlink_depends($stew, $work_dir);

        _get_file_from_repo("$opt_repo/src/$stew_file", "$work_dir/$stew_file");
        die "file '$stew_file' not found in repository\n"
          unless -e "$work_dir/$stew_file";

        local $ENV{PREFIX} = $opt_prefix;

        chdir $work_dir;
        _prepare($stew);

        chdir $work_dir;
        _build($stew);

        _system("mv $opt_prefix $opt_prefix.prev") if -d $opt_prefix;

        chdir $work_dir;
        _install($stew);

        _postinstall($stew);

        if (!-e "$dist_cache_dir/$stew_build") {
            _log("    > CACHING");

            _system("cd $opt_prefix", "tar czf $stew_build *");
            _system("cd $opt_prefix", "mv $stew_build $dist_cache_dir/");

            mkpath("$dist_cache_dir/new/$opt_os/$opt_arch/");
            _system(
"ln -s $dist_cache_dir/$stew_build $dist_cache_dir/new/$opt_os/$opt_arch/"
            );
        }

        if (-d "$opt_prefix.prev") {
            _system("cp -R $opt_prefix/* $opt_prefix.prev/");
            _system("rm -rf $opt_prefix");

            _system("mv $opt_prefix.prev $opt_prefix");
        }
    }

    _log("Done building '$stew_dist'");
}

sub _symlink_depends {
    my ($stew, $work_dir) = @_;

    my @depends = $stew->depends;
    foreach my $depend (@depends) {
        _symlink_depend($depend, $work_dir);
    }
}

sub _symlink_depend {
    my ($depend, $work_dir) = @_;

    my ($stew) = grep { $_->name . '-' . $_->version eq $depend } @stew_pkgs;

    if ($stew) {
        _system(sprintf "ln -s $build_dir/%s/%s $work_dir",
            $stew->name, $stew->name . '-' . $stew->version);

        if ($stew->depends) {
            _symlink_depends($stew);
        }
    }
    else {
        die "Cannot find dependency '$depend'\n";
    }
}

sub _get_file_from_repo {
    my ($in, $out) = @_;

    if ($in =~ m/^http/) {
        HTTP::Tiny->new->mirror($in, $out);
    }
    else {
        if (-e $in) {
            system("cp $in $out");
        }
    }
}

sub _prepare {
    my ($stew) = @_;

    _log("    > PREPARE");

    my @commands = $stew->prepare;
    _system(@commands);
}

sub _build {
    my ($stew) = @_;

    _log("    > BUILD");

    my @commands = $stew->build;
    _system(@commands);
}

sub _install {
    my ($stew) = @_;

    _log("    > INSTALL");

    my @commands = $stew->install;
    _system(@commands);
}

sub _postinstall {
    my ($stew) = @_;

    _log("    > POST-INSTALL");

    my @commands = $stew->postinstall;
    _system(@commands);
}

sub _log {
    print STDERR @_, "\n";

    open my $fh, '>>', $log_file;
    print $fh @_, "\n";
    close $fh;
}

sub _system {
    my $cmd = join ' && ', @_;

    my $redirect = $opt_verbose ? '' : '> /dev/null';
    $cmd = "sh -c \"$cmd\" 2>&1 | tee -a $log_file $redirect";

    _log($cmd);
    system($cmd) unless $opt_dry_run;
}

sub _slurp {
    my ($file) = @_;

    local $/;
    open my $fh, '<', $file or die $!;
    return <$fh>;
}

sub _rand_str {
    my @alpha = ('0' .. '9', 'a' .. 'z', 'A' .. 'Z');
    my $str = '';

    $str .= $alpha[rand($#alpha)] for 1 .. 16;

    return $str;
}

sub _sandbox {
    my ($file, $content, $work_dir) = @_;

    my $class_name = 'stew::_build_' . _rand_str();

    my $package = <<"EOP";
    package $class_name;
    use strict;
    use warnings;
    sub new {
        my \$class = shift;

        my \$self = {};
        bless \$self, \$class;

        return \$self;
    }
    $content
    sub name    { \$name }
    sub version { \$version }
    sub file    { \$file }
    sub depends { \@depends }
    1;
EOP

    eval $package or die "Error compiling '$file': $@\n";

    return $class_name;
}
