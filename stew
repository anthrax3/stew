#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/stew.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW';
  package App::stew;
  use 5.008001;
  use strict;
  use warnings;
  
  our $VERSION = "0.01";
  
  
  
  1;
  __END__
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::stew - stew your binaries!
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Viacheslav Tykhanovskyi, C<vti@cpan.org>.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2015, Viacheslav Tykhanovskyi.
  
  This program is free software, you can redistribute it and/or modify it under
  the same terms as Perl 5.10.
  
  =cut
APP_STEW

$fatpacked{"App/stew/builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_BUILDER';
  package App::stew::builder;
  
  use strict;
  use warnings;
  
  use Cwd qw(abs_path getcwd);
  use Carp qw(croak);
  use File::Path qw(rmtree);
  use File::Basename qw(basename dirname);
  use App::stew::util
    qw(cmd info debug error _chdir _mkpath _copy _unlink _tree _tree_diff);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{root_dir}  = $params{root_dir};
      $self->{build_dir} = $params{build_dir};
      $self->{cache}     = $params{cache};
      $self->{snapshot}  = $params{snapshot};
  
      return $self;
  }
  
  sub build {
      my $self = shift;
      my ($stew) = @_;
  
      if ($self->{snapshot}->is_installed($stew)) {
          info sprintf "'%s' is up to date", $stew->package;
          return;
      }
  
      croak '$ENV{PREFIX} not defined' unless $ENV{PREFIX};
  
      _mkpath($ENV{PREFIX});
  
      info sprintf "Building & installing '%s'...", $stew->package;
  
      my $work_dir = File::Spec->catfile($self->{build_dir}, $stew->package);
  
      my $cwd = getcwd();
      my $tree = [];
      eval {
          _mkpath($work_dir);
          _chdir($work_dir);
  
          info sprintf "Resolving dependencies...", $stew->package;
          $self->_resolve_dependencies($stew);
  
          my $dist_path = $self->{cache}->get_dist_filepath($stew);
  
          $self->_build_from_source($stew) unless -f $dist_path;
  
          $tree = $self->_install_from_binary($stew, $dist_path);
  
          _chdir($cwd);
      } or do {
          my $e = $@;
  
          _chdir($cwd);
  
          die $e;
      };
  
      info sprintf "Done installing '%s'", $stew->package;
      $self->{snapshot}->mark_installed($stew, $tree);
  
      return $self;
  }
  
  sub _install_from_binary {
      my $self = shift;
      my ($stew, $dist_path) = @_;
  
      info sprintf "Installing '%s' from binaries...", $stew->package;
  
      my $basename = basename $dist_path;
  
      my $work_dir = File::Spec->catfile($self->{build_dir}, $stew->package);
      _chdir $work_dir;
  
      _copy($dist_path, "$basename");
      cmd("tar xzf $basename");
      _chdir($stew->package . '-dist');
  
      my $local_prefix = $ENV{PREFIX};
      $local_prefix =~ s{^/+}{};
      cmd("cp --remove-destination -ra $local_prefix/* $ENV{PREFIX}/");
  
      return _tree(".");
  }
  
  sub _build_from_source {
      my $self = shift;
      my ($stew) = @_;
  
      info sprintf "Preparing '%s'...", $stew->package;
      $self->_prepare($stew);
  
      info sprintf "Building '%s'...", $stew->package;
      $self->_build($stew);
  
      _mkpath($ENV{PREFIX});
  
      my $work_dir = File::Spec->catfile($self->{build_dir}, $stew->package);
      _chdir($work_dir);
  
      my $dist_name = sprintf '%s-dist', $stew->package;
      _mkpath $dist_name;
      $ENV{DESTDIR} = abs_path($dist_name);
  
      info sprintf "Installing '%s'...", $stew->package;
      $self->_install($stew);
  
      my $dist_archive = "$dist_name.tar.gz";
      cmd("tar czhf $dist_archive $dist_name");
  
      info sprintf "Caching '%s' as '$dist_archive'...", $stew->package;
      $self->{cache}->cache_dist("$dist_archive");
  
      return $self;
  }
  
  sub _prepare {
      my $self = shift;
      my ($stew) = @_;
  
      my $work_dir = File::Spec->catfile($self->{build_dir}, $stew->package);
      _mkpath $work_dir;
      _chdir($work_dir);
  
      my $src_file = $self->{cache}->get_src_filepath($stew);
  
      _copy($src_file, $work_dir)
        or error("Copy '$src_file' to '$work_dir' failed: $!");
  
      my @commands = $stew->run('prepare');
      cmd(@commands);
  }
  
  sub _build {
      my $self = shift;
      my ($stew) = @_;
  
      my $work_dir = File::Spec->catfile($self->{build_dir}, $stew->package);
      _chdir($work_dir);
  
      my @commands = $stew->run('build');
      cmd(@commands);
  }
  
  sub _install {
      my $self = shift;
      my ($stew) = @_;
  
      my $work_dir = File::Spec->catfile($self->{build_dir}, $stew->package);
      _chdir($work_dir);
  
      my @commands = $stew->run('install');
      cmd(@commands);
  }
  
  sub _resolve_dependencies {
      my $self = shift;
      my ($stew) = @_;
  
      my $build_dir = $self->{build_dir};
      my $work_dir = File::Spec->catfile($build_dir, $stew->package);
  
      my @makedepends = $stew->makedepends;
      if (@makedepends) {
          info "Found make dependencies: @makedepends";
      }
      foreach my $makedepends (@makedepends) {
          my $stew_file = $self->{cache}->get_stew_filepath($makedepends);
          my $stew      = App::stew::file->parse($stew_file);
  
          _chdir($self->{root_dir});
  
          info sprintf "Preparing make dependency '%s'", $stew->package;
          $self->_prepare($stew);
  
          _chdir($self->{root_dir});
  
          my $to = sprintf '%s/%s', $work_dir, $stew->package;
          if (!-e $to) {
              cmd(sprintf "ln -s $build_dir/%s/%s $to",
                  $stew->package, $stew->package);
          }
      }
  
      my @depends = $stew->depends;
      if (@depends) {
          info "Found dependencies: @depends";
      }
      foreach my $depends (@depends) {
          my $stew_file = $self->{cache}->get_stew_filepath($depends);
          my $stew      = App::stew::file->parse($stew_file);
  
          _chdir($self->{root_dir});
  
          $self->build($stew);
  
          _chdir($self->{root_dir});
      }
  }
  
  1;
APP_STEW_BUILDER

$fatpacked{"App/stew/cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CACHE';
  package App::stew::cache;
  
  use strict;
  use warnings;
  
  use File::Spec ();
  use File::Basename qw(dirname basename);
  use App::stew::util qw(error _mkpath _copy);
  use App::stew::file;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{path} = $params{path};
      $self->{repo} = $params{repo};
      $self->{os}   = $params{os};
      $self->{arch} = $params{arch};
  
      return $self;
  }
  
  sub sync_stew {
      my $self = shift;
      my ($name, $type) = @_;
  
      my $stew = $self->_get_stew($name, $type);
  
      $self->_get_src($stew);
      $self->_get_dist($stew);
  
      my @makedepends = $stew->makedepends;
      foreach my $makedepends (@makedepends) {
          $self->sync_stew($makedepends, 'makedepends');
      }
  
      my @depends = $stew->depends;
      foreach my $depends (@depends) {
          $self->sync_stew($depends, 'depends');
      }
  
      return $stew;
  }
  
  sub cache_dist {
      my $self = shift;
      my ($dist_path) = @_;
  
      my $to = File::Spec->catfile($self->{path}, '.cache', 'dist',
          $self->{os}, $self->{arch}, basename($dist_path));
  
      #warn "Caching '$dist_path' to '$to'";
  
      _mkpath dirname $to;
      _copy($dist_path, $to) or error("Can't copy '$dist_path' to '$to': $!");
  
      return $self;
  }
  
  sub get_stew_filepath {
      my $self = shift;
      my ($name) = @_;
  
      return File::Spec->catfile($self->{path}, '.cache', 'stew',
          $name . '.stew');
  }
  
  sub get_src_filepath {
      my $self = shift;
      my ($stew) = @_;
  
      return File::Spec->catfile($self->{path}, '.cache', 'src', $stew->file);
  }
  
  sub get_dist_filepath {
      my $self = shift;
      my ($stew) = @_;
  
      return File::Spec->catfile($self->{path}, '.cache', 'dist',
          $self->{os}, $self->{arch}, $stew->package . '-dist.tar.gz');
  }
  
  sub _get_stew {
      my $self = shift;
      my ($name, $type) = @_;
  
      my $local_path = $self->get_stew_filepath($name);
      #warn "Checking local cache '$local_path'";
      if (!-e $local_path) {
          #warn "Getting from repository '$name'";
          $self->{repo}->mirror_stew($name, $local_path);
      }
  
      die qq{Cannot get stew file for '$name'} unless -e $local_path;
  
      return $self->_parse_stew($local_path, $type);
  }
  
  sub _get_src {
      my $self = shift;
      my ($stew) = @_;
  
      my $local_path = $self->get_src_filepath($stew);
      #warn "Checking local cache '$local_path'";
      if (!-e $local_path) {
          #warn sprintf "Getting from repository '%s'", $stew->file;
          $self->{repo}
            ->mirror_src($self->{os}, $self->{arch}, $stew->file, $local_path);
      }
  
      die sprintf qq{Cannot get source file for '%s'}, $stew->file
        unless -e $local_path;
  
      return;
  }
  
  sub _get_dist {
      my $self = shift;
      my ($stew) = @_;
  
      my $local_path = $self->get_dist_filepath($stew);
      if (!-e $local_path) {
          $self->{repo}->mirror_dist($self->{os}, $self->{arch}, $stew->package,
              $local_path);
      }
  
      return unless -e $local_path;
      return $local_path;
  }
  
  sub _parse_stew {
      my $self = shift;
      my ($file, $type) = @_;
  
      return App::stew::file->parse($file, $type);
  }
  
  1;
APP_STEW_CACHE

$fatpacked{"App/stew/cmd/install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_INSTALL';
  package App::stew::cmd::install;
  
  use strict;
  use warnings;
  
  use Getopt::Long qw(GetOptionsFromArray);
  use Cwd qw(cwd abs_path);
  use File::Path qw(mkpath);
  use File::Spec;
  use App::stew::repo;
  use App::stew::cache;
  use App::stew::builder;
  use App::stew::snapshot;
  use App::stew::env;
  use App::stew::util qw(info debug error);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{argv} = $params{argv};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      my $opt_base;
      my $opt_prefix = 'local';
      my $opt_repo;
      my $opt_os;
      my $opt_arch;
      my $opt_build = 'build';
      my $opt_dry_run;
      my $opt_verbose;
      GetOptionsFromArray(
          $self->{argv},
          "base=s"   => \$opt_base,
          "prefix=s" => \$opt_prefix,
          "repo=s"   => \$opt_repo,
          "os=s"     => \$opt_os,
          "arch=s"   => \$opt_arch,
          "build=s"  => \$opt_build,
          "dry-run"  => \$opt_dry_run,
          "verbose"  => \$opt_verbose,
      ) or die "error";
  
      chomp($opt_os //= `uname -s`);
      $opt_os = lc $opt_os;
      chomp($opt_arch //= `uname -m`);
      $opt_arch = lc $opt_arch;
  
      error("--base is required") unless $opt_base;
      error("--repo is required") unless $opt_repo;
  
      my (@packages) = @ARGV;
  
      my $root_dir  = abs_path(cwd());
      my $build_dir = abs_path($opt_build);
      mkpath($build_dir);
  
      my $repo = App::stew::repo->new(path => $opt_repo);
      my $cache = App::stew::cache->new(
          path => $build_dir,
          repo => $repo,
          os   => $opt_os,
          arch => $opt_arch
      );
      my $snapshot = App::stew::snapshot->new(base => $opt_base);
      $snapshot->load;
      my $builder = App::stew::builder->new(
          root_dir  => $root_dir,
          build_dir => $build_dir,
          cache     => $cache,
          snapshot  => $snapshot
      );
  
      $ENV{STEW_LOG_LEVEL} = $opt_verbose ? 1 : 0;
      $ENV{STEW_LOG_FILE} = "$build_dir/stew.log";
      unlink $ENV{STEW_LOG_FILE};
  
      info "Updating local repository...";
  
      my @stew_pkgs;
      foreach my $package (@packages) {
          push @stew_pkgs, $cache->sync_stew($package);
      }
  
      unless (@stew_pkgs) {
          error "No packages were found";
      }
  
      $ENV{STEW_OS}   = $opt_os;
      $ENV{STEW_ARCH} = $opt_arch;
      $ENV{PREFIX}    = File::Spec->catfile($opt_base, $opt_prefix);
  
      App::stew::env->setup;
  
      foreach my $stew_pkg (@stew_pkgs) {
          $builder->build($stew_pkg);
      }
  
      info "Done";
  }
  
  1;
APP_STEW_CMD_INSTALL

$fatpacked{"App/stew/cmd/list_installed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_LIST_INSTALLED';
  package App::stew::cmd::list_installed;
  
  use strict;
  use warnings;
  
  use Getopt::Long qw(GetOptionsFromArray);
  use App::stew::snapshot;
  use App::stew::util qw(info debug error);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{argv} = $params{argv};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      my $opt_base;
      GetOptionsFromArray($self->{argv}, "base=s" => \$opt_base)
        or die "error";
  
      error("--base is required") unless $opt_base;
  
      my $snapshot = App::stew::snapshot->new(base => $opt_base)->load;
  
      foreach my $key (sort keys %$snapshot) {
          print "$key\n";
      }
  }
  
  1;
APP_STEW_CMD_LIST_INSTALLED

$fatpacked{"App/stew/cmd/uninstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CMD_UNINSTALL';
  package App::stew::cmd::uninstall;
  
  use strict;
  use warnings;
  
  use Getopt::Long qw(GetOptionsFromArray);
  use App::stew::snapshot;
  use App::stew::util qw(info debug error _unlink);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{argv} = $params{argv};
  
      return $self;
  }
  
  sub run {
      my $self = shift;
  
      my $opt_base;
      my $opt_verbose;
      GetOptionsFromArray(
          $self->{argv},
          "base=s"   => \$opt_base,
          "verbose"  => \$opt_verbose,
      ) or die "error";
  
      error("--base is required") unless $opt_base;
  
      my (@packages) = @{$self->{argv} || []};
  
      my $snapshot = App::stew::snapshot->new(base => $opt_base);
      $snapshot->load;
  
      foreach my $package (@packages) {
          if (!$snapshot->is_installed($package)) {
              warn "$package not installed. Skipping";
          }
          else {
              debug sprintf "Uninstalling '%s'...", $package;
              my $info = $snapshot->get_package($package);
  
              foreach my $file (@{$info->{files}}) {
                  _unlink $file;
              }
  
              $snapshot->mark_uninstalled($package);
          }
      }
  }
  
  1;
APP_STEW_CMD_UNINSTALL

$fatpacked{"App/stew/env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_ENV';
  package App::stew::env;
  
  use strict;
  use warnings;
  
  use App::stew::util qw(debug);
  
  sub setup {
      _unshift_env(PATH => "$ENV{PREFIX}/bin");
  
      _unshift_env(LIBPATH         => "$ENV{PREFIX}/lib");
      _unshift_env(LIBRARY_PATH    => "$ENV{PREFIX}/lib");
      _unshift_env(LD_LIBRARY_PATH => "$ENV{PREFIX}/lib");
  
      _unshift_env(CPATH              => "$ENV{PREFIX}/include");
      _unshift_env(C_INCLUDE_PATH     => "$ENV{PREFIX}/include");
      _unshift_env(CPLUS_INCLUDE_PATH => "$ENV{PREFIX}/include");
  }
  
  sub _unshift_env {
      my ($var, $value) = @_;
  
      if ($ENV{$var}) {
          $ENV{$var} = "$value:$ENV{$var}";
      }
      else {
          $ENV{$var} = $value;
      }
  
      debug "Setting ENV{$var}=$ENV{$var}";
  }
  
  1;
APP_STEW_ENV

$fatpacked{"App/stew/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_FILE';
  package App::stew::file;
  
  use strict;
  use warnings;
  
  use App::stew::util qw(slurp_file error);
  
  sub new {
      my $class = shift;
  
      my $self = {};
      bless $self, $class;
  
      return $self;
  }
  
  sub parse {
      my $class = shift;
      my ($stew_file, $type) = @_;
  
      #_logn("Parsing '$stew_file'");
  
      my $content = slurp_file($stew_file);
  
      my $stew_class = $class->_sandbox($stew_file, $content, $type);
      return $stew_class->new;
  }
  
  sub _sandbox {
      my $self = shift;
      my ($file, $content, $type) = @_;
  
      $type = '' unless defined $type;
  
      my $class_name = 'stew::_build_' . _rand_str();
  
      my $package = <<"EOP";
      package $class_name;
      use strict;
      use warnings;
      my \$name;
      my \$version;
      my \$package;
      my \$file;
      my \@depends;
      my \@makedepends;
  
      sub new {
          my \$class = shift;
  
          my \$self = {};
          bless \$self, \$class;
  
          return \$self;
      }
  
      sub is_dependency     { '$type' eq 'depends' }
      sub is_makedependency { '$type' eq 'makedepends' }
  
      sub name        { \$name }
      sub version     { \$version }
      sub package     { \$package }
      sub file        { \$file }
      sub depends     { \@depends }
      sub makedepends { \@makedepends }
  
      my \$phases = {};
      sub download(&)    { \$phases->{download}    = shift }
      sub prepare(&)     { \$phases->{prepare}     = shift }
      sub build(&)       { \$phases->{build}       = shift }
      sub install(&)     { \$phases->{install}     = shift }
      sub postinstall(&) { \$phases->{postinstall} = shift }
  
      sub phase { \$phases->{\$_[1]} }
  
      sub run {
          my \$self = shift;
          my (\$phase) = \@_;
  
          if (\$phases->{\$phase}) {
              return \$phases->{\$phase}->()
          }
  
          return;
      }
      $content
      1;
  EOP
  
      eval $package or error("Error compiling '$file': $@");
  
      return $class_name;
  }
  
  sub _rand_str {
      my @alpha = ('0' .. '9', 'a' .. 'z', 'A' .. 'Z');
      my $str = '';
  
      $str .= $alpha[rand($#alpha)] for 1 .. 16;
  
      return $str;
  }
  
  1;
APP_STEW_FILE

$fatpacked{"App/stew/repo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_REPO';
  package App::stew::repo;
  
  use strict;
  use warnings;
  
  use HTTP::Tiny;
  use File::Basename ();
  use File::Path ();
  use App::stew::util qw(debug _copy);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{path} = $params{path};
      $self->{path} .= '/' unless $self->{path} =~ m{/$};
  
      return $self;
  }
  
  sub mirror_stew {
      my $self = shift;
      my ($name, $to) = @_;
  
      my $full_name = $self->{path} . File::Spec->catfile('stew', $name . '.stew');
  
      return $self->mirror_file($full_name, $to);
  }
  
  sub mirror_src {
      my $self = shift;
      my ($os, $arch, $filename, $to) = @_;
  
      my $full_name = $self->{path} . File::Spec->catfile('src', $filename);
  
      return $self->mirror_file($full_name, $to);
  }
  
  sub mirror_dist {
      my $self = shift;
      my ($os, $arch, $name, $to) = @_;
  
      my $full_name = $self->{path} . File::Spec->catfile('dist', $os, $arch, $name . '-dist.tar.gz');
  
      return $self->mirror_file($full_name, $to);
  }
  
  sub mirror_file {
      my $self = shift;
      my ($in, $out) = @_;
  
      debug("Mirroring '$in' to '$out'");
  
      File::Path::mkpath(File::Basename::dirname($out));
  
      if ($in =~ m/^http/) {
          HTTP::Tiny->new->mirror($in, $out);
      }
      else {
          return 0 unless -f $in;
  
          _copy($in, $out);
      }
  
      return 1;
  }
  
  1;
APP_STEW_REPO

$fatpacked{"App/stew/snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_SNAPSHOT';
  package App::stew::snapshot;
  
  use strict;
  use warnings;
  
  use File::Spec   ();
  use Data::Dumper ();
  use Carp qw(croak);
  use App::stew::util qw(slurp_file write_file);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{base} = $params{base};
      croak 'base is required' unless $self->{base};
  
      $self->{snapshot} = {};
      $self->load;
  
      return $self;
  }
  
  sub is_installed {
      my $self = shift;
      my ($stew) = @_;
  
      my $package = ref $stew ? $stew->package : $stew;
  
      if ($self->{snapshot}->{$package}) {
          return 1;
      }
  
      return 0;
  }
  
  sub get_package {
      my $self = shift;
      my ($package) = @_;
  
      return $self->{snapshot}->{$package};
  }
  
  sub load {
      my $self = shift;
  
      my $install_file = $self->_install_file;
  
      my $installed = {};
      if (-e $install_file) {
          no strict;
          $installed = eval slurp_file($install_file);
      }
  
      $self->{snapshot} = $installed;
  
      return $self->{snapshot};
  }
  
  sub mark_installed {
      my $self = shift;
      my ($stew, $files) = @_;
  
      $self->{snapshot}->{$stew->package} = {};
      $self->{snapshot}->{$stew->package}->{files} = [@$files];
      $self->store;
  
      return $self;
  }
  
  sub mark_uninstalled {
      my $self = shift;
      my ($stew) = @_;
  
      my $package = ref $stew ? $stew->package : $stew;
  
      delete $self->{snapshot}->{$package};
      $self->store;
  
      return $self;
  }
  
  sub store {
      my $self = shift;
  
      write_file($self->_install_file, Data::Dumper::Dumper($self->{snapshot}));
  
      return $self;
  }
  
  sub _install_file {
      my $self = shift;
  
      return File::Spec->catfile($self->{base}, 'stew.snapshot');
  }
  
  1;
APP_STEW_SNAPSHOT

$fatpacked{"App/stew/util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_UTIL';
  package App::stew::util;
  
  use strict;
  use warnings;
  
  use base 'Exporter';
  
  our @EXPORT_OK = qw(info debug error slurp_file write_file cmd _chdir _mkpath _copy _unlink _tree _tree_diff);
  
  use File::Find qw(find);
  use Carp qw(croak);
  use File::Copy qw(copy);
  use File::Path qw(mkpath rmtree);
  
  sub slurp_file {
      my ($file) = @_;
  
      local $/;
      open my $fh, '<', $file or error("Can't read file '$file': $!");
      return <$fh>;
  }
  
  sub write_file {
      my ($file, $content) = @_;
  
      open my $fh, '>', $file or error("Can't write file '$file': $!");
      print $fh $content;
      close $fh;
  }
  
  sub debug {
      print STDERR @_, "\n" if $ENV{STEW_LOG_LEVEL};
  
      _log(@_);
  }
  
  sub info {
      _log(@_);
      warn join(' ', @_) . "\n";
  }
  
  sub error {
      _log(@_);
      croak("ERROR: " . join(' ', @_));
  }
  
  sub _chdir {
      my ($dir) = @_;
  
      debug(qq{Entering '$dir'});
      die "Directory '$dir' does not exist" unless -d $dir;
      chdir($dir);
  }
  
  sub _mkpath {
      my ($dir) = @_;
  
      debug(qq{Creating '$dir'});
      mkpath($dir);
  }
  
  sub _copy {
      my ($from, $to) = @_;
  
      debug(qq{Copying '$from' -> '$to'});
      copy($from, $to) or croak "Cant copy '$from' -> '$to'";
  }
  
  sub _unlink {
      my ($file) = @_;
  
      debug(qq{Unlinking '$file'});
      unlink($file);
  }
  
  sub cmd {
      return unless @_;
  
      my $cmd = join ' && ', @_;
  
      $cmd = "sh -c \"$cmd 2>&1\" 2>&1 >> $ENV{STEW_LOG_FILE}";
  
      debug($cmd);
  
      #unless ($opt_dry_run) {
      my $exit = system($cmd);
  
      error("Command failed: $cmd") if $exit;
  
      #}
  }
  
  sub _log {
      open my $fh, '>>', $ENV{STEW_LOG_FILE}
        or die "Can't open logfile '$ENV{STEW_LOG_FILE}': $!";
      print $fh @_, "\n";
      close $fh;
  }
  
  sub _tree {
      my ($dir, $prefix) = @_;
  
      my @tree;
      find(
          sub {
              return unless -f $_;
  
              my $name = $File::Find::name;
  
              if ($prefix) {
                  $name =~ s{^$prefix}{};
                  $name = "/$name" unless $name =~ m{^/};
              }
  
              push @tree, $name;
          },
          $dir
      );
  
      return [sort @tree];
  }
  
  sub _tree_diff {
      my ($tree1, $tree2) = @_;
  
      my @diff;
      my $diff_pos = 0;
  
      for (my $pos = 0; $pos < @$tree1; $pos++) {
          while ($diff_pos < @$tree2
              && $tree1->[$pos] ne $tree2->[$diff_pos])
          {
              push @diff, $tree2->[$diff_pos];
              $diff_pos++;
          }
  
          if ($diff_pos < @$tree2 && $tree1->[$pos] eq $tree2->[$diff_pos]) {
              $diff_pos++;
              next;
          }
  
          last if $diff_pos >= @$tree2;
      }
  
      while ($diff_pos < @$tree2) {
          push @diff, $tree2->[$diff_pos];
          $diff_pos++;
      }
  
      return \@diff;
  }
  
  1;
APP_STEW_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use App::stew::util qw(error);
use App::stew::cmd::install;
use App::stew::cmd::list_installed;
use App::stew::cmd::uninstall;

my $command = shift @ARGV;

if (!$command) {
}
elsif ($command eq 'install') {
    App::stew::cmd::install->new(argv => \@ARGV)->run;
}
elsif ($command eq 'list-installed') {
    App::stew::cmd::list_installed->new(argv => \@ARGV)->run;
}
elsif ($command eq 'uninstall') {
    App::stew::cmd::uninstall->new(argv => \@ARGV)->run;
}
else {
    error qq{Unknown command '$command'};
}
