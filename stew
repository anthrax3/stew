#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/stew.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW';
  package App::stew;
  use 5.008001;
  use strict;
  use warnings;
  
  our $VERSION = "0.01";
  
  
  
  1;
  __END__
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::stew - stew your binaries!
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Viacheslav Tykhanovskyi, C<vti@cpan.org>.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2015, Viacheslav Tykhanovskyi.
  
  This program is free software, you can redistribute it and/or modify it under
  the same terms as Perl 5.10.
  
  =cut
APP_STEW

$fatpacked{"App/stew/builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_BUILDER';
  package App::stew::builder;
  
  use strict;
  use warnings;
  
  use File::Copy qw(copy);
  use File::Path qw(mkpath rmtree);
  use App::stew::util qw(cmd info debug);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{root_dir}  = $params{root_dir};
      $self->{build_dir} = $params{build_dir};
      $self->{cache}     = $params{cache};
      $self->{snapshot}  = $params{snapshot};
  
      return $self;
  }
  
  sub build {
      my $self = shift;
      my ($stew) = @_;
  
      if ($self->{snapshot}->is_installed($stew)) {
          info sprintf "'%s' is up to date\n", $stew->package;
          return;
      }
  
      info sprintf "Building & installing '%s'...\n", $stew->package;
  
      mkpath($ENV{PREFIX});
  
      info sprintf "Resolving dependencies...\n", $stew->package;
  
      $self->_resolve_dependencies($stew);
  
      info sprintf "Preparing '%s'...\n", $stew->package;
      $self->_prepare($stew);
  
      info sprintf "Building '%s'...\n", $stew->package;
      $self->_build($stew);
  
      cmd("mv $ENV{PREFIX} $ENV{PREFIX}_");
  
      eval {
          mkpath($ENV{PREFIX});
  
          info sprintf "Installing '%s'...\n", $stew->package;
          $self->_install($stew);
  
          my $dist_name = sprintf '%s-dist.tar.gz', $stew->package;
          cmd("cd $ENV{PREFIX}; tar czf $dist_name *");
  
          info sprintf "Caching '%s'...\n", $stew->package;
          $self->{cache}->cache_dist("$ENV{PREFIX}/$dist_name");
  
          cmd("cp -R $ENV{PREFIX}/* $ENV{PREFIX}_/");
          rmtree($ENV{PREFIX});
      };
  
      cmd("mv $ENV{PREFIX}_ $ENV{PREFIX}");
  
      if (!$@) {
          info sprintf "Done installing '%s'\n", $stew->package;
          $self->{snapshot}->mark_installed($stew);
      }
  
      return $self;
  }
  
  sub _prepare {
      my $self = shift;
      my ($stew) = @_;
  
      my $work_dir = File::Spec->catfile($self->{build_dir}, $stew->package);
  
      #warn "Creating '$work_dir'";
      mkpath($work_dir);
      chdir($work_dir);
  
      my $src_file = $self->{cache}->get_src_filepath($stew);
  
      #warn "Copying '$src_file' to '$work_dir'";
      copy($src_file, $work_dir);
  
      my @commands = $stew->run('prepare');
      cmd(@commands);
  }
  
  sub _build {
      my $self = shift;
      my ($stew) = @_;
  
      my @commands = $stew->run('build');
      cmd(@commands);
  }
  
  sub _install {
      my $self = shift;
      my ($stew) = @_;
  
      my @commands = $stew->run('install');
      cmd(@commands);
  }
  
  sub _resolve_dependencies {
      my $self = shift;
      my ($stew) = @_;
  
      my $build_dir = $self->{build_dir};
      my $work_dir = File::Spec->catfile($build_dir, $stew->package);
  
      my @makedepends = $stew->makedepends;
      if (@makedepends) {
          info "Found make dependencies: @makedepends\n";
      }
      foreach my $makedepends (@makedepends) {
          my $stew_file = $self->{cache}->get_stew_filepath($makedepends);
          my $stew      = App::stew::file->parse($stew_file);
  
          chdir $self->{root_dir};
  
          info sprintf "Preparing make dependency '%s'\n", $stew->package;
          $self->_prepare($stew);
  
          chdir $self->{root_dir};
  
          if (!-e sprintf '%s/%s', $work_dir, $stew->package) {
              cmd(sprintf "ln -s $build_dir/%s/%s $work_dir",
                  $stew->package, $stew->package);
          }
      }
  
      my @depends = $stew->depends;
      if (@depends) {
          info "Found dependencies: @depends\n";
      }
      foreach my $depends (@depends) {
          my $stew_file = $self->{cache}->get_stew_filepath($depends);
          my $stew      = App::stew::file->parse($stew_file);
  
          chdir $self->{root_dir};
  
          $self->build($stew);
  
          chdir $self->{root_dir};
      }
  }
  
  1;
APP_STEW_BUILDER

$fatpacked{"App/stew/cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_CACHE';
  package App::stew::cache;
  
  use strict;
  use warnings;
  
  use File::Spec ();
  use File::Copy qw(copy);
  use File::Basename ();
  use App::stew::file;
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{path} = $params{path};
      $self->{repo} = $params{repo};
      $self->{os}   = $params{os};
      $self->{arch} = $params{arch};
  
      return $self;
  }
  
  sub sync_stew {
      my $self = shift;
      my ($name, $type) = @_;
  
      my $stew = $self->_get_stew($name, $type);
  
      $self->_get_src($stew);
      $self->_get_dist($stew);
  
      my @makedepends = $stew->makedepends;
      foreach my $makedepends (@makedepends) {
          $self->sync_stew($makedepends, 'makedepends');
      }
  
      my @depends = $stew->depends;
      foreach my $depends (@depends) {
          $self->sync_stew($depends, 'depends');
      }
  
      return $stew;
  }
  
  sub cache_dist {
      my $self = shift;
      my ($dist_path) = @_;
  
      my $to = File::Spec->catfile($self->{path}, '.cache', 'dist',
          $self->{os}, $self->{arch}, File::Basename::basename($dist_path));
  
      #warn "Caching '$dist_path' to '$to'";
  
      copy $dist_path, $to;
  }
  
  sub get_stew_filepath {
      my $self = shift;
      my ($name) = @_;
  
      return File::Spec->catfile($self->{path}, '.cache', 'stew',
          $name . '.stew');
  }
  
  sub get_src_filepath {
      my $self = shift;
      my ($stew) = @_;
  
      return File::Spec->catfile($self->{path}, '.cache', 'src', $stew->file);
  }
  
  sub get_dist_filepath {
      my $self = shift;
      my ($stew) = @_;
  
      return File::Spec->catfile($self->{path}, '.cache', 'dist',
          $stew->package . '-dist.tar.gz');
  }
  
  sub _get_stew {
      my $self = shift;
      my ($name, $type) = @_;
  
      my $local_path = $self->get_stew_filepath($name);
      #warn "Checking local cache '$local_path'";
      if (!-e $local_path) {
          #warn "Getting from repository '$name'";
          $self->{repo}->mirror_stew($name, $local_path);
      }
  
      die qq{Cannot get stew file for '$name'} unless -e $local_path;
  
      return $self->_parse_stew($local_path, $type);
  }
  
  sub _get_src {
      my $self = shift;
      my ($stew) = @_;
  
      my $local_path = $self->get_src_filepath($stew);
      #warn "Checking local cache '$local_path'";
      if (!-e $local_path) {
          #warn sprintf "Getting from repository '%s'", $stew->file;
          $self->{repo}
            ->mirror_src($self->{os}, $self->{arch}, $stew->file, $local_path);
      }
  
      die sprintf qq{Cannot get source file for '%s'}, $stew->file
        unless -e $local_path;
  
      return;
  }
  
  sub _get_dist {
      my $self = shift;
      my ($stew) = @_;
  
      my $local_path = $self->get_dist_filepath($stew);
      if (!-e $local_path) {
          $self->{repo}->mirror_dist($self->{os}, $self->{arch}, $stew->package,
              $local_path);
      }
  
      return unless -e $local_path;
      return $local_path;
  }
  
  sub _parse_stew {
      my $self = shift;
      my ($file, $type) = @_;
  
      return App::stew::file->parse($file, $type);
  }
  
  1;
APP_STEW_CACHE

$fatpacked{"App/stew/env.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_ENV';
  package App::stew::env;
  
  use strict;
  use warnings;
  
  sub setup {
      _unshift_env(PATH => "$ENV{PREFIX}/bin");
  
      _unshift_env(LIBPATH         => "$ENV{PREFIX}/lib");
      _unshift_env(LIBRARY_PATH    => "$ENV{PREFIX}/lib");
      _unshift_env(LD_LIBRARY_PATH => "$ENV{PREFIX}/lib");
  
      _unshift_env(CPATH              => "$ENV{PREFIX}/include");
      _unshift_env(C_INCLUDE_PATH     => "$ENV{PREFIX}/include");
      _unshift_env(CPLUS_INCLUDE_PATH => "$ENV{PREFIX}/include");
  }
  
  sub _unshift_env {
      my ($var, $value) = @_;
  
      if ($ENV{$var}) {
          $ENV{$var} = "$value:$ENV{$var}";
      }
      else {
          $ENV{$var} = $value;
      }
  }
  
  1;
APP_STEW_ENV

$fatpacked{"App/stew/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_FILE';
  package App::stew::file;
  
  use strict;
  use warnings;
  
  use App::stew::util qw(slurp_file);
  
  sub new {
      my $class = shift;
  
      my $self = {};
      bless $self, $class;
  
      return $self;
  }
  
  sub parse {
      my $class = shift;
      my ($stew_file, $type) = @_;
  
      #_logn("Parsing '$stew_file'");
  
      my $content = slurp_file($stew_file);
  
      my $stew_class = $class->_sandbox($stew_file, $content, $type);
      return $stew_class->new;
  }
  
  sub _sandbox {
      my $self = shift;
      my ($file, $content, $type) = @_;
  
      $type = '' unless defined $type;
  
      my $class_name = 'stew::_build_' . _rand_str();
  
      my $package = <<"EOP";
      package $class_name;
      use strict;
      use warnings;
      my \$name;
      my \$version;
      my \$package;
      my \$file;
      my \@depends;
      my \@makedepends;
  
      sub new {
          my \$class = shift;
  
          my \$self = {};
          bless \$self, \$class;
  
          return \$self;
      }
  
      sub is_dependency     { '$type' eq 'depends' }
      sub is_makedependency { '$type' eq 'makedepends' }
  
      sub name        { \$name }
      sub version     { \$version }
      sub package     { \$package }
      sub file        { \$file }
      sub depends     { \@depends }
      sub makedepends { \@makedepends }
  
      my \$phases = {};
      sub download(&)    { \$phases->{download}    = shift }
      sub prepare(&)     { \$phases->{prepare}     = shift }
      sub build(&)       { \$phases->{build}       = shift }
      sub install(&)     { \$phases->{install}     = shift }
      sub postinstall(&) { \$phases->{postinstall} = shift }
  
      sub phase { \$phases->{\$_[1]} }
  
      sub run {
          my \$self = shift;
          my (\$phase) = \@_;
  
          if (\$phases->{\$phase}) {
              return \$phases->{\$phase}->()
          }
  
          return;
      }
      $content
      1;
  EOP
  
      eval $package or _error("Error compiling '$file': $@");
  
      return $class_name;
  }
  
  sub _rand_str {
      my @alpha = ('0' .. '9', 'a' .. 'z', 'A' .. 'Z');
      my $str = '';
  
      $str .= $alpha[rand($#alpha)] for 1 .. 16;
  
      return $str;
  }
  
  1;
APP_STEW_FILE

$fatpacked{"App/stew/repo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_REPO';
  package App::stew::repo;
  
  use strict;
  use warnings;
  
  use HTTP::Tiny;
  use File::Copy ();
  use File::Basename ();
  use File::Path ();
  use App::stew::util qw(debug);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{path} = $params{path};
      $self->{path} .= '/' unless $self->{path} =~ m{/$};
  
      return $self;
  }
  
  sub mirror_stew {
      my $self = shift;
      my ($name, $to) = @_;
  
      my $full_name = $self->{path} . File::Spec->catfile('stew', $name . '.stew');
  
      return $self->mirror_file($full_name, $to);
  }
  
  sub mirror_src {
      my $self = shift;
      my ($os, $arch, $filename, $to) = @_;
  
      my $full_name = $self->{path} . File::Spec->catfile('src', $filename);
  
      return $self->mirror_file($full_name, $to);
  }
  
  sub mirror_dist {
      my $self = shift;
      my ($os, $arch, $name, $to) = @_;
  
      my $full_name = $self->{path} . File::Spec->catfile('cache', $os, $arch, $name . '-dist.tar.gz');
  
      return $self->mirror_file($full_name, $to);
  }
  
  sub mirror_file {
      my $self = shift;
      my ($in, $out) = @_;
  
      debug("Mirroring '$in' to '$out'");
  
      File::Path::mkpath(File::Basename::dirname($out));
  
      if ($in =~ m/^http/) {
          HTTP::Tiny->new->mirror($in, $out);
      }
      else {
          File::Copy::copy($in, $out) or return 0;
      }
  
      return 1;
  }
  
  1;
APP_STEW_REPO

$fatpacked{"App/stew/snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_SNAPSHOT';
  package App::stew::snapshot;
  
  use strict;
  use warnings;
  
  use File::Spec   ();
  use Data::Dumper ();
  use App::stew::util qw(slurp_file write_file);
  
  sub new {
      my $class = shift;
      my (%params) = @_;
  
      my $self = {};
      bless $self, $class;
  
      $self->{base} = $params{base};
  
      $self->{snapshot} = {};
      $self->load;
  
      return $self;
  }
  
  sub is_installed {
      my $self = shift;
      my ($stew) = @_;
  
      if ($self->{snapshot}->{$stew->package}) {
          return 1;
      }
  
      return 0;
  }
  
  sub load {
      my $self = shift;
  
      my $install_file = $self->_install_file;
  
      my $installed = {};
      if (-e $install_file) {
          no strict;
          $installed = eval slurp_file($install_file);
      }
  
      $self->{snapshot} = $installed;
  
      return $self;
  }
  
  sub mark_installed {
      my $self = shift;
      my ($stew) = @_;
  
      $self->{snapshot}->{$stew->package}++;
      $self->store;
  
      return $self;
  }
  
  sub store {
      my $self = shift;
  
      write_file($self->_install_file, Data::Dumper::Dumper($self->{snapshot}));
  
      return $self;
  }
  
  sub _install_file {
      my $self = shift;
  
      return File::Spec->catfile($self->{base}, 'stew.snapshot');
  }
  
  1;
APP_STEW_SNAPSHOT

$fatpacked{"App/stew/util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_STEW_UTIL';
  package App::stew::util;
  
  use strict;
  use warnings;
  
  use base 'Exporter';
  
  our @EXPORT_OK = qw(info debug error slurp_file write_file cmd);
  
  use Carp qw(croak);
  
  sub debug {
      print STDERR @_, "\n" if $ENV{STEW_LOG_LEVEL};
  
      open my $fh, '>>', $ENV{STEW_LOG_FILE}
        or die "Can't open logfile '$ENV{STEW_LOG_FILE}': $!";
      print $fh @_, "\n";
      close $fh;
  }
  
  sub slurp_file {
      my ($file) = @_;
  
      local $/;
      open my $fh, '<', $file or _error("Can't read file '$file': $!");
      return <$fh>;
  }
  
  sub write_file {
      my ($file, $content) = @_;
  
      open my $fh, '>', $file or _error("Can't write file '$file': $!");
      print $fh $content;
      close $fh;
  }
  
  sub info {
      warn join(' ', @_) . "\n";
  }
  
  sub error {
      debug(@_);
      croak("ERROR: " . join(' ', @_));
  }
  
  sub cmd {
      return unless @_;
  
      my $cmd = join ' && ', @_;
  
      #my $redirect = $opt_verbose ? '' : ' > /dev/null';
      $cmd = "sh -c \"$cmd 2>&1 > /dev/null\" 2>&1 >> /dev/null";
  
      #warn $cmd;
      #_logn($cmd);
  
      #unless ($opt_dry_run) {
          my $exit = system($cmd);
  
          _error("Command failed: $cmd") if $exit;
      #}
  }
  
  1;
APP_STEW_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use Cwd qw(cwd abs_path);
use File::Path qw(mkpath);
use File::Spec;
use Getopt::Long;
use App::stew::repo;
use App::stew::cache;
use App::stew::builder;
use App::stew::snapshot;
use App::stew::env;
use App::stew::util qw(info debug error);

my $opt_base;
my $opt_prefix = 'local';
my $opt_repo;
my $opt_os;
my $opt_arch;
my $opt_build = 'build';
my $opt_dry_run;
my $opt_verbose;
GetOptions(
    "base=s"   => \$opt_base,
    "prefix=s" => \$opt_prefix,
    "repo=s"   => \$opt_repo,
    "os=s"     => \$opt_os,
    "arch=s"   => \$opt_arch,
    "build=s"  => \$opt_build,
    "dry-run"  => \$opt_dry_run,
    "verbose"  => \$opt_verbose,
) or error("Error in command line arguments");

chomp($opt_os //= `uname -s`);
$opt_os = lc $opt_os;
chomp($opt_arch //= `uname -m`);
$opt_arch = lc $opt_arch;

error("--base is required") unless $opt_base;
error("--repo is required") unless $opt_repo;

my (@packages) = @ARGV;

my $root_dir  = abs_path(cwd());
my $build_dir = abs_path($opt_build);
mkpath($build_dir);

my $repo = App::stew::repo->new(path => $opt_repo);
my $cache = App::stew::cache->new(
    path => $build_dir,
    repo => $repo,
    os   => $opt_os,
    arch => $opt_arch
);
my $snapshot = App::stew::snapshot->new(base => $opt_base)->load;
my $builder = App::stew::builder->new(
    root_dir  => $root_dir,
    build_dir => $build_dir,
    cache     => $cache,
    snapshot  => $snapshot
);

$ENV{STEW_LOG_LEVEL} = $opt_verbose ? 1 : 0;
$ENV{STEW_LOG_FILE} = "$build_dir/stew.log";

warn "Updating local repository...\n";

my @stew_pkgs;
foreach my $package (@packages) {
    push @stew_pkgs, $cache->sync_stew($package);
}

unless (@stew_pkgs) {
    error("No packages were found");
}

$ENV{STEW_OS}   = $opt_os;
$ENV{STEW_ARCH} = $opt_arch;
$ENV{PREFIX}    = File::Spec->catfile($opt_base, $opt_prefix);

App::stew::env->setup;

foreach my $stew_pkg (@stew_pkgs) {
    $builder->build($stew_pkg);
}

info("Done");
