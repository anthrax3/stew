#!/usr/bin/env perl

use strict;
use warnings;

use Cwd qw(cwd abs_path);
use File::Path qw(mkpath rmtree);
use Getopt::Long;
use HTTP::Tiny;

if (-e '.stewrc') {
    my $rc = _slurp('.stewrc');
    unshift @ARGV, grep { !/^#/ } split /\r?\n/, $rc;
}

my $opt_prefix;
my $opt_repo;
my $opt_os;
my $opt_arch;
my $opt_build;
my $opt_stewfile = 'stewfile';
my $opt_dry_run;
my $opt_keep_downloads;
my $opt_verbose;
GetOptions(
    "prefix=s"       => \$opt_prefix,
    "repo=s"         => \$opt_repo,
    "os=s"           => \$opt_os,
    "arch=s"         => \$opt_arch,
    "build=s"        => \$opt_build,
    "stewfile=s"     => \$opt_stewfile,
    "dry-run"        => \$opt_dry_run,
    "keep-downloads" => \$opt_keep_downloads,
    "verbose"        => \$opt_verbose,
) or _error("Error in command line arguments");

_error("--prefix is required") unless $opt_prefix;
_error("--repo is required")   unless $opt_repo;
_error("--build is required")  unless $opt_build;
_error("--os is required")     unless $opt_os;
_error("--arch is required")   unless $opt_arch;
_error("stewfile not found, use --stewfile to specify the path")
  unless $opt_stewfile && -f $opt_stewfile;

my (@packages) = @ARGV;

my $root_dir       = abs_path(cwd());
my $build_dir      = abs_path($opt_build);
my $cache_dir      = "$build_dir/.cache";
my $stew_cache_dir = "$cache_dir/stew";
my $dist_cache_dir = "$cache_dir/dist";
rmtree($cache_dir) unless $opt_keep_downloads;
mkpath($cache_dir);
mkpath($stew_cache_dir);
mkpath($dist_cache_dir);
mkpath($opt_prefix);

my $log_file = "$build_dir/stew.log";

_logn("Parsing '$opt_stewfile'");
my @stew_files = map { "$_.stew" } grep { !/^#/ && length } split /\r?\n/,
  _slurp($opt_stewfile);
_logn(sprintf 'Found %d packages in stewfile', scalar @stew_files);

my @stew_pkgs;
foreach my $stew_file (@stew_files) {
    if (@packages && !grep { $stew_file =~ m/^$_/ } @packages) {
        _logn("Skipping $stew_file");
        next;
    }

    push @stew_pkgs, _get_stew($stew_file);
}

unless (@stew_pkgs) {
    _error("No packages were found");
}

foreach my $stew_pkg (@stew_pkgs) {
    _build_stew($stew_pkg);
}

_logn("Done");

sub _get_stew {
    my ($stew_file, $type) = @_;

    if (!-e "$stew_cache_dir/$stew_file") {
        _logn("Getting stew '$stew_file' from repository...");

        _get_file_from_repo("$opt_repo/stew/$stew_file",
            "$stew_cache_dir/$stew_file");
        _error("Cannot get stew '$stew_file' from repository")
          unless -e "$stew_cache_dir/$stew_file";
    }

    my $stew = _parse_stew($stew_file, $type);

    my @stews;
    push @stews, $stew;

    my @depends = $stew->depends;
    foreach my $depends (@depends) {
        unshift @stews, _get_stew("$depends.stew", 'depends');
    }

    my @makedepends = $stew->makedepends;
    foreach my $makedepends (@makedepends) {
        unshift @stews, _get_stew("$makedepends.stew", 'makedepends');
    }

    return @stews;
}

sub _parse_stew {
    my ($stew_file, $type) = @_;

    _logn("Parsing '$stew_file'");

    my $content = _slurp("$stew_cache_dir/$stew_file");

    my $stew_class = _sandbox($stew_file, $content, $type);
    return $stew_class->new;
}

sub _build_stew {
    my ($stew) = @_;

    chdir $root_dir;

    my $stew_dist  = join '-', $stew->name, $stew->version;
    my $stew_name  = $stew->name;
    my $stew_file  = $stew->file;
    my $stew_build = $stew_dist . '-dist.tar.gz';

    _logn("Building and installing '$stew_dist'...");

    _log("Checking if repo has cached dist file...");
    if (!-e "$dist_cache_dir/$stew_build") {
        _logn("no");

        _get_file_from_repo("$opt_repo/cache/$opt_os/$opt_arch/$stew_build",
            "$dist_cache_dir/$stew_build");
    }

    if (-e "$dist_cache_dir/$stew_build") {
        _logn("yes. Using it");

        _system("tar xzf '$dist_cache_dir/$stew_build' -C $opt_prefix");
    }
    else {
        my $work_dir = "$build_dir/" . $stew->name;
        rmtree($work_dir);
        mkpath($work_dir);

        _logn('Symlinking dependencies...');
        _symlink_depends($stew, $work_dir);

        _logn('    > DOWNLOAD');
        if (my $download_cb = $stew->phase('download')) {
            chdir $work_dir;
            my @commands = $download_cb->();
            _system(@commands);
        }
        else {
            _get_file_from_repo("$opt_repo/src/$stew_file",
                "$work_dir/$stew_file");
        }
        _error("Getting file '$stew_file' failed")
          unless -e "$work_dir/$stew_file";

        local $ENV{STEW_OS}   = $opt_os;
        local $ENV{STEW_ARCH} = $opt_arch;
        local $ENV{PREFIX}    = $opt_prefix;

        local $ENV{PATH}            = "$ENV{PREFIX}/bin:$ENV{PATH}";
        local $ENV{LIBPATH}         = "$ENV{PREFIX}/lib:$ENV{LIBPATH}";
        local $ENV{LIBRARY_PATH}    = "$ENV{PREFIX}/lib:$ENV{LIBRARY_PATH}";
        local $ENV{LD_LIBRARY_PATH} = "$ENV{PREFIX}/lib:$ENV{LD_LIBRARY_PATH}";

        local $ENV{CPATH}              = "$ENV{PREFIX}/include:$ENV{CPATH}";
        local $ENV{C_INCLUDE_PATH}     = "$ENV{PREFIX}/include:$ENV{C_INCLUDE_PATH}";
        local $ENV{CPLUS_INCLUDE_PATH} = "$ENV{PREFIX}/include:$ENV{CPLUS_INCLUDE_PATH}";

        chdir $work_dir;
        _prepare($stew);

        if ($stew->is_makedependency) {
            _logn("This is a make dependency '$stew_dist'. Build canceled");
            return;
        }

        chdir $work_dir;
        _build($stew);

        _system("mv $opt_prefix $opt_prefix.prev") if -d $opt_prefix;

        chdir $work_dir;
        _install($stew);

        chdir $work_dir;
        _postinstall($stew);

        if (!-e "$dist_cache_dir/$stew_build") {
            _logn("    > CACHING");

            _system("cd $opt_prefix", "tar czf $stew_build *");
            _system("cd $opt_prefix", "mv $stew_build $dist_cache_dir/");

            mkpath("$dist_cache_dir/new/$opt_os/$opt_arch/");
            unlink("$dist_cache_dir/new/$opt_os/$opt_arch/$stew_build");
            _system("ln -s $dist_cache_dir/$stew_build $dist_cache_dir/new/$opt_os/$opt_arch/");
        }

        if (-d "$opt_prefix.prev") {
            _system("cp --remove-destination -R $opt_prefix/* $opt_prefix.prev/");
            _system("rm -rf $opt_prefix");

            _system("mv $opt_prefix.prev $opt_prefix");
        }
    }

    _logn("Done building '$stew_dist'");
}

sub _symlink_depends {
    my ($stew, $work_dir) = @_;

    my @depends = $stew->depends;
    foreach my $depend (@depends) {
        _symlink_depend($depend, $work_dir);
    }

    my @makedepends = $stew->makedepends;
    foreach my $makedepend (@makedepends) {
        _symlink_depend($makedepend, $work_dir);
    }
}

sub _symlink_depend {
    my ($depend, $work_dir) = @_;

    my ($stew) = grep { $_->name . '-' . $_->version eq $depend } @stew_pkgs;

    if ($stew) {
        _system(sprintf "ln -s $build_dir/%s/%s $work_dir",
            $stew->name, $stew->name . '-' . $stew->version);

        if ($stew->depends) {
            _symlink_depends($stew);
        }
    }
    else {
        _error("Cannot find dependency '$depend'");
    }
}

sub _get_file_from_repo {
    my ($in, $out) = @_;

    _logn("Getting '$in'...");

    if ($in =~ m/^http/) {
        HTTP::Tiny->new->mirror($in, $out);
    }
    else {
        if (-e $in) {
            system("cp $in $out");
        }
    }
}

sub _prepare {
    my ($stew) = @_;

    _logn("    > PREPARE");

    my @commands = $stew->run('prepare');
    _system(@commands);
}

sub _build {
    my ($stew) = @_;

    _logn("    > BUILD");

    my @commands = $stew->run('build');
    _system(@commands);
}

sub _install {
    my ($stew) = @_;

    _logn("    > INSTALL");

    my @commands = $stew->run('install');
    _system(@commands);
}

sub _postinstall {
    my ($stew) = @_;

    _logn("    > POST-INSTALL");

    my @commands = $stew->run('postinstall');
    _system(@commands);
}

sub _error {
    _logn(@_);
    die "ERROR: " . join(' ', @_), "\n";
}

sub _logn { _log(@_, "\n") }

sub _log {
    print STDERR @_;

    open my $fh, '>>', $log_file;
    print $fh @_;
    close $fh;
}

sub _system {
    return unless @_;

    my $cmd = join ' && ', @_;

    my $redirect = $opt_verbose ? '' : ' > /dev/null';
    $cmd = "sh -c \"$cmd\" 2>&1 >> $log_file$redirect";

    _logn($cmd);

    unless ($opt_dry_run) {
        my $exit = system($cmd);

        _error("Command failed: $cmd") if $exit;
    }
}

sub _slurp {
    my ($file) = @_;

    local $/;
    open my $fh, '<', $file or _error("Can't read file '$file': $!");
    return <$fh>;
}

sub _rand_str {
    my @alpha = ('0' .. '9', 'a' .. 'z', 'A' .. 'Z');
    my $str = '';

    $str .= $alpha[rand($#alpha)] for 1 .. 16;

    return $str;
}

sub _sandbox {
    my ($file, $content, $type) = @_;

    $type = '' unless defined $type;

    my $class_name = 'stew::_build_' . _rand_str();

    my $package = <<"EOP";
    package $class_name;
    use strict;
    use warnings;
    my \$name;
    my \$version;
    my \$package;
    my \$file;
    my \@depends;
    my \@makedepends;

    sub new {
        my \$class = shift;

        my \$self = {};
        bless \$self, \$class;

        return \$self;
    }

    sub is_dependency     { '$type' eq 'depends' }
    sub is_makedependency { '$type' eq 'makedepends' }

    sub name        { \$name }
    sub version     { \$version }
    sub package     { \$package }
    sub file        { \$file }
    sub depends     { \@depends }
    sub makedepends { \@makedepends }

    my \$phases = {};
    sub download(&)    { \$phases->{download}    = shift }
    sub prepare(&)     { \$phases->{prepare}     = shift }
    sub build(&)       { \$phases->{build}       = shift }
    sub install(&)     { \$phases->{install}     = shift }
    sub postinstall(&) { \$phases->{postinstall} = shift }

    sub phase { \$phases->{\$_[1]} }

    sub run {
        my \$self = shift;
        my (\$phase) = \@_;

        if (\$phases->{\$phase}) {
            return \$phases->{\$phase}->()
        }

        return;
    }
    $content
    1;
EOP

    eval $package or _error("Error compiling '$file': $@");

    return $class_name;
}
